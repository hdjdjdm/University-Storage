!<arch>
assert.h/       868562434   0     0     0       797       `
/*****************************************************************************/
/* assert.h   v1.10#                                                         */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _ASSERT
#define _ASSERT

void _nassert(int), _assert(int, char *);
void _abort_msg(char *);

#define _STR(x)  __STR(x)
#define __STR(x) #x

#if defined(NDEBUG)
#define assert(_ignore) ((void)0)

#elif defined(NASSERT)
#define assert(_expr)   _nassert(_expr)

#else
#define assert(_expr)   _assert((_expr),                                   \
                   "Assertion failed, (" _STR(_expr) "), file " __FILE__ \
		   ", line " _STR(__LINE__) "\n")
#endif
#endif


c60_32.h/       868562434   0     0     0       2880      `
/****************************************************************************/
/*  c60_32  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:07:54 EDT 1997 */

#ifndef __c60_32__
#define __c60_32__
#if 0
/*---------------------------------------------------------------------------*/
/* C60-specific 32-bit REAL (and other) behavior descriptions.               */
/*---------------------------------------------------------------------------*/
#endif

#ifndef _TMS320C6x
  #define _TMS320C6x 1
#endif

#define Adds_Per_Add  1 /* ratio of REAL add  to add */
#define Adds_Per_Mult 10/* ratio of REAL mult to add */
#define Adds_Per_Div  50/* ratio of REAL div  to add */

#define FLT_FIX_Faster_Than_MODF 0 /* (double)((int)(x)) faster than MODFF */

#define Floating_Sub_Has_Guard_Digit 0 /* safe value is 0 */

#undef Support_DENORM /* do not support denormalized numbers */
#undef Support_INFNAN /* do not support INFINITY's and NAN's */
#undef Support_SATURATION /* do not saturate overflows to MOST_POS,MOST_NEG */

#define INT_MOST_POS_P1 CNST( 2147483648.0) /* most pos int +1 as REAL */
#define INT_MOST_NEG    CNST(-2147483648.0) /* most neg int    as REAL */

#define BPAU 8    /* bits per Addressable Unit          */
#define BPchar 8  /* bits per char                      */
#define BPshrt 16 /* bits per short                     */
#define BPint 32  /* bits per int                       */
#define BPlong 40 /* bits per long (0 if not supported) */
#define BPREAL 32 /* bits per REAL when in MEMORY       */
#define BPLEAN 0  /* bits per next smallest REAL when in MEMORY */

#ifndef _LITTLE_ENDIAN
   #ifdef _BIG_ENDIAN
      #define _LITTLE_ENDIAN !(_BIG_ENDIAN)
   #endif
#endif

#define MSB_In_Hi_Addr _LITTLE_ENDIAN /* ENDIANness. 0=big, 1=little */

#define IEEE_Hardware _TMS320C6700 /* 1 if IEEE hardware present */

#if 0
/*---------------------------------------------------------------------------*/
/* Pick the integer size on top of which REAL is to be implemented.          */
/*---------------------------------------------------------------------------*/
#endif
#if ((1) || (BPint==BPREAL)) /* always choose int */
   #define BPbigint BPint
   #define bigint int
   #define biguns unsigned
#elif (BPint >= BPlong)
   #define BPbigint BPint
   #define bigint int
   #define biguns unsigned
#elif (BPlong==BPREAL)
   #define BPbigint BPlong
   #define bigint long
   #define biguns unsigned long
#else
   #define BPbigint BPlong
   #define bigint long
   #define biguns unsigned long
#endif

biguns _lmbd (biguns, biguns);
#define COUNT_LZERO(nnn) _lmbd(1, nnn)

#define Pointers_Might_Not_Work 1

#endif /*__c60_32_*/

c60_64.h/       868562434   0     0     0       2881      `
/****************************************************************************/
/*  c60_64  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:53 EDT 1997 */

#ifndef __c60_64__
#define __c60_64__
#if 0
/*---------------------------------------------------------------------------*/
/* C60-specific 64-bit REAL (and other) behavior descriptions.               */
/*---------------------------------------------------------------------------*/
#endif

#ifndef _TMS320C6x
  #define _TMS320C6x 1
#endif

#define Adds_Per_Add  1 /* ratio of REAL add  to add */
#define Adds_Per_Mult 10/* ratio of REAL mult to add */
#define Adds_Per_Div  50/* ratio of REAL div  to add */

#define FLT_FIX_Faster_Than_MODF 0 /* (double)((int)(x)) faster than MODFF */

#define Floating_Sub_Has_Guard_Digit 0 /* safe value is 0 */

#undef Support_DENORM /* do not support denormalized numbers */
#undef Support_INFNAN /* do not support INFINITY's and NAN's */
#undef Support_SATURATION /* do not saturate overflows to MOST_POS,MOST_NEG */

#define INT_MOST_POS_P1 CNST( 2147483648.0) /* most pos int +1 as REAL */
#define INT_MOST_NEG    CNST(-2147483648.0) /* most neg int    as REAL */

#define BPAU 8    /* bits per Addressable Unit          */
#define BPchar 8  /* bits per char                      */
#define BPshrt 16 /* bits per short                     */
#define BPint 32  /* bits per int                       */
#define BPlong 40 /* bits per long (0 if not supported) */
#define BPREAL 64 /* bits per REAL when in MEMORY       */
#define BPLEAN 32 /* bits per next smallest REAL when in MEMORY */


#ifndef _LITTLE_ENDIAN
   #ifdef _BIG_ENDIAN
      #define _LITTLE_ENDIAN !(_BIG_ENDIAN)
   #endif
#endif

#define MSB_In_Hi_Addr _LITTLE_ENDIAN /* ENDIANness. 0=big, 1=little */

#define IEEE_Hardware _TMS320C6700 /* 1 if IEEE hardware present */

#if 0
/*---------------------------------------------------------------------------*/
/* Pick the integer size on top of which REAL is to be implemented.          */
/*---------------------------------------------------------------------------*/
#endif
#if ((1) || (BPint==BPREAL)) /* always choose int */
   #define BPbigint BPint
   #define bigint int
   #define biguns unsigned
#elif (BPint >= BPlong)
   #define BPbigint BPint
   #define bigint int
   #define biguns unsigned
#elif (BPlong==BPREAL)
   #define BPbigint BPlong
   #define bigint long
   #define biguns unsigned long
#else
   #define BPbigint BPlong
   #define bigint long
   #define biguns unsigned long
#endif

biguns _lmbd (biguns, biguns);
#define COUNT_LZERO(nnn) _lmbd(1, nnn)

#define Pointers_Might_Not_Work 1

#endif /*__c60_64_*/


c6x.h/          868562434   0     0     0       1663      `
unsigned _extu	  (unsigned, unsigned, unsigned);
int      _ext	  (unsigned, unsigned, int);
unsigned _set	  (unsigned, unsigned, unsigned);
unsigned _clr	  (unsigned, unsigned, unsigned);
int      _sadd	  (int,      int);
long     _lsadd	  (int,      long);
int	 _ssub	  (int,      int);
long	 _lssub	  (int,      long);
int      _sshl	  (int,      unsigned);
int	 _add2	  (int,      int);
int	 _sub2	  (int,      int);
unsigned _subc	  (unsigned, unsigned);
unsigned _lmbd	  (unsigned, unsigned);
int      _abs	  (int);
int      _sat	  (long);
unsigned _norm	  (int);
unsigned _lnorm	  (long);
int	 _smpy	  (int,      int);
int	 _smpyhl  (int,      int);
int	 _smpylh  (int,      int);
int	 _smpyh	  (int,      int);
int	 _mpy	  (int,      int);
int	 _mpyus	  (unsigned, int);
int	 _mpysu	  (int,      unsigned);
unsigned _mpyu	  (unsigned, unsigned);
int	 _mpyhl	  (int,      int);
int	 _mpyhuls (unsigned, int);
int	 _mpyhslu (int,      unsigned);
unsigned _mpyhlu  (unsigned, unsigned);
int	 _mpylh	  (int,      int);
int	 _mpyluhs (unsigned, int);
int	 _mpylshu (int,      unsigned);
unsigned _mpylhu  (unsigned, unsigned);
int	 _mpyh	  (int,      int);
int	 _mpyhus  (unsigned, int);
int	 _mpyhsu  (int,      unsigned);
unsigned _mpyhu	  (unsigned, unsigned);

extern cregister volatile unsigned int AMR;
extern cregister volatile unsigned int CSR;
extern cregister volatile unsigned int IFR;
extern cregister volatile unsigned int ISR;
extern cregister volatile unsigned int ICR;
extern cregister volatile unsigned int IER;
extern cregister volatile unsigned int ISTP;
extern cregister volatile unsigned int IN;
extern cregister volatile unsigned int OUT;

ctype.h/        868562436   0     0     0       4940      `
/*****************************************************************************/
/* ctype.h    v1.10#                                                         */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/

/************************************************************************/
/*                                                                      */
/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */
/*                                                                      */
/*  Note that in this implementation, either macros or functions may    */
/*  be used.  Macros are prefixed with an underscore.                   */
/*                                                                      */
/************************************************************************/
#ifndef _CTYPE
#define _CTYPE

extern unsigned char _ctypes_[];

#ifdef _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

/************************************************************************/
/*   FUNCTION DEFINITIONS                                               */
/************************************************************************/
__INLINE int isalnum(int _c);
__INLINE int isalpha(int _c);
__INLINE int iscntrl(int _c);
__INLINE int isdigit(int _c);
__INLINE int isgraph(int _c);
__INLINE int islower(int _c);
__INLINE int isprint(int _c);
__INLINE int ispunct(int _c);
__INLINE int isspace(int _c);
__INLINE int isupper(int _c);
__INLINE int isxdigit(int _c);
__INLINE int isascii(int _c);

__INLINE int toupper(int _c);
__INLINE int tolower(int _c);
__INLINE int toascii(int _c);

/************************************************************************/
/*  MACRO DEFINITIONS                                                   */
/************************************************************************/
#define _U_   0x01
#define _L_   0x02
#define _N_   0x04
#define _S_   0x08
#define _P_   0x10
#define _C_   0x20
#define _H_   0x40
#define _B_   0x80

#define _isalnum(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_))
#define _isalpha(a)  (_ctypes_[(a)+1] & (_U_ | _L_))
#define _iscntrl(a)  (_ctypes_[(a)+1] & _C_)
#define _isdigit(a)  (_ctypes_[(a)+1] & _N_)
#define _isgraph(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_ | _P_))
#define _islower(a)  (_ctypes_[(a)+1] & _L_)
#define _isprint(a)  (_ctypes_[(a)+1] & (_B_ | _U_ | _L_ | _N_ | _P_))
#define _ispunct(a)  (_ctypes_[(a)+1] & _P_)
#define _isspace(a)  (_ctypes_[(a)+1] & _S_)
#define _isupper(a)  (_ctypes_[(a)+1] & _U_)
#define _isxdigit(a) (_ctypes_[(a)+1] & _H_)
#define _isascii(a)  (((a) & ~0x7F) == 0)

#define _toupper(b)  ((_islower(b)) ? (b) - ('a' - 'A') : (b))
#define _tolower(b)  ((_isupper(b)) ? (b) + ('a' - 'A') : (b))
#define _toascii(a)  ((a) & 0x7F)

#ifdef _INLINE
static inline int isalnum(int c)  { return(_isalnum(c)); }
static inline int isalpha(int c)  { return(_isalpha(c)); }
static inline int isascii(int c)  { return(_isascii(c)); }
static inline int iscntrl(int c)  { return(_iscntrl(c)); }
static inline int isdigit(int c)  { return(_isdigit(c)); }
static inline int isgraph(int c)  { return(_isgraph(c)); }
static inline int islower(int c)  { return(_islower(c)); }
static inline int isprint(int c)  { return(_isprint(c)); }
static inline int ispunct(int c)  { return(_ispunct(c)); }
static inline int isspace(int c)  { return(_isspace(c)); }
static inline int isupper(int c)  { return(_isupper(c)); }
static inline int isxdigit(int c) { return(_isxdigit(c));}
static inline int toascii(int c)  { return(_toascii(c)); }

/****************************************************************************/
/*  tolower                                                                 */
/****************************************************************************/
static inline int tolower(int ch)
{
   /*
    This code depends on two assumptions: (1) all of the letters of the
    alphabet of a given case are contiguous, and (2) the lower and upper
    case forms of each letter are displaced from each other by the same
    constant value.
   */

   if ( (unsigned int)(ch - 'A') <= (unsigned int)('Z' - 'A')) ch += 'a' - 'A';
   return ch;
}

/****************************************************************************/
/*  toupper                                                                 */
/****************************************************************************/
static inline int toupper(int ch)
{
   /*
    This code depends on two assumptions: (1) all of the letters of the
    alphabet of a given case are contiguous, and (2) the lower and upper
    case forms of each letter are displaced from each other by the same
    constant value.
   */

   if ( (unsigned int)(ch - 'a') <= (unsigned int)('z' - 'a')) ch -= 'a' - 'A';
   return ch;
}

#endif
#undef __INLINE

#endif
errno.h/        868562436   0     0     0       447       `
/*****************************************************************************/
/*  ERRNO.H  v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

#ifndef _ERRNO
#define _ERRNO

extern int errno;

#define EDOM   1
#define ERANGE 2
#define ENOENT 3
#define EFPOS  5

#endif

file.h/         868562436   0     0     0       1824      `
/*****************************************************************************/
/*  FILE.H v1.10#                                                            */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Macros and declarations used in lowlevel I/O functions.                   */
/*****************************************************************************/

/*---------------------------------------------------------------------------*/
/* constants for file manipulations                                          */
/*---------------------------------------------------------------------------*/
#define  O_RDONLY    (0x0000) /* open for reading      */
#define  O_WRONLY    (0x0001) /* open for writing      */
#define  O_RDWR      (0x0002) /* open for read & write */
#define  O_APPEND    (0x0008) /* append on each write  */
#define  O_CREAT     (0x0200) /* open with file create */
#define  O_TRUNC     (0x0400) /* open with truncation  */
#define  O_BINARY    (0x8000) /* open in binary mode   */

/*---------------------------------------------------------------------------*/
/* lowlevel I/O declarations                                                 */
/*---------------------------------------------------------------------------*/
extern int  open(const char *path, unsigned flags, int mode);
extern int  read(int fildes, char *bufptr, unsigned cnt);
extern int  write(int fildes, const char *bufptr, unsigned cnt);
extern long lseek(int fildes, long offset, int origin);
extern int  close(int fildes);
extern int  unlink(const char *path);
extern int  rename(const char *old_name, const char *new_name);

float.h/        868562438   0     0     0       2981      `
/*****************************************************************************/
/* float.h    v1.10#                                                         */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/

/********************************************************************/
/*    KEY:  FLT_     - APPLIES TO TYPE FLOAT                        */
/*          DBL_     - APPLIES TO TYPE DOUBLE                       */
/*          LDBL_    - APPLIES TO TYPE LONG DOUBLE                  */
/********************************************************************/
#ifndef _FLOAT
#define _FLOAT

#define FLT_RADIX                         2   /* RADIX OF EXPONENT         */
#define FLT_ROUNDS                        1   /* ROUND TO NEAREST          */

#define FLT_DIG                           6   /* DECIMAL PRECISION         */
#define FLT_MANT_DIG                     24   /* BITS IN MANTISSA          */
#define FLT_MIN_EXP                    -125   /* SMALLEST EXPONENT         */
#define FLT_MAX_EXP                     128   /* LARGEST EXPONENT          */
#define FLT_MIN_10_EXP                  -37   /* MIN POWER OF 10           */
#define FLT_MAX_10_EXP                   38   /* MAX POWER OF 10           */
#define FLT_EPSILON        1.192092896E-07F   /* SMALLEST X WHERE 1+X != 1 */
#define FLT_MIN            1.175494351E-38F   /* SMALLEST POSITIVE VALUE   */
#define FLT_MAX            3.402823466E+38F   /* LARGEST POSITIVE VALUE    */

#define DBL_DIG                          15   /* DECIMAL PRECISION         */
#define DBL_MANT_DIG                     53   /* BITS IN MANTISSA          */
#define DBL_MIN_EXP                   -1021   /* SMALLEST EXPONENT         */
#define DBL_MAX_EXP                    1024   /* LARGEST EXPONENT          */
#define DBL_MIN_10_EXP                 -307   /* MIN POWER OF 10           */
#define DBL_MAX_10_EXP                  308   /* MAX POWER OF 10           */
#define DBL_EPSILON  2.2204460492503131E-16   /* SMALLEST X WHERE 1+X != 1 */
#define DBL_MIN     2.2250738585072014E-308   /* SMALLEST POSITIVE VALUE   */
#define DBL_MAX     1.7976931348623157E+308   /* LARGEST POSITIVE VALUE    */
 
#define LDBL_DIG                         15   /* DECIMAL PRECISION         */
#define LDBL_MANT_DIG                    53   /* BITS IN MANTISSA          */
#define LDBL_MIN_EXP                  -1021   /* SMALLEST EXPONENT         */
#define LDBL_MAX_EXP                   1024   /* LARGEST EXPONENT          */
#define LDBL_MIN_10_EXP                -307   /* MIN POWER OF 10           */
#define LDBL_MAX_10_EXP                 308   /* MAX POWER OF 10           */
#define LDBL_EPSILON 2.2204460492503131E-16   /* SMALLEST X WHERE 1+X != 1 */
#define LDBL_MIN    2.2250738585072014E-308   /* SMALLEST POSITIVE VALUE   */
#define LDBL_MAX    1.7976931348623157E+308   /* LARGEST POSITIVE VALUE    */

#endif

format.h/       868562438   0     0     0       2067      `
/*****************************************************************************/
/*  FORMAT.H v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Structures and macros used in printf and scanf                            */
/*****************************************************************************/
#ifndef __FORMAT_H
#define __FORMAT_H
#include <stdarg.h>

#define _ARSIZE 128

extern int _scanfi(void *inp, const char *_format, va_list _ap,
            int (*_chkmbc)(void **inp, char **_format, int *num_read),
            char (*_inpchar)(void **inp),
            void (*_uninpchar)(void **inp, char outchar));
 
/****************************************************************************/
/* _FIELD STRUCTURE AND MACROS USED FOR PRINTF AND SCANF                    */
/****************************************************************************/
typedef struct {
      unsigned int   flags;   /* Format flags */
      int      fwidth;        /* Field width */
      int      precision;     /* Field precision */
      char     conv;          /* Conversion specifier */
} _PFIELD;
 
typedef struct {
      unsigned int   flags;   /* Format flags */
      int      fwidth;        /* Field width */
      int      precision;     /* Field precision */
      char     scanset[96];  /* Scanset used for '[' conversion */
      char     conv;          /* Conversion specifier */
} _SFIELD;
 
/****************/
/* PRINTF FLAGS */
/****************/

#define _PFMINUS  0x01
#define _PFPLUS   0x02
#define _PFSPACE  0x04
#define _PFPOUND  0x08
#define _PFZERO   0x10
 
/***************/
/* SCANF FLAGS */
/***************/

#define _SFSTAR   0x01
#define _SFCIRC   0x02

/****************/
/* MUTUAL FLAGS */
/****************/

#define _MFH      0x20
#define _MFL      0x40
#define _MFLD     0x80

#endif

formi32.h/      868562438   0     0     0       6711      `
/****************************************************************************/
/*  formi32  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:07:54 EDT 1997 */

#ifndef __formi32__
#define __formi32__

#if 0 /* eliminate comments during source build */
/*---------------------------------------------------------------------------*/
/* Description of the IEEE 32-bit float format.                              */
/*                                                                           */
/* This file is used in conjunction with the c pre-processor to build        */
/* customized product sources.  It is carefully constructed so that comments */
/* are removed by the preprocessor and all expansions result in a minimum    */
/* disruption of surrounding code.                                           */
/*                                                                           */
/* All floating-point constants in this file must be expressed either        */
/* exactly or to *MORE* places than REAL_DIGITS (REAL_DIGITS+3 is suggested).*/
/*---------------------------------------------------------------------------*/
#endif

#if 0
/*---------------------------------------------------------------------------*/
/* REAL is described in terms of the canonical form:  +/- f * r**e           */
/* where: r is "radix",                                                      */
/*        e is "exponent" (an integer),                                      */
/*        f is fractional part (mantissa) and  1/r <= f < 1,                 */
/*---------------------------------------------------------------------------*/
#endif
#define REAL_RADIX     2 /* radix (r)                                        */
#define REAL_MANTISSA 24 /* radix digits in mantissa                         */
#define REAL_EMAX    128 /* max e for which +/- f has MANTISSA digits        */
#define REAL_EMIN  (-125)/* min e for which +/- f has MANTISSA digits        */
#define REAL_DIGITS    6 /* FLRF(REAL_MANTISSA-1)*Ln_RADIX/Ln_10)            */

#define Round_To_Even

#define IEEE /* don't define "IEEE" at all if not ieee format */

#if defined(Generate_Sources)
   #define if_IEEE_Hardware #ifdef IEEE_Hardware
   #define elsif_not_IEEE_Hardware #else
   #define endif_IEEE_Hardware #endif
#elif defined(IEEE_Hardware)
   #define if_IEEE_Hardware if (IEEE_Hardware) {
   #define elsif_not_IEEE_Hardware } else {
   #define endif_IEEE_Hardware }
#else
   #define if_IEEE_Hardware if (0) {
   #define elsif_not_IEEE_Hardware } else {
   #define endif_IEEE_Hardware }
#endif

#define REAL_EXP_BITS 8  /* bits in unsigned_exp_field */
#define REAL_FRC_BITS 23 /* bits in fraction_field     */
#define REAL_EXP_BIAS 127/* exponent = unsigned_exp_field - REAL_EXP_BIAS */

#if BPLEAN==0 /* no next-smaller REAL */
   #undef LEAN_DIGITS
   #undef LEAN_EXP_BITS
   #undef LEAN_FRC_BITS
   #undef LEAN_EXP_BIAS
#else
   #error "LEAN_* not yet defined for this size LEAN"
#endif

#if 0
/*---------------------------------------------------------------------------*/
/* Absolute extremes of floating point range.                                */
/* f need not have full MANTISSA digits, but do not                          */
/* include consideration of NAN's, ZEROs, infinities.                        */
/* Express to *MORE* places than REAL_DIGITS.                                */
/*---------------------------------------------------------------------------*/
#endif
#define REAL_MOST_POS  CNST( 3.402823466E+38)
#define REAL_MOST_NEG  CNST(-3.402823466E+38)

#ifdef Support_DENORM
   #define REAL_LEAST_POS CNST( 1.401298464E-45)  /* denormalized */
   #define REAL_LEAST_NEG CNST(-1.401298464E-45)  /* denormalized */
   #define LEAST_POS_INVERTABLE_NOT_LEAST_POS 1
#else
   #define REAL_LEAST_POS CNST( 1.175494351e-38)
   #define REAL_LEAST_NEG CNST(-1.175494351e-38)
   #define LEAST_POS_INVERTABLE_NOT_LEAST_POS 0
#endif

#define REAL_LEAST_POS_INVERTABLE CNST(1.1754943508e-38)
#if 0                 /* usually (-EMIN<EMAX) ? RADIX**(EMIN-1) : 1/MOST_POS */

/*---------------------------------------------------------------------------*/
/* Constants derived from RADIX & MANTISSA needed for math.h routines.       */
/* Express to *MORE* places than REAL_DIGITS.                                */
/*---------------------------------------------------------------------------*/
#endif
#define RADIX                    CNST( 2.0) /* FLTIF(REAL_RADIX   )          */
#define MANTISSA                 CNST(24.0) /* FLTIF(REAL_MANTISSA)          */

#define Ln_RADIX                 Ln_2   /* ln(RADIX)                         */
#define Sqrt_RADIX               Sqrt_2 /* sqrt(RADIX)                       */

#define RADIX_to(x)              SCLF(ONE,x) /* RADIX**x, x an integer       */

#define RADIX_to_Hlf_MANTISSA_M2 CNST(1024.0) /*    RADIX**((MANTISSA/2)-2)  */
#define RADIX_to_Hlf_MANTISSA_M1 CNST(2048.0) /*    RADIX**((MANTISSA/2)-1)  */
#define RADIX_to_Hlf_MANTISSA    CNST(4096.0) /*    RADIX**( MANTISSA/2)     */
#define RADIX_to_MANTISSA        CNST(16777216.0)/* RADIX**( MANTISSA     )  */

#define One_Over_RADIX          CNST(0.5)/*              RADIX**(-1         )*/
#define RADIX_to_M_Hlf_MANTISSA CNST(2.44140625e-4)/*    RADIX**(-MANTISSA/2)*/
#define RADIX_to_One_M_MANTISSA CNST(1.1920928955E-7)/*  RADIX**(1-MANTISSA )*/
#define RADIX_to_M_MANTISSA     CNST(5.9604644753E-8)/*  RADIX**( -MANTISSA )*/
#define RADIX_to_EMIN           CNST(2.35098870164E-38)/*RADIX**(EMIN       )*/

#ifndef BPint
   #error "target props .h file must be included before REAL format .h file"
#endif
#define RND_GLITCH ((REAL_MANTISSA+1) <= BPint)
#define RND_P_GLITCH CNST( 16777216.0)/*\_RNDF glitch points. see fltsyntx.h */
#define RND_M_GLITCH CNST(-16777215.0)/*/ if no round-to-even dont need these*/

#define RSQRT_Sz_Newtons 3 /* (int)FLOOR(LOG2((MANTISSA-1)/5))+1             */
#define SQRT_Sz_Newtons  2 /* (int)FLOOR(LOG2((MANTISSA-1)/5))               */
#define SQRT_CW_Newtons  3 /* (int)CEIL (LOG2( MANTISSA     ))-2             */

#define EXP_Max CNST( 88.72283382) /* ln(MOST_POS   )*(1-RADIX**-MANTISSA)   */
#define EXP_Min CNST(-86.64339241) /* ln(RADIX**EMIN)*(1-RADIX**-MANTISSA)   */

#define POW_Ovfl CNST( 1418.0) /* FLOOR(16*ln(MOST_POS   )-1)                */
#define POW_Unfl CNST(-1386.0) /* FLOOR(16*ln(RADIX**EMIN)+1)                */

#define TANH_Max CNST(9.01091334725)/* (Ln_2+(MANTISSA+1)*Ln_RADIX)/2        */

#endif /*__formi32__*/

formi64.h/      868562438   0     0     0       6975      `
/****************************************************************************/
/*  formi64  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:54 EDT 1997 */

#ifndef __formi64__
#define __formi64__

#if 0 /* eliminate comments during source build */
/*---------------------------------------------------------------------------*/
/* Description of the IEEE 64-bit float format.                              */
/*                                                                           */
/* This file is used in conjunction with the c pre-processor to build        */
/* customized product sources.  It is carefully constructed so that comments */
/* are removed by the preprocessor and all expansions result in a minimum    */
/* disruption of surrounding code.                                           */
/*                                                                           */
/* All floating-point constants in this file must be expressed either        */
/* exactly or to *MORE* places than REAL_DIGITS (REAL_DIGITS+3 is suggested).*/
/*---------------------------------------------------------------------------*/
#endif

#if 0
/*---------------------------------------------------------------------------*/
/* REAL is described in terms of the canonical form:  +/- f * r**e           */
/* where: r is "radix",                                                      */
/*        e is "exponent" (an integer),                                      */
/*        f is fractional part (mantissa) and  1/r <= f < 1,                 */
/*---------------------------------------------------------------------------*/
#endif
#define REAL_RADIX     2 /* radix (r)                                        */
#define REAL_MANTISSA 53 /* radix digits in mantissa                         */
#define REAL_EMAX   1024 /* max e for which +/- f has MANTISSA digits        */
#define REAL_EMIN (-1021)/* min e for which +/- f has MANTISSA digits        */
#define REAL_DIGITS   15 /* FLRF(REAL_MANTISSA-1)*Ln_RADIX/Ln_10)            */
                                
#define Round_To_Even

#define IEEE /* don't define "IEEE" at all if not ieee format */

#if defined(Generate_Sources)
   #define if_IEEE_Hardware #ifdef IEEE_Hardware
   #define elsif_not_IEEE_Hardware #else
   #define endif_IEEE_Hardware #endif
#elif defined(IEEE_Hardware)
   #define if_IEEE_Hardware if (IEEE_Hardware) {
   #define elsif_not_IEEE_Hardware } else {
   #define endif_IEEE_Hardware }
#else
   #define if_IEEE_Hardware if (0) {
   #define elsif_not_IEEE_Hardware } else {
   #define endif_IEEE_Hardware }
#endif

#define REAL_EXP_BITS 11 /* bits in unsigned_exp_field */
#define REAL_FRC_BITS 52 /* bits in fraction_field     */
#define REAL_EXP_BIAS 1023/* exponent = unsigned_exp_field - REAL_EXP_BIAS */

#if BPLEAN==0 /* no next-smaller REAL */
   #undef LEAN_DIGITS
   #undef LEAN_EXP_BITS
   #undef LEAN_FRC_BITS
   #undef LEAN_EXP_BIAS
#elif BPLEAN==32 /* shape of next-smaller REAL (for grow/slim routines) */
   #define LEAN_DIGITS 6
   #define LEAN_EXP_BITS 8  /* bits in unsigned_exp_field */
   #define LEAN_FRC_BITS 23 /* bits in fraction_field     */
   #define LEAN_EXP_BIAS 127/* exponent=unsigned_exp_field-LEAN_EXP_BIAS */
#else
   #error "LEAN_* not yet defined for this size LEAN"
#endif

#if 0
/*---------------------------------------------------------------------------*/
/* Absolute extremes of floating point range.                                */
/* f need not have full MANTISSA digits, but do not                          */
/* include consideration of NAN's, ZEROs, infinities.                        */
/* Express to *MORE* places than REAL_DIGITS.                                */
/*---------------------------------------------------------------------------*/
#endif
#define REAL_MOST_POS  CNST( 1.7976931348623157e+308)
#define REAL_MOST_NEG  CNST(-1.7976931348623157e+308)

#ifdef Support_DENORM
   #define REAL_LEAST_POS CNST( 4.9406564584124654e-324) /* denormalized */
   #define REAL_LEAST_NEG CNST(-4.9406564584124654e-324) /* denormalized */
   #define LEAST_POS_INVERTABLE_NOT_LEAST_POS 1
#else
   #define REAL_LEAST_POS CNST( 2.225073858507201383e-308)
   #define REAL_LEAST_NEG CNST(-2.225073858507201383e-308)
   #define LEAST_POS_INVERTABLE_NOT_LEAST_POS 0
#endif

#define REAL_LEAST_POS_INVERTABLE CNST(2.225073858507201383e-308)
#if 0                 /* usually (-EMIN<EMAX) ? RADIX**(EMIN-1) : 1/MOST_POS */


/*---------------------------------------------------------------------------*/
/* Constants derived from RADIX & MANTISSA needed for math.h routines.       */
/* Express to *MORE* places than REAL_DIGITS.                                */
/*---------------------------------------------------------------------------*/
#endif
#define RADIX                    CNST( 2.0) /* FLTIF(REAL_RADIX   )          */
#define MANTISSA                 CNST(53.0) /* FLTIF(REAL_MANTISSA)          */

#define Ln_RADIX                 Ln_2   /* ln(RADIX)                         */
#define Sqrt_RADIX               Sqrt_2 /* sqrt(RADIX)                       */

#define RADIX_to(x)              SCLF(ONE,x) /* RADIX**x, x an integer       */

#define RADIX_to_Hlf_MANTISSA_M1 CNST(33554432.0)/* RADIX**((MANTISSA/2)-1)  */
#define RADIX_to_Hlf_MANTISSA_M2 CNST(16777216.0)/* RADIX**((MANTISSA/2)-2)  */
#define RADIX_to_Hlf_MANTISSA    CNST(67108864.0)/* RADIX**( MANTISSA/2   )  */
#define RADIX_to_MANTISSA        CNST(9007199254740992.0)/*RADIX**MANTISSA   */

#define One_Over_RADIX          CNST(0.5)/*                     RDX**(-1    )*/
#define RADIX_to_M_Hlf_MANTISSA CNST(1.490116119384765625e-08)/*RDX**(-MNT/2)*/
#define RADIX_to_One_M_MANTISSA CNST(2.220446049250313081e-16)/*RDX**(1-MNT )*/
#define RADIX_to_M_MANTISSA     CNST(1.110223024625156540e-16)/*RDX**( -MNT )*/
#define RADIX_to_EMIN           CNST(4.450147717014402766e-308)/*RDX**(EMIN )*/

#ifndef BPint
   #error "target props .h file must be included before REAL format .h file"
#endif
#define RND_GLITCH ((REAL_MANTISSA+1) <= BPint)
#define RND_P_GLITCH RADIX_to_MANTISSA
#define RND_M_GLITCH CNST(-9007199254740991.0) /* -(RADIX**MANTISSA-1) */

#define SQRT_Sz_Newtons  3 /* (int)FLOOR(LOG2((MANTISSA-1)/5))               */
#define SQRT_CW_Newtons  4 /* (int)CEIL (LOG2( MANTISSA     ))-2             */

#define EXP_Max CNST(7.097827128933838594e+02) /*ln(MOST_POS )*(1-RDX**-MNT) */
#define EXP_Min CNST(-7.077032713517040747e+02)/*ln(RDX**EMIN)*(1-RDX**-MNT) */

#define POW_Ovfl CNST( 11355.0) /* FLOOR(16*ln(MOST_POS)-1)                  */
#define POW_Unfl CNST(-11323.0) /* FLOOR(16*ln(RADIX**EMIN)+1)               */

#define TANH_Max CNST(1.906154746539849754e+01)/*(Ln_2+(MNT+1)*Ln_RADIX)/2   */

#endif /*__formi64__*/

frcaddd.h/      868562438   0     0     0       737       `
/****************************************************************************/
/*  frcaddd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:55 EDT 1997 */

#ifndef __FRCADDF__
#define __FRCADDF__

#include "realdi.h"

#if (BPREAL == BPbigint) /* use compiler support for bigint add */

#elif (BPREAL == (BPbigint*2))
extern int FRCADDF(int lx, REAL_2UNS *lf, 
                   int rx, REAL_2UNS *rf);
#else
   #error "FRCADDF not yet implemented for this size REAL"
#endif

#endif /* __FRCADDF__ */

frcaddf.h/      868562438   0     0     0       737       `
/****************************************************************************/
/*  frcaddf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:07:55 EDT 1997 */

#ifndef __FRCADDF__
#define __FRCADDF__

#include "realfi.h"

#if (BPREAL == BPbigint) /* use compiler support for bigint add */

#elif (BPREAL == (BPbigint*2))
extern int FRCADDF(int lx, REAL_2UNS *lf, 
                   int rx, REAL_2UNS *rf);
#else
   #error "FRCADDF not yet implemented for this size REAL"
#endif

#endif /* __FRCADDF__ */

frcdivd.h/      868562438   0     0     0       705       `
/****************************************************************************/
/*  frcdivd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:55 EDT 1997 */

#ifndef __FRCDIVF__
#define __FRCDIVF__

#include "realdi.h"

#if (BPREAL == BPbigint)
biguns FRCDIVF(biguns l, biguns r);
#elif (BPREAL == (BPbigint*2))
extern int FRCDIVF(REAL_2UNS *p, REAL_2UNS *l, REAL_2UNS *r);

#else
   #error "FRCDIVF not yet implemented for this size REAL"
#endif

#endif /*__FRCDIVF__*/

frcdivf.h/      868562438   0     0     0       705       `
/****************************************************************************/
/*  frcdivf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:07:56 EDT 1997 */

#ifndef __FRCDIVF__
#define __FRCDIVF__

#include "realfi.h"

#if (BPREAL == BPbigint)
biguns FRCDIVF(biguns l, biguns r);
#elif (BPREAL == (BPbigint*2))
extern int FRCDIVF(REAL_2UNS *p, REAL_2UNS *l, REAL_2UNS *r);

#else
   #error "FRCDIVF not yet implemented for this size REAL"
#endif

#endif /*__FRCDIVF__*/

frcmpyd.h/      868562438   0     0     0       713       `
/****************************************************************************/
/*  frcmpyd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:56 EDT 1997 */

#ifndef __FRCMPYF__
#define __FRCMPYF__

#include "realdi.h"

#if (BPREAL == BPbigint)
extern biguns FRCMPYF(biguns l, biguns r);

#elif (BPREAL == (BPbigint*2))
extern int FRCMPYF(REAL_2UNS *p, REAL_2UNS *l, REAL_2UNS *r);

#else
   #error "FRCMPYF not yet implemented for this size REAL"
#endif

#endif /*__FRCMPYF__*/

frcmpyf.h/      868562438   0     0     0       713       `
/****************************************************************************/
/*  frcmpyf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:07:56 EDT 1997 */

#ifndef __FRCMPYF__
#define __FRCMPYF__

#include "realfi.h"

#if (BPREAL == BPbigint)
extern biguns FRCMPYF(biguns l, biguns r);

#elif (BPREAL == (BPbigint*2))
extern int FRCMPYF(REAL_2UNS *p, REAL_2UNS *l, REAL_2UNS *r);

#else
   #error "FRCMPYF not yet implemented for this size REAL"
#endif

#endif /*__FRCMPYF__*/

ieeed.h/        868562438   0     0     0       2087      `
/****************************************************************************/
/*  ieeed  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:56 EDT 1997 */

#ifndef __ieeed__
#define __ieeed__

#include <limits.h>

extern double _absd(double x);
extern double _negd(double x);

extern double _addd(double left, double right);
extern double _subd(double left, double right);
extern double _mpyd(double left, double right);
extern double _divd(double left, double right);

extern int _cmpd(double left,
                 double right); /* <0 if LT, 0 if EQ, >0 if GT     */
                                /* no correct result if NaN source */

extern int _eqld(double left, double right);
extern int _neqd(double left, double right);
extern int _leqd(double left, double right);
extern int _geqd(double left, double right);
extern int _lssd(double left, double right);
extern int _gtrd(double left, double right);


/* char <-> double */
extern double        _fltcd(  signed char x);
extern double        _fltbd(unsigned char x);
extern   signed char _fixdc(double x);
extern unsigned char _fixdb(double x);

/* short <-> double */
extern double         _fltsid(         short x);
extern double         _fltusd(unsigned short x);
extern short          _fixdsi(double x);
extern unsigned short _fixdus(double x);

/* int <-> double */
extern double   _fltid(int      x);
extern double   _fltud(unsigned x);
extern int      _fixdi(double x);
extern unsigned _fixdu(double x);

/* long <-> double */
extern double        _fltlid(         long x);
extern double        _fltuld(unsigned long x);
extern long          _fixdli(double x);
extern unsigned long _fixdul(double x);


/* float <-> double */
extern float  _cvtdf(double x); /* slim from double to float  */
extern double _cvtfd(float  x); /* grow from float  to double */

#endif /* __ieeed__ */







ieeef.h/        868562438   0     0     0       1883      `
/****************************************************************************/
/*  ieeef  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:07:57 EDT 1997 */

#ifndef __ieeef__
#define __ieeef__

#include <limits.h>

extern float _absf(float x);
extern float _negf(float x);

extern float _addf(float left, float right);
extern float _subf(float left, float right);
extern float _mpyf(float left, float right);
extern float _divf(float left, float right);

extern int _cmpf(float left,
                 float right); /* <0 if LT, 0 if EQ, >0 if GT     */
                               /* no correct result if NaN source */

extern int _eqlf(float left, float right);
extern int _neqf(float left, float right);
extern int _leqf(float left, float right);
extern int _geqf(float left, float right);
extern int _lssf(float left, float right);
extern int _gtrf(float left, float right);


/* char <-> float */
extern float         _fltcf(  signed char x);
extern float         _fltbf(unsigned char x);
extern   signed char _fixfc(float x);
extern unsigned char _fixfb(float x);

/* short <-> float */
extern float          _fltsif(         short x);
extern float          _fltusf(unsigned short x);
extern short          _fixfsi(float x);
extern unsigned short _fixfus(float x);

/* int <-> float */
extern float    _fltif(int      x);
extern float    _fltuf(unsigned x);
extern int      _fixfi(float x);
extern unsigned _fixfu(float x);

/* long <-> float */
extern float         _fltlif(         long x);
extern float         _fltulf(unsigned long x);
extern long          _fixfli(float x);
extern unsigned long _fixful(float x);

#endif /* __ieeef__ */

ieeemask.h/     868562440   0     0     0       16214     `
/****************************************************************************/
/*  ieeemask  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:57 EDT 1997 */

#ifndef __ieeemask__
#define __ieeemask__

#ifndef BPint
   #error "target properties .h file must be included before ieeemask.h"
#endif

#if 0
/*---------------------------------------------------------------------------*/
/* There are two ways to get at the bits associated with REAL:               */
/*                                                                           */
/* 1. Efficient size-specific casting:                                       */
/*    . for (BPREAL==   BPbigint) use {bigint crx; REALasINT(crx,x); ... etc}*/
/*    . for (BPREAL== 2*BPbigint) use {REAL_2UNS crx; crx.r=x; x.msh ...}    */
/*    These have also been size-abstracted as CREAL (pronounced "Cast REAL") */
/*      {CREAL crx; REALasCREAL(crx,x); ...etc}                              */
/*                                                                           */
/* 2. Slightly less efficient size-independent:                              */
/*       {bigint *pr = (bigint *)(&x)+MSBI_OFFSET;                           */
/*        msbi = *pr;  /* fetch most significant bigint part                 */
/*        NEXT_MS(pr); /* advance ptr to next-most significant bigint part   */
/*    The macros MSI,LSI,MSBI,LSBI will allow access to the most/least       */
/*    significant int/bigint parts without having to declare pr.             */
/*                                                                           */
/* The pointer method is less efficient because most compilers cannot track  */
/* pointer usage sufficiently well to determine the variables changed when   */
/* writing through a pointer.  This causes many keep-it-in-a-register        */
/* opportunities to be lost around write sites.                              */
/* Furthermore, some compilers do not guarantee that reads and writes        */
/* through aliased pointer variables have *ANY* relationship with the        */
/* variables they alias and will optimize code such that desired data        */
/* dependencies are not maintained.  A sometimes-cure for this unfriendly    */
/* behavior is to insert an optmization fence before and after any use of a  */
/* pointer or a pointer cast.  ANSI specifies that char* is itself a fence   */
/* so if the REAL can be processed a char-at-a-time, use the MSC macros.     */
/*                                                                           */
/* Advantages of both models may be obtained by keeping REALs as CREALs      */
/* and using pointers to address of the CREAL version.                       */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* CREAL casting type and associated operations.                          */
/*---------------------------------------------------------------------------*/
#endif
#if (BPREAL == BPbigint)
   union REAL_UNS_u {
      REAL r;
      biguns u;
   };
   typedef union REAL_UNS_u REAL_UNS;
   union REAL_INT_u {
      REAL r;
      bigint i;
   };
   typedef union REAL_INT_u REAL_INT;

 #ifdef Pointers_Might_Not_Work
   #define REALasINT(I, R) do{REAL_INT XX; XX.r =(R); (I)= XX.i;}while (0)
   #define REALasUNS(U, R) do{REAL_UNS XX; XX.r =(R); (U)= XX.u;}while (0)
   #define INTasREAL(R, I) do{REAL_INT XX; XX.i =(I); (R)= XX.r;}while (0)
   #define UNSasREAL(R, U) do{REAL_UNS XX; XX.u =(U); (R)= XX.r;}while (0)

   #define return_REALasINT(R) do{REAL_INT XX; XX.r=(R); return XX.i;}while (0)
   #define return_REALasUNS(R) do{REAL_UNS XX; XX.r=(R); return XX.u;}while (0)
   #define return_INTasREAL(I) do{REAL_INT XX; XX.i=(I); return XX.r;}while (0)
   #define return_UNSasREAL(U) do{REAL_UNS XX; XX.u=(U); return XX.r;}while (0)
 #else
   #define REALasINT(I, R) do{I= *(bigint *)&(R);}while (0)
   #define REALasUNS(U, R) do{U= *(biguns *)&(R);}while (0)
   #define INTasREAL(R, I) do{R= *(REAL *)&(I);}while (0)
   #define UNSasREAL(R, U) do{R= *(REAL *)&(U);}while (0)

   #define return_REALasINT(R) do{REAL mem_REAL=R;\
                                  return *(bigint *)&(mem_REAL);}while (0)
   #define return_REALasUNS(R) do{REAL mem_REAL=R;\
                                  return *(biguns *)&(mem_REAL);}while (0)
   #define return_INTasREAL(I) do{bigint mem_int=I;\
                                  return *(REAL *)&(mem_int);}while (0)
   #define return_UNSasREAL(U) do{biguns mem_uns=U;\
                                  return *(REAL *)&(mem_uns);}while (0)
 #endif

   #define CREAL REAL_UNS
   #define REALasCREAL(CR,R) CR.r=(R)
   #define CREALasREAL(R,CR) (R)=CR.r
   #define UNSasCREAL(CR,U) CR.u=(U)
   #define INTasCREAL(CR,I) CR.i=(I)
   #define CREAL_SAME(l, r) (l==r)

   #define CREAL_IS_NAN(CR) (CR.u>REAL_INFNAN)

#elif (BPREAL==(2*BPbigint))
   union REAL_2UNS_u {
      REAL r;
      struct {
      #if MSB_In_Hi_Addr
         biguns lsh;
         biguns msh;
      #else
         biguns msh;
         biguns lsh;
      #endif
      } u;
   };
   typedef union REAL_2UNS_u REAL_2UNS;
   union REAL_2INT_u {
      REAL r;
      struct {
      #if MSB_In_Hi_Addr
         bigint lsh;
         bigint msh;
      #else
         bigint msh;
         bigint lsh;
      #endif
      } u;
   };
   typedef union REAL_2INT_u REAL_2INT;

#if 0
   /* INTasREAL and UNSasREAL have no meaning unless I,U is *p++ */
#endif
   #if (MSB_In_Hi_Addr)
      #define INTasREAL(R,I) do{LSBI(R)= I; \
                                MSBI(R) = I;} while(0) /* I usually *p++ */
      #define UNSasREAL(R,U) do{LSBI(R)= U; \
                                MSBI(R) = U;} while(0) /* U usually *p++ */
   #else
      #define INTasREAL(R,I) do{MSBI(R)= I; \
                                LSBI(R) = I;} while(0) /* I usually *p++ */
      #define UNSasREAL(R,U) do{MSBI(R)= U; \
                                LSBI(R) = U;} while(0) /* U usually *p++ */
   #endif

   #define CREAL REAL_2UNS
   #define REALasCREAL(CR,R) CR.r=R
   #define CREALasREAL(R,CR) R=CR.r
   #if (MSB_In_Hi_Addr)
      #define UNSasCREAL(CR, U) CR.u.lsh=(U); CR.u.msh=(U)  /* u usually *p++*/
      #define INTasCREAL(CR, I) CR.u.lsh=(biguns)(I); CR.u.msh=(biguns)(I)
   #else
      #define UNSasCREAL(CR, U) CR.u.msh=(u); CR.u.lsh=(U)  /* u usually *p++*/
      #define INTasCREAL(CR, I) CR.u.msh=(biguns)(I); CR.u.lsh=(biguns)(I)
   #endif

   #define CREAL_SAME(l, r) (((l).u.msh == (r).u.msh) && \
                             ((l).u.lsh == (r).u.lsh))

   #define CREAL_IS_NAN(cr) ( ((cr).u.msh> REAL_INFNAN)|| \
                             (((cr).u.msh==REAL_INFNAN)&&((cr).u.lsh>0)))

   
   #define NEG2sCOMP(xx) xx.u.msh = ~xx.u.msh + ((xx.u.lsh = -xx.u.lsh) == 0)

   #define RIGHT_SHIFT(lll, nnn) do { \
      int sc = nnn; \
      if (sc >= BPbigint) {lll.u.lsh= lll.u.msh >> sc-BPbigint; lll.u.msh=0;} \
      else { lll.u.lsh = (lll.u.msh << BPbigint-sc) + (lll.u.lsh >> sc); \
             lll.u.msh >>= sc;}} while (0)

   #define LEFT_SHIFT(lll, nnn) do { \
      int sc = nnn; \
      if (sc >= BPbigint) {lll.u.msh= lll.u.lsh << sc-BPbigint; lll.u.lsh=0;} \
      else { lll.u.msh = (lll.u.lsh >> BPbigint-sc) + (lll.u.msh << sc); \
             lll.u.lsh <<= sc;}} while (0)

   #define RIGHT_SHIFT1(lll) do {\
      lll->u.lsh = (lll->u.lsh >> 1) + (lll->u.msh << BPbigint-1);\
      lll->u.msh >>=1;} while (0)

   #define LEFT_SHIFT1(lll) do {\
      lll->u.msh = (lll->u.msh << 1) + (lll->u.lsh >> BPbigint-1);\
      lll->u.lsh <<=1;} while (0)

   #define RSH1(msh,lsh) \
      do {lsh = (lsh >> 1) + (msh << BPbigint-1); msh >>=1;} while (0)

   #define LSH1(msh,lsh) \
      do {msh = (msh << 1) + (lsh >> BPbigint-1);  lsh <<=1;} while (0)

 #if 0 /* alternative implementations of interest */
   #define RSH1(msh,lsh) \
      do {lsh >>= 1; if (msh & 1) lsh += MINUS; msh >>=1;} while (0)
   #define LSH1(msh,lsh) \
      do {msh <<= 1; if ((int)lsh < 0) msh++; lsh <<=1;} while (0)
 #endif

#else
   #error "no casting type defined for this size REAL"
#endif


#if 0
/*---------------------------------------------------------------------------*/
/* For use with (int *) ptr to REAL, and (bigint *) ptr to REAL.             */
/*    MSC  is "Least Significant   char part"                                */
/*    MSI  is "Least Significant    int part"                                */
/*    MSBI is "Least Significant bigint part"                                */
/*    LSC  is "Least Significant   char part"                                */
/*    LSI  is "Least Significant    int part"                                */
/*    LSBI is "Least Significant bigint part"                                */
/*---------------------------------------------------------------------------*/
#endif

#if 0
/* The C6x compiler exhibits some rather unfriendly this week   */
/* in that it rearranges code with pointer casts such that      */
/* desired data dependencies are not forthcoming and code       */
/* function is unpredictable.  A fix for this is to isolate     */
/* reads and writes and place optimization blocks around them.  */
/* Probably this too will stop working some day.  Beware.       */
#endif
#define OPTIMIZATION_BLOCK asm(" ")

#if (MSB_In_Hi_Addr)
   #define MSC_OFFSET ((BPREAL/BPchar)-1) 
   #define LSC_OFFSET 0
   #define MSI_OFFSET ((BPREAL/BPint)-1) 
   #define LSI_OFFSET 0
   #define MSBI_OFFSET ((BPREAL/BPbigint)-1) 
   #define LSBI_OFFSET 0
   #define NEXT_MS_OFFSET (-1)
   #define CONSUME_MS(ptr) *ptr--
#else
   #define MSC_OFFSET 0
   #define LSC_OFFSET ((BPREAL/BPchar)-1)
   #define MSI_OFFSET 0
   #define LSI_OFFSET ((BPREAL/BPint)-1)
   #define MSBI_OFFSET 0
   #define LSBI_OFFSET ((BPREAL/BPbigint)-1) 
   #define NEXT_MS_OFFSET 1
   #define CONSUME_MS(ptr) *ptr++
#endif

#define LSC(right)  *((  char *)(&right)+ LSC_OFFSET)
#define LSI(right)  *((   int *)(&right)+ LSI_OFFSET)
#define LSBI(right) *((bigint *)(&right)+LSBI_OFFSET)

#define MSC(right)  *((  char *)(&right)+ MSC_OFFSET)
#define MSI(right)  *((   int *)(&right)+ MSI_OFFSET)
#define MSBI(right) *((bigint *)(&right)+MSBI_OFFSET)

#define NEXT_MS(ptr) ptr+=NEXT_MS_OFFSET;

#define SIGN_SET(right) (MSC(right) < 0)
#define MINUSC (((char)1)<<(BPchar-1))




#if 0
/*---------------------------------------------------------------------------*/
/* Masks and constants for the top BPbigint bits of the IEEE number.         */
/*---------------------------------------------------------------------------*/
#endif

#define MINUS (((bigint)1)<<(BPbigint-1))
#define UNORDERED (((int)1)<<(BPint-1)) /* return this for NAN input to CMPF */
#define MASK(bb) ((((bigint)1)<<(bb))-1) /*clear bits above the 2**(bb-1) bit*/

#define REAL_EXP_INFNAN ((((bigint)1)<<REAL_EXP_BITS)-1)
#define REAL_EXP_MASK   ((((bigint)1)<<REAL_EXP_BITS)-1)

#define REAL_FRC_MSBs (REAL_FRC_BITS % BPbigint) /*frc bits MS part*/
#define REAL_FRC_MASK  ((((bigint)1)<< REAL_FRC_MSBs)-1)
#define REAL_HIDDEN_BIT (((bigint)1)<< REAL_FRC_MSBs)
#define REAL_INFNAN (((bigint)REAL_EXP_INFNAN) << REAL_FRC_MSBs)
#define REAL_NSNAN_BIT (((bigint)1)<<(REAL_FRC_MSBs-1)) /* MSB of fraction */
#define REAL_NAN    (REAL_INFNAN+1) /* signalling NAN */
#define REAL_NSNAN  (REAL_INFNAN+REAL_NSNAN_BIT) /*non-signl NAN*/

#define REAL_MOSTPOS (((REAL_EXP_INFNAN-1)<<REAL_FRC_MSBs)+REAL_FRC_MASK)
#define REAL_MOSTNEG (((REAL_EXP_INFNAN-1)<<REAL_FRC_MSBs)+REAL_FRC_MASK+MINUS)


#if 0
/*---------------------------------------------------------------------------*/
/* Similar constants as above,                                               */
/* but defined for LEAN, the next smallest floating point format.            */
/*---------------------------------------------------------------------------*/
#endif
   
#if !defined(LEAN) /* no smaller float size to provide conversion to/from */
   
#elif (BPLEAN == BPbigint)
   union LEAN_UNS_u {
      LEAN r;
      biguns u;
   };
   typedef union LEAN_UNS_u LEAN_UNS;
   union LEAN_INT_u {
      LEAN r;
      bigint i;
   };
   typedef union LEAN_INT_u LEAN_INT;

 #ifdef Pointers_Might_Not_Work
   #define LEANasINT(I, R) do{LEAN_INT XX; XX.r =(R); (I)= XX.i;}while (0)
   #define LEANasUNS(U, R) do{LEAN_UNS XX; XX.r =(R); (U)= XX.u;}while (0)
   #define INTasLEAN(R, I) do{LEAN_INT XX; XX.i =(I); (R)= XX.r;}while (0)
   #define UNSasLEAN(R, U) do{LEAN_UNS XX; XX.u =(U); (R)= XX.r;}while (0)

   #define return_LEANasINT(R) do{LEAN_INT XX; XX.r=(R); return XX.i;}while (0)
   #define return_LEANasUNS(R) do{LEAN_UNS XX; XX.r=(R); return XX.u;}while (0)
   #define return_INTasLEAN(I) do{LEAN_INT XX; XX.i=(I); return XX.r;}while (0)
   #define return_UNSasLEAN(U) do{LEAN_UNS XX; XX.u=(U); return XX.r;}while (0)
 #else
   #define LEANasINT(I, R) do{I= *(bigint *)&(R);}while (0)
   #define LEANasUNS(U, R) do{U= *(biguns *)&(R);}while (0)
   #define INTasLEAN(R, I) do{R= *(LEAN *)&(I);}while (0)
   #define UNSasLEAN(R, U) do{R= *(LEAN *)&(U);}while (0)

   #define return_LEANasINT(R) do{LEAN mem_LEAN=R;\
                                  return *(bigint *)&(mem_LEAN);}while (0)
   #define return_LEANasUNS(R) do{LEAN mem_LEAN=R;\
                                  return *(biguns *)&(mem_LEAN);}while (0)
   #define return_INTasLEAN(I) do{bigint mem_int=I;\
                                  return *(LEAN *)&(mem_int);}while (0)
   #define return_UNSasLEAN(U) do{biguns mem_uns=U;\
                                  return *(LEAN *)&(mem_uns);}while (0)
 #endif

   #define CLEAN LEAN_UNS
   #define LEANasCLEAN(CR,R) CR.r=(R)
   #define CLEANasLEAN(R,CR) (R)=CR.r
   #define UNSasCLEAN(CR,U) CR.u=(U)
   #define INTasCLEAN(CR,I) CR.i=(I)
   #define CLEAN_SAME(l, r) (l==r)

   #define LEAN_IS_NAN(CR) (CR.u>LEAN_INFNAN)

#elif (BPLEAN==(2*BPbigint))
   #define INTasLEAN(r,i) do{int j; bigint *q = &r; \  /* i usually *p++ */
                             for (j=1; j<=BPLEAN/BPbigint; j++)\
                                *q++ = i;}while(0)
   #define UNSasLEAN(r,u) do{int j; biguns *q = &r; \  /* u usually *p++ */
                             for (j=1; j<=BPLEAN/BPbigint; j++)\
                                *q++ = u;}while(0)

   union LEAN_2UNSs_u {
      LEAN r;
      struct {
      #if MSB_In_Hi_Addr
         biguns lsh;
         biguns msh;
      #else
         biguns msh;
         biguns lsh;
      #endif
      } u;
   };
   typedef union LEAN_2UNSs_u LEAN_2UNSs;

   #define CLEAN LEAN_2UNSs
   #define LEANasCLEAN(cr,R) cr.r=R
   #define CLEANasLEAN(R,cr) R=cr.r
   #if (MSB_In_Hi_Addr)
      #define UNSasCLEAN(cr, u) cr.u.lsh=(u); cr.u.msh=(u) /*u usually *p++*/
      #define INTasCLEAN(cr, i) cr.u.lsh=(biguns)(i); cr.u.msh=(biguns)(i)
   #else
      #define UNSasCLEAN(cr, u) cr.u.msh=(u); cr.u.lsh=(u) /*u usually *p++*/
      #define INTasCLEAN(cr, i) cr.u.msh=(biguns)(i); cr.u.lsh=(biguns)(i)
   #endif

   #define CLEAN_SAME(l, r) (((l).u.msh == (r).u.msh) && \
                             ((l).u.lsh == (r).u.lsh))

   #define CLEAN_IS_NAN(cr) ( ((cr).u.msh> LEAN_INFNAN)|| \
                             (((cr).u.msh==LEAN_INFNAN)&&((cr).u.lsh>0)))
#else
   #error "no casting type defined for this size LEAN format"
#endif


#define LEAN_EXP_INFNAN ((((bigint)1)<<LEAN_EXP_BITS)-1)
#define LEAN_EXP_MASK ((((bigint)1)<<LEAN_EXP_BITS)-1)

#define LEAN_EXP_INFNAN ((((bigint)1)<<LEAN_EXP_BITS)-1)
#define LEAN_EXP_MASK   ((((bigint)1)<<LEAN_EXP_BITS)-1)

#define LEAN_FRC_MSBs (LEAN_FRC_BITS % BPbigint) /*frc bits MS part*/
#define LEAN_FRC_MASK  ((((bigint)1)<< LEAN_FRC_MSBs)-1)
#define LEAN_HIDDEN_BIT (((bigint)1)<< LEAN_FRC_MSBs)
#define LEAN_INFNAN (((bigint)LEAN_EXP_INFNAN) << LEAN_FRC_MSBs)
#define LEAN_NSNAN_BIT (((bigint)1)<<(LEAN_FRC_MSBs-1)) /* MSB of fraction */
#define LEAN_NAN    (LEAN_INFNAN+1) /* signalling NAN */
#define LEAN_NSNAN  (LEAN_INFNAN+LEAN_NSNAN_BIT) /*non-signl NAN*/

#endif /* __ieeemask__ */
limits.h/       868562440   0     0     0       1776      `
/*****************************************************************************/
/* limits.h   v1.10#                                                         */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/

/*****************************************************************************/
/* TMS320C6X machine limits                                                  */
/*****************************************************************************/

#ifndef _LIMITS
#define _LIMITS

#define CHAR_BIT                 8    /* NUMBER OF BITS IN TYPE CHAR  */
#define SCHAR_MIN             -128    /* MIN VALUE FOR SIGNED CHAR    */
#define SCHAR_MAX              127    /* MAX VALUE FOR SIGNED CHAR    */
#define UCHAR_MAX              255U   /* MAX VALUE FOR UNSIGNED CHAR  */
#define CHAR_MIN         SCHAR_MIN    /* MIN VALUE FOR CHAR           */
#define CHAR_MAX         SCHAR_MAX    /* MAX VALUE FOR CHAR           */
#define MB_LEN_MAX               1    /* MAX # BYTES IN MULTI-BYTE    */
 
#define SHRT_MIN            -32768    /* MIN VALUE FOR SHORT          */
#define SHRT_MAX             32767    /* MAX VALUE FOR SHORT          */
#define USHRT_MAX            65535U   /* MAX VALUE FOR UNSIGNED SHORT */

#define INT_MIN         (-INT_MAX-1)  /* MIN VALUE FOR INT            */
#define INT_MAX         2147483647    /* MAX VALUE FOR INT            */
#define UINT_MAX        4294967295U   /* MAX VALUE FOR UNSIGNED INT   */

#define LONG_MIN        (-LONG_MAX-1) /* MIN VALUE FOR LONG           */
#define LONG_MAX      549755813887    /* MAX VALUE FOR LONG           */
#define ULONG_MAX    1099511627775U   /* MAX VALUE FOR UNSIGNED LONG  */

#endif

math.h/         868562440   0     0     0       3873      `
/****************************************************************************/
/*  math  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:58 EDT 1997 */

#ifndef __math__
#define __math__

#ifndef EDOM
#define EDOM   1
#endif

#ifndef ERANGE
#define ERANGE 2
#endif

#include <float.h>
#define HUGE_VAL DBL_MAX

#ifdef _INLINE
   #define __INLINE static inline
#else
   #define __INLINE extern
#endif

extern double sqrt (double x);
extern double exp  (double x);
extern double log  (double x);
extern double log10(double x);
extern double pow  (double x, double y);
extern double sin  (double x);
extern double cos  (double x);
extern double tan  (double x);
extern double asin (double x);
extern double acos (double x);
extern double atan (double x);
extern double atan2(double y, double x);
extern double sinh (double x);
extern double cosh (double x);
extern double tanh (double x);

__INLINE double ceil (double x);
__INLINE double floor(double x);

extern double fabs (double x);

extern double ldexp(double x, int n);
extern double frexp(double x, int *exp);
extern double modf (double x, double *ip);
extern double fmod (double x, double y);

/* An inline version of fmod that works for limited domain only */
/* See comments in implementation below */
static inline double _FMOD(double x, double y);

/* these present in many linked images, so we'll tell you about them. */
extern double _round(double x); /* round-to-nearest */
extern double _trunc(double x); /* truncate towards 0 */

#undef __INLINE

/* the ANSI-optional *f and *l routines */
#include <mathf.h>
#include <mathl.h>

#ifdef _TI_ENHANCED_MATH_H
#if 0
/* ------------------------------------------------- */
/* Routines below are an addition to ANSI math.h     */
/* Some (noted with "9x" in comment) will become ANSI*/
/* once C9x is approved.                             */
/* ------------------------------------------------- */
#endif

extern double rsqrt(double x); /*    == 1/sqrt(x) but *MUCH* faster         */
extern double exp2 (double x); /* 9x mathematically equiv to pow(2.0 ,x)    */
extern double exp10(double x); /*    mathematically equiv to pow(10.0,x)    */
extern double log2 (double x); /* 9x mathematically equiv to log(x)/log(2.0)*/

extern double powi(double x, int i); /* equiv to pow(x,(double)i) */

extern double cot  (double x);
extern double acot (double x);
extern double acot2(double x, double y);

extern double coth (double x);

extern double asinh(double x); /* 9x */
extern double acosh(double x); /* 9x */
extern double atanh(double x); /* 9x */
extern double acoth(double x);

#define round(x) _round(x) /* 9x round-to-nearest   */
#define trunc(x) _trunc(x) /* 9x truncate towards 0 */

#endif


#ifdef _INLINE
/****************************************************************************/
/*  Inline versions of floor, ceil, fmod                                    */
/****************************************************************************/

static inline double floor(double x) 
{
   double y; 
   return (modf(x, &y) < 0 ? y - 1 : y);
}

static inline double ceil(double x)
{
   double y; 
   return (modf(x, &y) > 0 ? y + 1 : y);
}

/* 
   The implementation below does not work correctly for all cases.
   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).
   The correct result is one of 0,1, or 2.
   But the implementation below will *always* return 0 
   because the quotient is only an approximation.
*/
static inline double _FMOD(double x, double y)
{
   double d = fabs(x); 
   if (d - fabs(y) == d) return (0);
   modf(x/y, &d);  
   return (x - d * y);
}

#endif


#endif /* __math__ */

mathf.h/        868562440   0     0     0       4807      `
/****************************************************************************/
/*  mathf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:07:58 EDT 1997 */

#ifndef __mathf__
#define __mathf__

#ifndef EDOM
   #define EDOM   1
#endif

#ifndef ERANGE
   #define ERANGE 2
#endif

#include <float.h>

#if (LDBL_DIG != DBL_DIG) /* float is not different than double */

#include <math.h>

#define sqrtf    sqrt
#define expf     exp
#define logf     log
#define log10f   log10
#define powf     pow
#define sinf     sin
#define cosf     cos
#define tanf     tan
#define asinf    asin
#define acosf    acos
#define atanf    atan
#define atan2f   atan2
#define sinhf    sinh
#define coshf    cosh
#define tanhf    tanh

#define ceilf    ceil
#define floorf   floor

#define fabsf    fabs

#define ldexpf   ldexp
#define frexpf   frexp
#define modff    modf
#define fmodf    fmod

#ifdef _TI_ENHANCED_MATH_H

#define HUGE_VALF FLT_MAX

#define rsqrtf   rsqrt
#define exp2f    exp2
#define exp10f   exp10
#define log2f    log2
#define powif    powi
#define cotf     cot
#define acotf    acot
#define acot2f   acot2
#define cothf    coth
#define asinhf   asinh
#define acoshf   acosh
#define atanhf   atanh
#define acothf   acoth
#define truncf   _trunc
#define roundf   _round

#endif

#else /* float is different than double */

#ifdef _INLINE
   #define __INLINE static inline
#else
   #define __INLINE extern
#endif

extern float sqrtf (float x);
extern float expf  (float x);
extern float logf  (float x);
extern float log10f(float x);
extern float powf  (float x, float y);
extern float sinf  (float x);
extern float cosf  (float x);
extern float tanf  (float x);
extern float asinf (float x);
extern float acosf (float x);
extern float atanf (float x);
extern float atan2f(float y, float x);
extern float sinhf (float x);
extern float coshf (float x);
extern float tanhf (float x);

__INLINE float ceilf (float x);
__INLINE float floorf(float x);

extern float fabsf (float x);

extern float ldexpf(float x, int n);
extern float frexpf(float x, int *exp);
extern float modff (float x, float *ip);
extern float fmodf (float x, float y);

/* An inline version of fmodf that works for limited domain only */
/* See comments in implementation below */
static inline float _FMODF(float x, float y);

/* these present in many linked images, so we'll tell you about them. */
extern float _roundf(float x); /* round-to-nearest */
extern float _truncf(float x); /* truncate towards 0 */

#ifdef _TI_ENHANCED_MATH_H
#if 0
/* ------------------------------------------------- */
/* Routines below are an addition to ANSI math.h     */
/* Some (noted with "9x" in comment) will become ANSI*/
/* once C9x is approved.                             */
/* ------------------------------------------------- */
#endif

#define HUGE_VALF FLT_MAX /* 9x */

extern float rsqrtf(float x); /*    == 1/sqrtf(x) but *MUCH* faster          */
extern float exp2f (float x); /* 9x mathematically equiv to powf(2.0 ,x)     */
extern float exp10f(float x); /*    mathematically equiv to powf(10.0,x)     */
extern float log2f (float x); /* 9x mathematically equiv to logf(x)/logf(2.0)*/

extern float powif (float x, int i); /* equiv to powf(x,(float)i) */

extern float cotf  (float x);
extern float acotf (float x);
extern float acot2f(float x, float y);

extern float cothf (float x);

extern float asinhf(float x); /* 9x */
extern float acoshf(float x); /* 9x */
extern float atanhf(float x); /* 9x */
extern float acothf(float x);

#define roundf(x) _roundf(x) /* 9x round-to-nearest   */
#define truncf(x) _truncf(x) /* 9x truncate towards 0 */
#endif


#ifdef _INLINE
/****************************************************************************/
/*  Inline versions of floorf, ceilf, fmodf                                 */
/****************************************************************************/

static inline float floorf(float x) 
{
   float y; 
   return (modff(x, &y) < 0 ? y - 1 : y);
}

static inline float ceilf(float x)
{
   float y; 
   return (modff(x, &y) > 0 ? y + 1 : y);
}

/* 
   The implementation below does not work correctly for all cases.
   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).
   The correct result is one of 0,1, or 2.
   But the implementation below will *always* return 0 
   because the quotient is only an approximation.
*/
static inline float _FMODF(float x, float y)
{
   float d = fabsf(x); 
   if (d - fabsf(y) == d) return (0);
   modff(x/y, &d);  
   return (x - d * y);
}

#endif
#undef __INLINE

#endif

#endif /* __mathf__ */

mathl.h/        868562440   0     0     0       5252      `
/****************************************************************************/
/*  mathl  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 07:23:29 EDT 1997 */

#ifndef __mathl__
#define __mathl__

#ifndef EDOM
   #define EDOM   1
#endif

#ifndef ERANGE
   #define ERANGE 2
#endif

#include <float.h>

#if (LDBL_DIG != DBL_DIG) /* long double is not different than double */

#include <math.h>

#define sqrtl    sqrt
#define expl     exp
#define logl     log
#define log10l   log10
#define powl     pow
#define sinl     sin
#define cosl     cos
#define tanl     tan
#define asinl    asin
#define acosl    acos
#define atanl    atan
#define atan2l   atan2
#define sinhl    sinh
#define coshl    cosh
#define tanhl    tanh

#define ceill    ceil
#define floorl   floor

#define fabsl    fabs

#define ldexpl   ldexp
#define frexpl   frexp
#define modfl    modf
#define fmodl    fmod

#ifdef _TI_ENHANCED_MATH_H

#define HUGE_VALL LDBL_MAX

#define rsqrtl   rsqrt
#define exp2l    exp2
#define exp10l   exp10
#define log2l    log2
#define powil    powi
#define cotl     cot
#define acotl    acot
#define acot2l   acot2
#define cothl    coth
#define asinhl   asinh
#define acoshl   acosh
#define atanhl   atanh
#define acothl   acoth
#define truncl   _trunc
#define roundl   _round

#endif

#else /* long double is different than double */

#ifdef _INLINE
   #define __INLINE static inline
#else
   #define __INLINE extern
#endif


extern long double sqrtl (long double x);
extern long double expl  (long double x);
extern long double logl  (long double x);
extern long double log10l(long double x);
extern long double powl  (long double x, long double y);
extern long double sinl  (long double x);
extern long double cosl  (long double x);
extern long double tanl  (long double x);
extern long double asinl (long double x);
extern long double acosl (long double x);
extern long double atanl (long double x);
extern long double atan2l(long double y, long double x);
extern long double sinhl (long double x);
extern long double coshl (long double x);
extern long double tanhl (long double x);

__INLINE long double ceill (long double x);
__INLINE long double floorl(long double x);

extern long double fabsl (long double x);

extern long double ldexpl(long double x, int n);
extern long double frexpl(long double x, int *exp);
extern long double modfl (long double x, long double *ip);
extern long double fmodl (long double x, long double y);

/* An inline version of fmod that works for limited domain only */
/* See comments in implementation below */
static inline long double _FMODL(long double x, long double y);

extern long double _roundl(long double x); /* round-to-nearest */
extern long double _truncl(long double x); /* truncate towards 0 */

#ifdef _TI_ENHANCED_MATH_H
#if 0
/* ------------------------------------------------- */
/* Routines below are an addition to ANSI math.h     */
/* Some (noted with "9x" in comment) will become ANSI*/
/* once C9x is approved.                             */
/* ------------------------------------------------- */
#endif

#define HUGE_VALL LDBL_MAX /* ## */

extern long double rsqrtl(long double x); /*    1/sqrtl(x) but *MUCH* faster */
extern long double exp2l (long double x); /* 9x math equiv to powl(2.0 ,x)   */
extern long double exp10l(long double x); /*    math equiv to powl(10.0,x)   */
extern long double log2l (long double x); /* 9x math equiv to logl(x)/logl(2)*/

extern long double powil (long double x, int i); /* == powl(x,(long double)i)*/

extern long double cotl  (long double x);
extern long double acotl (long double x);
extern long double acot2l(long double x, long double y);

extern long double cothl (long double x);

extern long double asinhl(long double x); /* 9x */
extern long double acoshl(long double x); /* 9x */
extern long double atanhl(long double x); /* 9x */
extern long double acothl(long double x);

#define roundl(x) _roundl(x) /* 9x round-to-nearest   */
#define truncl(x) _truncl(x) /* 9x truncate towards 0 */

#endif


#ifdef _INLINE
/****************************************************************************/
/*  Inline versions of floorl, ceill, fmodl                                 */
/****************************************************************************/

static inline long double floorl(long double x) 
{
   long double y; 
   return (modfl(x, &y) < 0 ? y - 1 : y);
}

static inline long double ceill(long double x)
{
   long double y; 
   return (modfl(x, &y) > 0 ? y + 1 : y);
}

/* 
   The implementation below does not work correctly for all cases.
   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).
   The correct result is one of 0,1, or 2.
   But the implementation below will *always* return 0 
   because the quotient is only an approximation.
*/
static inline long double _FMODL(long double x, long double y)
{
   long double d = fabsl(x); 
   if (d - fabsl(y) == d) return (0);
   modfl(x/y, &d);  
   return (x - d * y);
}

#endif
#undef __INLINE

#endif

#endif /* __mathl__ */
numconst.h/     868562440   0     0     0       6141      `
/****************************************************************************/
/*  numconst  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:58 EDT 1997 */

#ifndef __numconst__
#define __numconst__

#if 0
/*---------------------------------------------------------------------------*/
/* Numerical Constants                                                       */
/*---------------------------------------------------------------------------*/
/* Most of the following constants are taken from                            */
/* "Standard Mathematical Tables", (18th edition, 1970),                     */
/* Editor-In-Chief: Samuel M. Selby Ph.D. Sc.D.,                             */
/* The Chemical Rubber Co. 18901 Cranwood Parkway, Cleveland, Ohio 44128.    */
/* Page 6.                                                                   */
/*---------------------------------------------------------------------------*/
/* The following conventions are used:                                       */
/* Ln  = "log base e"                                                        */
/* Log = "log base 10"                                                       */
/*                                                                           */
/* compile-time division is avoided in favor of multiplication.              */
/*---------------------------------------------------------------------------*/



/*---------------------------------------------------------------------------*/
/* Common values.                                                            */
/*---------------------------------------------------------------------------*/
#endif

#define ZERO      CNST(0.0)
#define SIXTEENTH CNST(0.0625)
#define EIGHTH    CNST(0.125)
#define TENTH     CNST(0.1)
#define QUARTER   CNST(0.25)
#define THIRD     CNST(0.3333333333333333333333333333333333333333333333333)
#define HALF      CNST(0.5)
#define ONE       CNST(1.0)
#define TWO       CNST(2.0)
#define THREE     CNST(3.0)
#define FOUR      CNST(4.0)
#define SIX       CNST(6.0)
#define TEN       CNST(10.0)
#define SIXTEEN   CNST(16.0)

#define M_ONE     CNST(-1.0)
#define M_TWO     CNST(-2.0)


#if 0
/*---------------------------------------------------------------------------*/
/* PI constants                                                              */
/*---------------------------------------------------------------------------*/
#endif
#define Pi          CNST(3.14159265358979323846264338327950288419716939937510)
#define Two_Pi      (MPYF(Pi,TWO))
#define One_Over_Pi CNST(0.31830988618379067153776752674502872406891929148091)
#define Two_Over_Pi (MPYF(TWO,One_Over_Pi))

#define Pi_Over_Two   (MPYF(Pi,HALF))
#define Pi_Over_Three (DIVF(Pi,CNST(3.0)))
#define Pi_Over_Four  (MPYF(Pi,CNST(0.25)))
#define Pi_Over_Six   (MPYF(Pi_Over_Three,HALF))

#define Pi_Squared   CNST(9.86960440108935861883449099987615113531369940724079)
#define Ln_Pi        CNST(1.14472988584940017414342735135305871164729481291531)
#define Log_Pi       CNST(0.49714987269413385435126828829089887365167832438044)
#define Log_Sqrt_Two_Pi CNST(0.39908993417905752478250359150769595020993410292127)


#if 0
/*---------------------------------------------------------------------------*/
/* Constants Involving e                                                     */
/*---------------------------------------------------------------------------*/
#endif
#define Naperian_e CNST(2.71828182845904523536028747135266249775724709369995)
#define One_Over_e CNST(0.36787944117144232159552377016146086744581113103176)

#define e_Squared CNST(7.38905609893065022723042746057500781318031557055184)

#define Ln_10 CNST(2.30258509299404568401799145468436420760110148862877)
#define One_Over_Log_e Ln_10

#define One_Over_Ln_10 CNST(0.43429448190325182765112891891660508229439700580366)
#define Log_e One_Over_Ln_10


#if 0
/*---------------------------------------------------------------------------*/
/* Pi**e and e**Pi Constants                                                 */
/*---------------------------------------------------------------------------*/
#endif
#define Pi_To_e            CNST(22.4591577183610454734271522) 
#define e_To_Pi            CNST(23.1406926327792690057290864)
#define e_To_Minus_Pi      CNST( 0.0432139182637722497744177)
#define e_To_Hlf_Pi        CNST( 4.8104773809653516554730357)
#define e_To_Minus_Hlf_Pi  CNST( 0.2078795763507619085469556)


#if 0
/*---------------------------------------------------------------------------*/
/* Numerical Constants                                                       */
/*---------------------------------------------------------------------------*/
#endif
#define Sqrt_2       CNST(1.41421356237309504880168872420969807856967187537694)
#define Cube_Root_2  CNST(1.25992104989487316476721060727822835057025146470150)
#define One_Over_Sqrt_2 CNST(0.70710678118654752440)
#define Ln_2         CNST(0.69314718055994530941723212145817656807550013436025)
#define One_Over_Ln_2 CNST(1.44269504088896340735)
#define Log_2        CNST(0.30102999566398119521373889472449302676818988146210)
#define Sqrt_3       CNST(1.73205080756887729352744634150587236694280525381038)

#define Cube_Root_3  CNST(1.44224957030740838232163831078010958839186925349935)
#define Ln_3         CNST(1.09861228866810969139524523692252570464749055782274)
#define Log_3        CNST(0.47712125471966243729502790325511530920012886419069)


#if 0
/*---------------------------------------------------------------------------*/
/* Other Constants                                                           */
/*---------------------------------------------------------------------------*/
#endif
#define Gamma     CNST( 0.57721566490153286061) /* Euler's Constant */
#define Ln_Gamma  CNST(-0.54953931298164482234)

#define Phi CNST(1.618033988749894848204586834365638117720309180)/*Gold Ratio*/

#endif /*__numconst__*/

reald.h/        868562440   0     0     0       568       `
/****************************************************************************/
/*  reald  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:39 EDT 1997 */

#ifndef __reald__
#define __reald__

#include <limits.h>
#include <errno.h>
#include "c60_64.h"
#include "formi64.h"
#include "syntd.h"
#include "math.h"

#endif /*__reald__ */
realdi.h/       868562440   0     0     0       591       `
/****************************************************************************/
/*  realdi  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:59 EDT 1997 */

#ifndef __realdi__
#define __realdi__

#include <limits.h>
#include <errno.h>
#include "c60_64.h"
#include "formi64.h"
#include "syntdi.h"
#include "ieeed.h"
#include "math.h"

#endif /*__realdi__ */

realf.h/        868562440   0     0     0       569       `
/****************************************************************************/
/*  realf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:06 EDT 1997 */

#ifndef __realf__
#define __realf__

#include <limits.h>
#include <errno.h>
#include "c60_32.h"
#include "formi32.h"
#include "syntf.h"
#include "mathf.h"

#endif /*__realf__ */

realfi.h/       868562442   0     0     0       592       `
/****************************************************************************/
/*  realfi  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:07:59 EDT 1997 */

#ifndef __realfi__
#define __realfi__

#include <limits.h>
#include <errno.h>
#include "c60_32.h"
#include "formi32.h"
#include "syntfi.h"
#include "ieeef.h"
#include "mathf.h"

#endif /*__realfi__ */
renormd.h/      868562442   0     0     0       2354      `
/****************************************************************************/
/*  renormd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:09:59 EDT 1997 */

#ifndef __RENORMF__
#define __RENORMF__

#include "realdi.h"

#if (BPREAL == BPbigint)
   /* #define COUNT_LZERO(nnn) DEFAULT_IS_UNDEFINED                          */
   /* If defined, must be macro that returns the count of the number of      */
   /* consecutive zero bits at the most significant end of nnn.              */
   /* If COUNT_LZERO is not defined, alternate implementations will be used. */


   /* int RENORMF(bigint ff, int ee)                                         */
   /* ff (0<ff<REAL_HIDDEN_BIT) is left shifted until ff >= REAL_HIDDEN_BIT. */
   /* At least one shift is required.                                        */
   /* ee is decremented by the number of shifts.                             */
   #ifdef Support_DENORM
      #ifdef COUNT_LZERO
         #define RENORMF(ff,ee) do {int tmp = \
                                   COUNT_LZERO(ff)-BPbigint+\
                                   (REAL_FRC_MSBs)+1;\
                                ff <<= tmp; ee -= tmp-1;} while(0)
      #else
         #define RENORMF(ff,ee) while ((ff <<= 1) < REAL_HIDDEN_BIT) ee -= 1
      #endif
   #endif

   /* int RENORM2F(bigint ff, int ee)                                        */
   /* ff (0<ff<REAL_HIDDEN_BIT*2) is left shifted until ff>=REAL_HIDDEN_BIT*2*/
   /* At least one shift is required.                                        */
   /* ee is decremented by the number of shifts.                             */
   #ifdef COUNT_LZERO
      #define RENORM2F(ff,ee) do {int tmp=\
                                COUNT_LZERO(ff)-BPbigint+\
                                (REAL_FRC_BITS%BPbigint)+2;\
                               ff <<= tmp; ee -= tmp;} while (0)
   #else
      #define RENORM2F(ff,ee) do ee -= 1; while ((ff <<= 1) < REAL_HIDDEN_BIT*2)
   #endif
#elif (BPREAL == (BPbigint*2))
   extern int RENORMF(REAL_2UNS *ff);
#else
   #error "RENORMF not yet implemented for this size REAL"
#endif

#endif /* __RENORMF__ */
renormf.h/      868562442   0     0     0       2354      `
/****************************************************************************/
/*  renormf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:00 EDT 1997 */

#ifndef __RENORMF__
#define __RENORMF__

#include "realfi.h"

#if (BPREAL == BPbigint)
   /* #define COUNT_LZERO(nnn) DEFAULT_IS_UNDEFINED                          */
   /* If defined, must be macro that returns the count of the number of      */
   /* consecutive zero bits at the most significant end of nnn.              */
   /* If COUNT_LZERO is not defined, alternate implementations will be used. */


   /* int RENORMF(bigint ff, int ee)                                         */
   /* ff (0<ff<REAL_HIDDEN_BIT) is left shifted until ff >= REAL_HIDDEN_BIT. */
   /* At least one shift is required.                                        */
   /* ee is decremented by the number of shifts.                             */
   #ifdef Support_DENORM
      #ifdef COUNT_LZERO
         #define RENORMF(ff,ee) do {int tmp = \
                                   COUNT_LZERO(ff)-BPbigint+\
                                   (REAL_FRC_MSBs)+1;\
                                ff <<= tmp; ee -= tmp-1;} while(0)
      #else
         #define RENORMF(ff,ee) while ((ff <<= 1) < REAL_HIDDEN_BIT) ee -= 1
      #endif
   #endif

   /* int RENORM2F(bigint ff, int ee)                                        */
   /* ff (0<ff<REAL_HIDDEN_BIT*2) is left shifted until ff>=REAL_HIDDEN_BIT*2*/
   /* At least one shift is required.                                        */
   /* ee is decremented by the number of shifts.                             */
   #ifdef COUNT_LZERO
      #define RENORM2F(ff,ee) do {int tmp=\
                                COUNT_LZERO(ff)-BPbigint+\
                                (REAL_FRC_BITS%BPbigint)+2;\
                               ff <<= tmp; ee -= tmp;} while (0)
   #else
      #define RENORM2F(ff,ee) do ee -= 1; while ((ff <<= 1) < REAL_HIDDEN_BIT*2)
   #endif
#elif (BPREAL == (BPbigint*2))
   extern int RENORMF(REAL_2UNS *ff);
#else
   #error "RENORMF not yet implemented for this size REAL"
#endif

#endif /* __RENORMF__ */
setjmp.h/       868562442   0     0     0       725       `
/*****************************************************************************/
/* setjmp.h   v1.10#                                                         */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _SETJMP
#define _SETJMP

/****************************************************************************/
/* SAVE AND RESTORE CONTEXT AREA.                                           */
/****************************************************************************/
typedef int jmp_buf[13];

int  _setjmp(jmp_buf _env); 
void longjmp(jmp_buf _env, int _val);

#define setjmp(_x) _setjmp(_x)

#endif


stdarg.h/       868562442   0     0     0       1394      `
/*****************************************************************************/
/* stdarg.h   v1.10#                                                         */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STDARG
#define _STDARG

typedef char *va_list;
 
/********************************************************************/
/* WARNING - va_arg will not work for "float" type, must use double */
/* ALSO NOTE THAT DOUBLES MUST BE DOUBLE WORD ALIGNED               */
/********************************************************************/
#define va_end(_ap)
  
#define va_start(_ap, _parmN) \
         (_ap = ((char *)&(_parmN)) + (sizeof(_parmN) < 4 ? 4 : sizeof(_parmN)))

#ifdef _TMS320C6200
#define va_arg(_ap, _type)                                       \
         (sizeof(_type) == sizeof(double)                        \
             ? ((_ap += 8), (*(_type *)(_ap - 8)))               \
	     : ((_ap += 4), (*(_type *)(_ap - 4))))
#else
#define va_arg(_ap, _type)                                       \
         ((sizeof(_type) == sizeof(double)                       \
             ? ((_ap = (void *)(((int)_ap + 7) & ~7)),           \
	        (_ap += 8), (*(_type *)(_ap - 8)))               \
	     : ((_ap += 4), (*(_type *)(_ap - 4)))))
#endif

#endif
stddef.h/       868562442   0     0     0       632       `
/*****************************************************************************/
/* stddef.h   v1.10#                                                         */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STDDEF
#define _STDDEF

#ifndef NULL
#define NULL ((void *)0)
#endif

typedef int ptrdiff_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned int size_t;
#endif

#ifndef _WCHAR_T
#define _WCHAR_T
typedef char wchar_t;
#endif

#define offsetof(_type, _ident) ((size_t)(&((_type *)0)->_ident))

#endif

stdio.h/        868562442   0     0     0       9783      `
/*****************************************************************************/
/* STDIO.H V1.10#                                                            */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STDIO 
#define _STDIO

/****************************************************************************/
/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */
/****************************************************************************/
#ifndef _SIZE_T                                                    
#define _SIZE_T                                                    
typedef unsigned size_t;                                           
#endif

typedef struct {
         int fd;                    /* File descriptor */
         unsigned char* buf;        /* Pointer to start of buffer */
         unsigned char* pos;        /* Position in buffer */
         unsigned char* bufend;     /* Pointer to end of buffer */
         unsigned char* buff_stop;  /* Pointer to last read char in buffer */
         unsigned int   flags;      /* File status flags (see below) */
         int index;                 /* Location in ftable */
} FILE;

#ifndef _FPOS_T
#define _FPOS_T
#if defined(_TMS320C6X)
typedef int fpos_t;
#else
typedef long fpos_t;
#endif
#endif

/****************************************************************************/
/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */
/****************************************************************************/
#define _IOFBF       0x0001
#define _IOLBF       0x0002
#define _IONBF       0x0004
#define _BUFFALOC    0x0008
#define _MODER       0x0010
#define _MODEW       0x0020
#define _MODERW      0x0040
#define _MODEA       0x0080
#define _MODEBIN     0x0100
#define _STATEOF     0x0200
#define _STATERR     0x0400
#define _UNGETC      0x0800
#define _TMPFILE     0x1000

#define _SET(_fp, _b)      (((_fp)->flags) |= (_b))
#define _UNSET(_fp, _b)    (((_fp)->flags) &= ~(_b))
#define _STCHK(_fp, _b)    (((_fp)->flags) & (_b))
#define _BUFFMODE(_fp)     (((_fp)->flags) & (_IOFBF | _IOLBF | _IONBF))
#define _ACCMODE(_fp)      (((_fp)->flags) & (_MODER | _MODEW))

/****************************************************************************/
/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */
/****************************************************************************/
#define BUFSIZ          256 
#define FOPEN_MAX       12
#define FILENAME_MAX    256  
#define TMP_MAX         65535

#define SEEK_SET  (0x0000)
#define SEEK_CUR  (0x0001)
#define SEEK_END  (0x0002)

#ifndef NULL
#define NULL 0
#endif

#ifndef EOF
#define EOF    (-1)
#endif

#define stdin     (&_ftable[0])      
#define stdout    (&_ftable[1])
#define stderr    (&_ftable[2])

#define L_tmpnam  (sizeof(P_tmpdir) + 15)

/******** END OF ANSI MACROS ************************************************/

#define P_tmpdir        ""                   /* Path for temp files         */

/****************************************************************************/
/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */
/****************************************************************************/
#define _NFILE          20                   /* Max number of files open    */
#define _NSTREAM        20                   /* Size of stream table        */
#define _NDEVICE        3                    /* Size of device table        */

#define _SSA      (0x0000)             /* Single Stream allowed       */
#define _BUSY     (0x0001)             /* Device busy                 */
#define _MSA      (0x0002)             /* Multiple Streams Allowed    */

#define stdevice        (&_device[0])        /* Default device (host)       */

typedef struct {                             
   char  name[9];
   unsigned short flags;
   int (*OPEN) ();
   int (*CLOSE) ();
   int (*READ) ();
   int (*WRITE) ();
   fpos_t (*LSEEK) ();
   int (*UNLINK) ();
   int (*RENAME) ();
} _DEVICE;

extern FILE _ftable[_NFILE];
extern char _tmpnams[_NFILE][L_tmpnam];

/****************************************************************************/
/*   FUNCTION DEFINITIONS  - ANSI                                           */
/****************************************************************************/
/****************************************************************************/
/* OPERATIONS ON FILES                                                      */
/****************************************************************************/
       int     remove(const char *_file);
extern int     rename(const char *_old, const char *_new);
extern FILE   *tmpfile(void);
extern char   *tmpnam(char *_s);

/****************************************************************************/
/* FILE ACCESS FUNCTIONS                                                    */
/****************************************************************************/
extern int    fclose(FILE *_fp); 
extern FILE   *fopen(const char *_fname, const char *_mode);
extern FILE   *freopen(const char *_fname, const char *_mode,
               register FILE *_fp);
extern void    setbuf(register FILE *_fp, char *_buf);
extern int     setvbuf(register FILE *_fp, register char *_buf, 
                       register int _type,  register size_t _size); 
extern int     fflush(register FILE *_fp); 

/****************************************************************************/
/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern int     fprintf(FILE *_fp, const char *_format, ...);
extern int     fscanf(FILE *_fp, const char *_fmt, ...);
extern int     printf(const char *_format, ...);
extern int     scanf(const char *_fmt, ...);
extern int     sprintf(char *_string, const char *_format, ...);
extern int     sscanf(const char *_str, const char *_fmt, ...);
extern int     vfprintf(FILE *_fp, const char *_format, char *_ap);
extern int     vprintf(const char *_format, char *_ap);
extern int     vsprintf(char *_string, const char *_format, char *_ap);

/****************************************************************************/
/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern int     fgetc(register FILE *_fp);
extern char   *fgets(char *_ptr, register int _size, register FILE *_fp);
extern int     fputc(int _c, register FILE *_fp);
extern int     fputs(const char *_ptr, register FILE *_fp);
extern int     getc(FILE *_p);
       int     getchar(void);
extern char   *gets(char *_ptr); 
extern int     putc(int _x, FILE *_fp);
       int     putchar(int _x);
extern int     puts(const char *_ptr); 
extern int     ungetc(int _c, register FILE *_fp);

/****************************************************************************/
/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */
/****************************************************************************/
extern size_t    fread(void *_ptr, size_t _size, size_t _count, FILE *_fp);
extern size_t    fwrite(const void *_ptr, size_t _size, size_t _count,
                        register FILE *_fp); 

/****************************************************************************/
/* FILE POSITIONING FUNCTIONS                                               */
/****************************************************************************/
extern int       fgetpos(FILE *_fp, fpos_t *_pos);
extern int       fseek(register FILE *_fp, long _offset, int _ptrname);
extern int       fsetpos(FILE *_fp, const fpos_t *_pos);
extern long      ftell(FILE *_fp);
extern void  rewind(register FILE *_fp); 

/****************************************************************************/
/* ERROR-HANDLING FUNCTIONS                                                 */
/****************************************************************************/
       void      clearerr(FILE *_fp);
extern int       feof(FILE *_fp);
       int       ferror(FILE *_fp);
extern void      perror(const char *_s);
                

#define _getchar()      getc(stdin)
#define _putchar(_x)    putc((_x), stdout)
#define _clearerr(_fp)   ((void) ((_fp)->flags &= ~(_STATERR | _STATEOF)))

#define _ferror(_x)     ((_x)->flags & _STATERR)

#define _remove(_fl)    (unlink((_fl)))

/******* END OF ANSI FUNCTIONS  *********************************************/


/****************************************************************************/
/* GETENV IS SUPPOSED TO BE IN STDLIB.H IN THE RTS.LIB, BUT BECAUSE STDIO.H */
/* IS THE ONLY HEADER FILE THAT USES ROUTINES TO INTERFACE WITH THE HOST    */
/* OPERATING SYSTEM, GETENV WAS PLACED HERE.                                */
/****************************************************************************/
char            *getenv(const char *_string);

/****************************************************************************/
/* LOW LEVEL FUNCTION PROTOTYPES                                            */
/****************************************************************************/
extern int       add_device(char           *name,
                            unsigned        flags,
                  int            (*dopen)(),
                  int            (*dclose)(),
                  int            (*dread)(),
                  int            (*dwrite)(),
                  fpos_t           (*dlseek)(),
                  int            (*dunlink)(),
                  int            (*drename)());
#endif

stdlib.h/       868562442   0     0     0       2538      `
/*****************************************************************************/
/* stdlib.h   v1.10#                                                         */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STDLIB
#define _STDLIB

typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;

#define MB_CUR_MAX    1

#ifndef NULL
#define NULL          0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned int size_t;
#endif

#ifndef _WCHAR_T
#define _WCHAR_T
typedef char wchar_t;
#endif

#define EXIT_FAILURE  0
#define EXIT_SUCCESS  1

#define RAND_MAX 32767

#ifdef _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

/*---------------------------------------------------------------*/
/* NOTE - Normally, abs, labs, and fabs are expanded inline, so  */
/*        no formal definition is really required. However, ANSI */
/*        requires that they exist as separate functions.        */
/*---------------------------------------------------------------*/
         int    abs(int _val); 
         long   labs(long _val);
        
         int    atoi(const char *_st);
__INLINE long   atol(const char *_st);
__INLINE double atof(const char *_st);

         long     strtol(const char *_st, char **_endptr, int _base);
         unsigned long strtoul(const char *_st, char **_endptr, int _base);
         double   strtod(const char *_st, char **_endptr);

         int    rand(void);
         void   srand(unsigned _seed);

         void  *calloc(size_t _num, size_t _size);
         void  *malloc(size_t _size);
         void  *realloc(void *_ptr, size_t _size);
         void   free(void *_ptr);
	 void  *memalign(size_t _aln, size_t _size);

         void   abort(void); 
         int    atexit(void (*_func)(void));
         void  *bsearch(const void *_key, const void *_base, size_t _nmemb, 
	                size_t _size, int (*compar)(const void *,const void *));
         void qsort(void *_base, size_t _nmemb, size_t _size, int (*_compar)());
         void   exit(int _status);

         div_t  div(int _numer, int _denom);
         ldiv_t ldiv(long _numer, long _denom);

         char  *getenv(const char *_string);
	 int    system(const char *_name);

#ifdef _INLINE

static inline double atof(const char *_st)  { return strtod(_st, (char **)0); }
static inline long   atol(register const char *st) { return atoi(st); }

#endif
#undef __INLINE

#endif
string.h/       868562442   0     0     0       7884      `
/*****************************************************************************/
/* string.h   v1.10#                                                         */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STRING
#define _STRING
 
#ifndef NULL
#define NULL 0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#ifdef _INLINE 
#define __INLINE static inline
#else
#define __INLINE
#endif

__INLINE size_t  strlen(const char *_string);
__INLINE char   *strcpy(char *_dest, const char *_src);
__INLINE char   *strncpy(char *_to, const char *_from, size_t _n);
__INLINE char   *strcat(char *_string1, const char *_string2);
__INLINE char   *strncat(char *_to, const char *_from, size_t _n);
__INLINE char   *strchr(const char *_string, int _c);
__INLINE char   *strrchr(const char *_string, int _c);
__INLINE int     strcmp(const char *_string1, const char *_string2);
__INLINE int     strncmp(const char *_string1, const char *_string2, size_t _n);
        
         int     strcoll(const char *_string1, const char *_string2);
         size_t  strxfrm(char *_to, const char *_from, size_t _n);
         char   *strpbrk(const char *_string, const char *_chs);
         size_t  strspn(const char *_string, const char *_chs);
         size_t  strcspn(const char *_string, const char *_chs);
         char   *strstr(const char *_string1, const char *_string2);
         char   *strtok(char *_str1, const char *_str2);
         char   *strerror(int _errno);
        
         void   *memmove(void *_s1, const void *_s2, size_t _n);
	 void   *memcpy(void *_s1, const void *_s2, size_t _n);
__INLINE int     memcmp(const void *_cs, const void *_ct, size_t _n);
__INLINE void   *memchr(const void *_cs, int _c, size_t _n);
__INLINE void   *memset(void *_mem, int _ch, size_t _n);

#ifdef _INLINE

/****************************************************************************/
/*  strlen                                                                  */
/****************************************************************************/
static inline size_t strlen(const char *string)
{
   size_t      n = -1;
   const char *s = string - 1;

   do n++; while (*++s);
   return n;
}

/****************************************************************************/
/*  strcpy                                                                  */
/****************************************************************************/
static inline char *strcpy(char *dest, const char *src)
{
   register char       *d = dest - 1;
   register const char *s = src  - 1;

   while (*++d = *++s);
   return dest;
}

/****************************************************************************/
/*  strncpy                                                                 */
/****************************************************************************/
static inline char *strncpy(char *dest, const char *src, size_t n)
{
    if (n)
    {
	char       *d = dest - 1;
	const char *s = src  - 1;

	while ((*++d = *++s) && --n);              /* COPY STRING         */
	if (n-- > 1) do *++d = '\0'; while (--n);  /* TERMINATION PADDING */
    }
    return dest;
}

/****************************************************************************/
/*  strcat                                                                  */
/****************************************************************************/
static inline char *strcat(char *string1, const char *string2)
{
    char       *s1 = string1 - 1;
    const char *s2 = string2 - 1;

    while (*++s1);                     /* FIND END OF STRING   */
    s1--;                              /* BACK UP OVER NULL    */
    while (*++s1 = *++s2);             /* APPEND SECOND STRING */
    return string1;
}

/****************************************************************************/
/*  strncat                                                                 */
/****************************************************************************/
static inline char *strncat(char *dest, const char *src, size_t n)
{
    if (n) 
    {
	char       *d = dest - 1;
	const char *s = src  - 1;

	while (*++d);                    /* FIND END OF STRING   */
	d--;                             /* BACK UP OVER NULL    */
	while ((*++d = *++s) && --n);    /* APPEND SECOND STRING */
	*++d = 0;
    }
    return dest;
}

/****************************************************************************/
/*  strchr                                                                  */
/****************************************************************************/
static inline char *strchr(const char *string, int c)
{
    char        tch, ch = c;
    const char *s       = (char *) string - 1;

    for (;;)
    {
	if ((tch = *++s) == ch) return (char *) s;
	if (!tch)               return (char *) 0;
    }
}

/****************************************************************************/
/*  strrchr                                                                 */
/****************************************************************************/
static inline char *strrchr(const char *string, int c)
{
   char        tch, ch = c;
   char       *result  = 0;
   const char *s       = string - 1;

   for (;;)
   {
      if ((tch = *++s) == ch) result = (char *) s;
      if (!tch) break;
   }

   return result;
}

/****************************************************************************/
/*  strcmp                                                                  */
/****************************************************************************/
static inline int strcmp(const char *string1, const char *string2)
{
   const char *s1 = string1 - 1;
   const char *s2 = string2 - 1;
   char        cp1;
   char        cp2;

   while (((cp1 = *++s1) == (cp2 = *++s2)) && cp1);
   return cp1 - cp2;
}

/****************************************************************************/
/*  strncmp                                                                 */
/****************************************************************************/
static inline int strncmp(const char *string1, const char *string2, size_t n)
{
     if (n) 
     {
	 const char *s1 = string1 - 1;
	 const char *s2 = string2 - 1;
	 char        cp;
	 int         result;

	 do 
	    if (result = *++s1 - (cp = *++s2)) return result;
	 while (cp && --n);
     }
     return 0;
}

/****************************************************************************/
/*  memcmp      							    */
/****************************************************************************/
static inline int memcmp(const void *cs, const void *ct, size_t n)
{
    if (n)
    {
	const unsigned char *mem1 = (unsigned char *)cs - 1;
	const unsigned char *mem2 = (unsigned char *)ct - 1;
	int                  cp;
	
	while ((cp = *++mem1) == *++mem2 && --n);
	return cp - *mem2;
    }
    return 0;
}

/****************************************************************************/
/*  memchr                                                                  */
/****************************************************************************/
static inline void *memchr(const void *cs, int c, size_t n)
{
    if (n)
    {
	const unsigned char *mem = (unsigned char *)cs - 1;
	unsigned char        ch  = c;

	do if ( *++mem == ch ) return (void *)mem;
	while (--n);
    }
    return NULL;
}

/****************************************************************************/
/*  memset                                                                  */
/****************************************************************************/
static inline void *memset(void *s, int c, size_t n)
{
    register char *m = (char *)s - 1;

    while (n--) *++m = c;
    return s;
}

#endif

#undef __INLINE

#endif

syntd.h/        868562442   0     0     0       15242     `
/****************************************************************************/
/*  syntd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:40 EDT 1997 */

#ifndef __syntd__
#define __syntd__

#if 0
/*---------------------------------------------------------------------------*/
/* Bind abstract REAL to "double" syntax.                                    */
/* Use built-in operators for unary -, +,-,*,/, >,<,>=,<=,==,!=, =           */
/* Use ANSI names for double version of math.h routines (sqrt, sin, ... etc) */
/*---------------------------------------------------------------------------*/
#endif

#define REAL double
#define EXPONENT_TYPE int

#if BPLEAN == 0
   #undef LEAN
#else /* since REAL is "double", assume next smallest is "float" */
   #define LEAN float
#endif

#define CNST(x) (x) /* constants within statements */
#define TSNC
#define KNST(x) x   /* constants within tables     */
#define TSNK

#include "numconst.h" /* NUMerical CONSTants used by some definitions below */

#if 0
/*---------------------------------------------------------------------------*/
/* Define Compiler Syntax For Basic Operations                               */
/*---------------------------------------------------------------------------*/
/* Names have form: <operation> F { 1 | 2 | 3 }?                             */
/* Where <operation> is one of:                                              */
/*    CPY  -- simple assignment                                              */
/*    NEG  -- negative                                                       */
/*    ABS  -- absolute value                                                 */
/*    SQR  -- square                                                         */
/*    INV  -- inverse (1/x)                                                  */
/*    ADD  -- plus                                                           */
/*    SUB  -- subtract                                                       */
/*    MPY  -- multiply                                                       */
/*    DIV  -- division                                                       */
/*    EQL  -- ==                                                             */
/*    NEQ  -- !=                                                             */
/*    GTR  -- >                                                              */
/*    GEQ  -- >=                                                             */
/*    LSS  -- <                                                              */
/*    LEQ  -- <=                                                             */
/*    EQZ  -- == 0.0                                                         */
/*    NEZ  -- != 0.0                                                         */
/*    GTZ  -- >  0.0                                                         */
/*    GEZ  -- >= 0.0                                                         */
/*    LSZ  -- <  0.0                                                         */
/*    LEZ  -- <= 0.0                                                         */
/* F means REAL                                                              */
/* If no 1,2 or 3 suffix then is function returning result.                  */
/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */
/*    1 -> right = operation right;                                          */
/*    2 -> dst   = operation right;      ( unary operations)                 */
/*         left  = left operation right; (binary operations)                 */
/*    3 -> dst   = left operation right;                                     */
/*---------------------------------------------------------------------------*/
#endif

#define CPYF(dst,right) dst=(right)

#define NEGF(right) (-(right))
#define ABSF(right) (LSSF(right,ZERO) ? NEGF(right) : (right))
#define SQRF(right) ((right) * (right))
#define INVF(right) DIVF(ONE,right)

#define ADDF(left,right) ((left)+(right))
#define SUBF(left,right) ((left)-(right))
#define MPYF(left,right) ((left)*(right))
#define DIVF(left,right) ((left)/(right))

#define NEGF2(dst,right) dst=(-(right))
#define ABSF2(dst,right) dst=(LSSF(right,ZERO)?NEGF(right):(right))
#define SQRF2(dst,right) dst=(right)*(right)
#define INVF2(dst,right) dst=INVF(right)

#define ADDF3(dst,left,right) dst=(left)+(right)
#define SUBF3(dst,left,right) dst=(left)-(right)
#define MPYF3(dst,left,right) dst=(left)*(right)
#define DIVF3(dst,left,right) dst=(left)/(right)

#define NEGF1(right) (right)=-(right)
#define ABSF1(right) if LSSF(right,ZERO) NEGF1(right)
#define SQRF1(right) (right)*=(right)
#define INVF1(right) (right)=INVF(right)

#define ADDF2(left,right) (left)+=(right)
#define SUBF2(left,right) (left)-=(right)
#define RSBF2(left,right) (left) =(right)-(left)
#define MPYF2(left,right) (left)*=(right)
#define DIVF2(left,right) (left)/=(right)

#define CMPF(left,right) ((left)<(right)?-1:((left)!=(right)))
#define CMPF3(dst,left,right) dst=CMPF(left,right)

#define EQLF(left,right) ((left)==(right))
#define NEQF(left,right) ((left)!=(right))
#define LEQF(left,right) ((left)<=(right))
#define GEQF(left,right) ((left)>=(right))
#define GTRF(left,right) ((left)>(right))
#define LSSF(left,right) ((left)<(right))

#define EQZF(left) EQLF(left,ZERO)
#define NEZF(left) NEQF(left,ZERO)
#define LEZF(left) LEQF(left,ZERO)
#define GEZF(left) GEQF(left,ZERO)
#define GTZF(left) GTRF(left,ZERO)
#define LSZF(left) LSSF(left,ZERO)



#if 0
/*---------------------------------------------------------------------------*/
/* Compose and Decompose REAL                                                */
/* integer <-> REAL conversion operations                                    */
/* REAL whole number conversions                                             */
/* REAL whole number conversions, caller KNOWS whole number fits in int      */
/* Exact Remainder                                                           */
/*---------------------------------------------------------------------------*/
/* Names have form: <operation> F { 1 | 2 | 3 }?                             */
/* Where <operation> is one of:                                              */
/*    SCL  -- f * RADIX**e                                                   */
/*    RIP  -- decompose x into f,e such that x == f*RADIX**e and 1/RADIX<=f<1*/
/*                                                                           */
/*    FIX  -- truncate towards zero and convert to int                       */
/*    FLT  -- convert int  to REAL                                           */
/*                                                                           */
/*    TNC  -- truncate towards 0                (x fits in int)              */
/*    RND  -- round to nearest whole number REAL(x fits in int)              */
/*    FLR  -- truncate towards minus infinity   (x fits in int)              */
/*    CEI  -- truncate towards plus  infinity   (x fits in int)              */
/*                                                                           */
/*    REM  -- *EXACT* remainder (big horrible by-hand divide routine)        */
/*                                                                           */
/* Note that the following whole number approximation rtns exist in math.h:  */
/*    TRUNCF -- truncate towards 0                (x any value)              */
/*    ROUNDF -- round to nearest whole number REAL(x any value)              */
/*    FLOORF -- truncate towards minus infinity   (x any value)              */
/*    CEILF  -- truncate towards plus  infinity   (x any value)              */
/*                                                                           */
/* F means REAL                                                              */
/* If no 1,2 or 3 suffix then is function returning result.                  */
/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */
/*    1 -> right = operation right;                                          */
/*    2 -> dst   = operation right;      ( unary operations)                 */
/*         left  = left operation right; (binary operations)                 */
/*    3 -> dst   = left operation right;                                     */
/*---------------------------------------------------------------------------*/
#endif

#define RIPF(x,f,e) f=FREXPF((x),&e)

#define SCLF(f,e)            LDEXPF((f),(e))
#define SCLF2(f,e)       f = LDEXPF((f),(e))
#define SCLF3(dst,f,e) dst = LDEXPF((f),(e))

#define FIXFC(x) ((char)(x))
#define FLTCF(x) ((REAL)(x))

#define FIXFB(x) ((unsigned char)(x))
#define FLTBF(x) ((REAL)(x))

#define FIXFSI(x) ((short)(x))
#define FLTSIF(x) ((REAL)(x)) 

#define FIXFUS(x) ((unsigned short)(x))
#define FLTUSF(x) ((REAL)(x))

#define FIXFI(x) ((int)(x))
#define FLTIF(x) ((REAL)(x))

#define FIXFU(x) ((unsigned)(x))
#define FLTUF(x) ((REAL)(x))

#define FIXFLI(x) ((long)(x))
#define FLTLIF(x) ((REAL)(x))

#define FIXFUL(x) ((unsigned long)(x))
#define FLTULF(x) ((REAL)(x))

#if 0
/* TNCF, RNDF, FLRF, CEIF, may all use FLTIF(FIXFI(f(x))).                */
/* Call sites must be sure to enforce several rules:                      */
/* 1. TRUNCF(f(x)) must not exceed the integer range.                     */
/* 2. if REAL does unbiased round-towards-even,                           */
/*    input x to RNDF must never equal +/- RADIX_to_Mantissa-1.           */
#endif
#ifndef RND_GLITCH
   #error "REAL format .h file must be included before REAL syntax .h file"
#endif
#if (RND_GLITCH)
   #define RND_MAX_P1 RND_P_GLITCH
   #define RND_MIN    RND_M_GLITCH
#else
   #define RND_MAX_P1 INT_MOST_POS_P1
   #define RND_MIN    INT_MOST_NEG
#endif
#ifndef FLT_FIX_Faster_Than_MODF
   #error "target props .h file must be included before REAL syntax .h file"
#endif
#if (FLT_FIX_Faster_Than_MODF)
   #define TNCF(x) (FLTIF(FIXFI(x)))

   #define RNDF(x) (GEZF(x)? \
                    FLTIF(FIXFI((ADDF((x),HALF)))) : \
                    FLTIF(FIXFI((SUBF((x),HALF)))))

   #define FLRF(x) (GEZF(x) ? \
                    (FLTIF(FIXFI(x))) : \
                     (EQLF(x,FLTIF(FIXFI(x))) ? \
                      x : \
                      (FLTIF(NEGF(FIXFI(ADDF(NEGF(x),ONE)))))))

   #define CEIF(x) (LEZF(x) ? \
                    (FLTIF(FIXFI(x))) : \
                     (EQLF(x,FLTIF(FIXFI(x))) ? \
                      x : \
                      (FLTIF(NEGF(FIXFI(SUBF(NEGF(x),ONE)))))))

#else /* call through to general purpose routines */
   #define TNCF(x) (TRUNCF(x))
   #define RNDF(x) (ROUNDF(x))
   #define FLRF(x) (FLOORF(x))
   #define CEIF(x) (CEILF(x))
#endif

#define FIXFI1(x) x=FIXFI(x)
#define FLTIF1(x) x=FLTIF(x)
#define FIXFU1(x) x=FIXFU(x)
#define FLTUF1(x) x=FLTUF(x)

#define TNCF1(x) x=TNCF(x)
#define RNDF1(x) x=RNDF(x)
#define FLRF1(x) x=FLRF(x)
#define CEIF1(x) x=CEIF(x)

#define FIXFI2(dst,right) dst=FIXFI(right)
#define FLTIF2(dst,right) dst=FLTIF(right)
#define FIXFU2(dst,right) dst=FIXFU(right)
#define FLTUF2(dst,right) dst=FLTUF(right)

#define TNCF2(dst,right) dst=TNCF(right)
#define RNDF2(dst,right) dst=RNDF(right)
#define FLRF2(dst,right) dst=FLRF(right)
#define CEIF2(dst,right) dst=CEIF(right)


#define REMF(right,left)           (FMODF(right,left))
#define REMF1(right,left)     right=FMODF(right,left)
#define REMF2(dst,right,left) dst  =FMODF(right,left)

#if 0
/*---------------------------------------------------------------------------*/
/* IEEE software support specific routines                                   */
/*---------------------------------------------------------------------------*/
#endif
#ifdef LEAN
   #define GROWF(x) ((REAL)(x)) /* grow from LEAN to REAL */
   #define SLIMF(x) ((LEAN)(x)) /* slim from REAL to LEAN */
#endif


#if 0
/*---------------------------------------------------------------------------*/
/* Polynomial evaluation loops macros.                                       */
/*---------------------------------------------------------------------------*/
/* Loops are used for all polynomials.  It is assumed that this              */
/* is more DSP-friendly given that DSP hardware/software has:                */
/*   . zero-overhead looping,                                                */
/*   . optimizations to software pipeline multiply-accumulate,               */
/*   . the lack of full-precision floating-immediate address mode,           */
/*   . relatively expensive fetch of non-tabular constants,                  */
/*   . the existance of auto-increment addressing for table access.          */
/*---------------------------------------------------------------------------*/

/* form of: r=(((K[0]*x + K[1])*x + K[2])*x); r not same as x */
#endif
#define POLYF(r,x,K,s) {int i; REAL *p=K;                             \
                        MPYF3(r,x,*p++);                              \
                        for (i=s-1; i>0; i--) MPYF3(r,x,ADDF(r,*p++));}

#if 0
/* extra add at the end */
/* form of: r=(((K[0]*x + K[1])*x + K[2])*x) + K[3];  r not same as x */
#endif
#define POLYaF(r,x,K,s) {int i; REAL *p=K;                             \
                         MPYF3(r,x,*p++);                              \
                         for (i=s-2; i>0; i--) MPYF3(r,x,ADDF(r,*p++));\
                         ADDF2(r,*p++);}

#if 0
/* form of: r=((K[0]+x)*x + K[1])*x + K[2]) * x) + K[3]; r not same as x */
#endif
#define POLYbF(r,x,K,s) {int i; REAL *p=K;                             \
                         ADDF3(r,x,*p++);                              \
                         for (i=s-1; i>0; i--) ADDF3(r,*p++,MPYF(x,r));}

#if 0
/*---------------------------------------------------------------------------*/
/* Bind The Names Of The Math Library Routines                               */
/*---------------------------------------------------------------------------*/
#endif
#define SQRTF(x)    sqrt(x)
#define RSQRTF(x)   rsqrt(x)
#define EXPF(x)     exp(x)
#define EXP2F(x)    exp2(x)
#define EXP10F(x)   exp10(x)
#define LOGF(x)     log(x)
#define LOG2F(x)    log2(x)
#define LOG10F(x)   log10(x)
#define POWF(x,y)   pow(x,y)
#define POWIF(x,i)  powi(x,i)
#define SINF(x)     sin(x)
#define COSF(x)     cos(x)
#define TANF(x)     tan(x)
#define COTF(x)     cot(x)
#define ASINF(x)    asin(x)
#define ACOSF(x)    acos(x)
#define ATANF(x)    atan(x)
#define ATAN2F(y,x) atan2(y,x)
#define ACOTF(x)    acot(x)
#define ACOT2F(x,y) acot2(x,y)
#define SINHF(x)    sinh(x)
#define COSHF(x)    cosh(x)
#define TANHF(x)    tanh(x)
#define COTHF(x)    coth(x)
#define ASINHF(x)   asinh(x)
#define ACOSHF(x)   acosh(x)
#define ATANHF(x)   atanh(x)
#define ACOTHF(x)   acoth(x)

#define CEILF(x)    ceil(x)
#define FLOORF(x)   floor(x)
#define TRUNCF(x)   _trunc(x)
#define ROUNDF(x)   _round(x)

#define FABSF(x)    fabs(x)

#define LDEXPF(x,n)   ldexp(x,n)
#define FREXPF(x,exp) frexp(x,exp)
#define MODFF(x,ip)   modf(x,ip)
#define FMODF(x,y)    fmod(x,y)

#endif /*__syntd__*/
syntdi.h/       868562442   0     0     0       16415     `
/****************************************************************************/
/*  syntdi  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:00 EDT 1997 */

#ifndef __syntd__
#define __syntd__

#if 0
/*---------------------------------------------------------------------------*/
/* Bind abstract REAL to "double" syntax.                                    */
/* Use ANSI-style function calls for IEEE +,-,*,/, >,<,>=,<=,==,!=, =        */
/* Use d-suffix names for experimental math.h routines (sqrtd, sind, ... etc)*/
/*---------------------------------------------------------------------------*/
#endif

#define REAL double
#define EXPONENT_TYPE int

#if BPLEAN == 0
   #undef LEAN
#else /* since REAL is "double", assume next smallest is "float" */
   #define LEAN float
#endif

#define CNST(x) (x)  /* constants within statements */
#define TSNC
#define KNST(x) x    /* constants within tables     */
#define TSNK

#include "numconst.h" /* NUMerical CONSTants used by some definitions below */

#if 0
/*---------------------------------------------------------------------------*/
/* Define Compiler Syntax For Basic Operations                               */
/*---------------------------------------------------------------------------*/
/* Names have form: <operation> F { 1 | 2 | 3 }?                             */
/* Where <operation> is one of:                                              */
/*    CPY  -- simple assignment                                              */
/*    NEG  -- negative                                                       */
/*    ABS  -- absolute value                                                 */
/*    SQR  -- square                                                         */
/*    INV  -- inverse (1/x)                                                  */
/*    ADD  -- plus                                                           */
/*    SUB  -- subtract                                                       */
/*    MPY  -- multiply                                                       */
/*    DIV  -- division                                                       */
/*    EQL  -- ==                                                             */
/*    NEQ  -- !=                                                             */
/*    GTR  -- >                                                              */
/*    GEQ  -- >=                                                             */
/*    LSS  -- <                                                              */
/*    LEQ  -- <=                                                             */
/*    EQZ  -- == 0.0                                                         */
/*    NEZ  -- != 0.0                                                         */
/*    GTZ  -- >  0.0                                                         */
/*    GEZ  -- >= 0.0                                                         */
/*    LSZ  -- <  0.0                                                         */
/*    LEZ  -- <= 0.0                                                         */
/* F means REAL                                                              */
/* If no 1,2 or 3 suffix then is function returning result.                  */
/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */
/*    1 -> right = operation right;                                          */
/*    2 -> dst   = operation right;      ( unary operations)                 */
/*         left  = left operation right; (binary operations)                 */
/*    3 -> dst   = left operation right;                                     */
/*---------------------------------------------------------------------------*/
#endif

#define CPYF(dst,right) dst=(right)

#define NEGF(right) _negd(right)
#define ABSF(right) _absd(right)
#define SQRF(right) MPYF(right,right)
#define INVF(right) DIVF(ONE,right)

#define ADDF(left,right) _addd(left,right)
#define SUBF(left,right) _subd(left,right)
#define MPYF(left,right) _mpyd(left,right)
#define DIVF(left,right) _divd(left,right)

#define NEGF2(dst,right) dst=NEGF(right)
#define ABSF2(dst,right) dst=ABSF(right)
#define SQRF2(dst,right) dst=MPYF(right,right)
#define INVF2(dst,right) dst=INVF(right)

#define ADDF3(dst,left,right) dst=ADDF(left,right)
#define SUBF3(dst,left,right) dst=SUBF(left,right)
#define MPYF3(dst,left,right) dst=MPYF(left,right)
#define DIVF3(dst,left,right) dst=DIVF(left,right)

#define NEGF1(right) (right)=NEGF(right)
#define ABSF1(right) (right)=ABSF(right)
#define SQRF1(right) (right)=MPYF(right,right)
#define INVF1(right) (right)=INVF(right)

#define ADDF2(left,right) (left)=ADDF(left,right)
#define SUBF2(left,right) (left)=SUBF(left,right)
#define RSBF2(left,right) (left)=SUBF(right,left)
#define MPYF2(left,right) (left)=MPYF(left,right)
#define DIVF2(left,right) (left)=DIVF(left,right)

#define EQLF(left,right) (_eqld(left,right))
#define NEQF(left,right) (_neqd(left,right))
#define LEQF(left,right) (_leqd(left,right))
#define GEQF(left,right) (_geqd(left,right))
#define LSSF(left,right) (_lssd(left,right))
#define GTRF(left,right) (_gtrd(left,right))

#define CMPF(left,right) _cmpd(left,right) /* <0 if LT, 0 if EQ, >0 if GT */
#define CMPF3(dst,left,right) dst=CMPF(left,right)

#define EQZF(left) EQLF(left,ZERO)
#define NEZF(left) NEQF(left,ZERO)
#define LEZF(left) LEQF(left,ZERO)
#define GTZF(left) GTRF(left,ZERO)

#if (1 || defined(Support_INFNAN))
   #define GEZF(left) GEQF(left,ZERO)
   #define LSZF(left) LSSF(left,ZERO)
#else /* there are some uses of GEZF and LSZF that can't do "&left" */
   #if (MSB_In_Hi_Addr)
      #define GEZF(left) (*((int *)(&left)+((BPREAL/BPint)-1)) >= 0)
      #define LSZF(left) (*((int *)(&left)+((BPREAL/BPint)-1)) < 0)
   #else
      #define GEZF(left) (*((int *)(&left)) >= 0)
      #define LSZF(left) (*((int *)(&left)) < 0)
   #endif
#endif

#if 0
/*---------------------------------------------------------------------------*/
/* Compose and Decompose REAL                                                */
/* integer <-> REAL conversion operations                                    */
/* REAL whole number conversions, caller KNOWS whole number fits in int      */
/* Exact Remainder                                                           */
/*---------------------------------------------------------------------------*/
/* Names have form: <operation> F { 1 | 2 | 3 }?                             */
/* Where <operation> is one of:                                              */
/*    SCL  -- f * RADIX**e                                                   */
/*    RIP  -- decompose x into f,e such that x == f*RADIX**e and 1/RADIX<=f<1*/
/*                                                                           */
/*    FIX  -- truncate towards zero and convert to int                       */
/*    FLT  -- convert int  to REAL                                           */
/*    FIXU -- truncate towards zero and convert to unsigned int              */
/*    FLTU -- convert unsigned int  to REAL                                  */
/*                                                                           */
/*    TNC  -- truncate towards 0                (x fits in int)              */
/*    RND  -- round to nearest whole number REAL(x fits in int)              */
/*    FLR  -- truncate towards minus infinity   (x fits in int)              */
/*    CEI  -- truncate towards plus  infinity   (x fits in int)              */
/*                                                                           */
/*    REM  -- *EXACT* remainder (big horrible by-hand divide routine)        */
/*                                                                           */
/* Note that the following whole number approximation rtns exist in math.h:  */
/*    TRUNCF -- truncate towards 0                (x any value)              */
/*    ROUNDF -- round to nearest whole number REAL(x any value)              */
/*    FLOORF -- truncate towards minus infinity   (x any value)              */
/*    CEILF  -- truncate towards plus  infinity   (x any value)              */
/*                                                                           */
/* F means REAL                                                              */
/* If no 1,2 or 3 suffix then is function returning result.                  */
/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */
/*    1 -> right = operation right;                                          */
/*    2 -> dst   = operation right;      ( unary operations)                 */
/*         left  = left operation right; (binary operations)                 */
/*    3 -> dst   = left operation right;                                     */
/*---------------------------------------------------------------------------*/
#endif

#define RIPF(x,f,e) f=FREXPF((x),&e)

#define SCLF(f,e)            LDEXPF((f),(e))
#define SCLF2(f,e)       f = LDEXPF((f),(e))
#define SCLF3(dst,f,e) dst = LDEXPF((f),(e))

#define FIXFC(x) _fixdc(x) /*((char)(x))    */
#define FLTCF(x) _fltcd(x) /*((REAL)(x))    */

#define FIXFB(x) _fixdb(x) /*((unsigned char)(x))*/
#define FLTBF(x) _fltbd(x) /*((REAL)(x))        */

#define FIXFSI(x) _fixdsi(x) /*((short)(x))   */
#define FLTSIF(x) _fltsid(x) /*((REAL)(x))    */

#define FIXFUS(x) _fixdus(x) /*((unsigned short)(x))*/
#define FLTUSF(x) _fltusd(x) /*((REAL)(x))          */

#define FIXFI(x) _fixdi(x) /*((int)(x))     */
#define FLTIF(x) _fltid(x) /*((REAL)(x))    */

#define FIXFU(x) _fixdu(x) /*((unsigned)(x))*/
#define FLTUF(x) _fltud(x) /*((REAL)(x))    */

#define FIXFLI(x) _fixdli(x) /*((long)(x))    */
#define FLTLIF(x) _fltlid(x) /*((REAL)(x))    */

#define FIXFUL(x) _fixdul(x) /*((unsigned long)(x))*/
#define FLTULF(x) _fltuld(x) /*((REAL)(x))         */

#if 0
/* TNCF, RNDF, FLRF, CEIF, may all use FLTIF(FIXFI(f(x))).                */
/* Call sites must be sure to enforce several rules:                      */
/* 1. TRUNCF(f(x)) must not exceed the integer range.                     */
/* 2. if REAL does unbiased round-towards-even,                           */
/*    input x to RNDF must never equal +/- RADIX_to_Mantissa-1.           */
#endif
#ifndef RND_GLITCH
   #error "REAL format .h file must be included before REAL syntax .h file"
#endif
#if (RND_GLITCH)
   #define RND_MAX_P1 RND_P_GLITCH
   #define RND_MIN    RND_M_GLITCH
#else
   #define RND_MAX_P1 INT_MOST_POS_P1
   #define RND_MIN    INT_MOST_NEG
#endif
#ifndef FLT_FIX_Faster_Than_MODF
   #error "target props .h file must be included before REAL syntax .h file"
#endif
#if (FLT_FIX_Faster_Than_MODF)
   #define TNCF(x) (FLTIF(FIXFI(x)))

   #define RNDF(x) (GEZF(x)? \
                    FLTIF(FIXFI((ADDF((x),HALF)))) : \
                    FLTIF(FIXFI((SUBF((x),HALF)))))

   #define FLRF(x) (GEZF(x) ? \
                    (FLTIF(FIXFI(x))) : \
                     (EQLF(x,FLTIF(FIXFI(x))) ? \
                      x : \
                      (FLTIF(NEGF(FIXFI(ADDF(NEGF(x),ONE)))))))

   #define CEIF(x) (LEZF(x) ? \
                    (FLTIF(FIXFI(x))) : \
                     (EQLF(x,FLTIF(FIXFI(x))) ? \
                      x : \
                      (FLTIF(NEGF(FIXFI(SUBF(NEGF(x),ONE)))))))

#else /* call through to general purpose routines */
   #define TNCF(x) (TRUNCF(x))
   #define RNDF(x) (ROUNDF(x))
   #define FLRF(x) (FLOORF(x))
   #define CEIF(x) (CEILF(x))
#endif

#define FIXFI1(x) x=FIXFI(x)
#define FLTIF1(x) x=FLTIF(x)
#define FIXFU1(x) x=FIXFU(x)
#define FLTUF1(x) x=FLTUF(x)

#define TNCF1(x) x=TNCF(x)
#define RNDF1(x) x=RNDF(x)
#define FLRF1(x) x=FLRF(x)
#define CEIF1(x) x=CEIF(x)

#define FIXFI2(dst,right) dst=FIXFI(right)
#define FLTIF2(dst,right) dst=FLTIF(right)
#define FIXFU2(dst,right) dst=FIXFU(right)
#define FLTUF2(dst,right) dst=FLTUF(right)

#define TNCF2(dst,right) dst=TNCF(right)
#define RNDF2(dst,right) dst=RNDF(right)
#define FLRF2(dst,right) dst=FLRF(right)
#define CEIF2(dst,right) dst=CEIF(right)


#define REMF(right,left)           (FMODF(right,left))
#define REMF1(right,left)     right=FMODF(right,left)
#define REMF2(dst,right,left) dst  =FMODF(right,left)


#if 0
/*---------------------------------------------------------------------------*/
/* IEEE software support specific routines                                   */
/*---------------------------------------------------------------------------*/
#endif
#if (BPREAL == BPbigint)
   #define FRCMPYF(l,r) _frcmpyd(l,r)
   #define FRCDIVF(l,r) _frcdivd(l,r)
#elif (BPREAL == (BPbigint*2))
   #define RENORMF(x) renormd(x)
   #define FRCADDF(lx,lf,rx,rf) _frcaddd(lx,lf,rx,rf)
   #define FRCMPYF(p,l,r) _frcmpyd(p,l,r)
   #define FRCDIVF(q,l,r) _frcdivd(q,l,r)
#else
   #error "IEEE lowest-level support routines NYI for this size REAL"
#endif
#ifdef LEAN
   #define GROWF(x) _cvtfd(x) /* grow from LEAN to REAL */
   #define SLIMF(x) _cvtdf(x) /* slim from REAL to LEAN */
#endif

#if 0
/*---------------------------------------------------------------------------*/
/* Polynomial evaluation loops macros.                                       */
/*---------------------------------------------------------------------------*/
/* Loops are used for all polynomials.  It is assumed that this              */
/* is more DSP-friendly given that DSP hardware/software has:                */
/*   . zero-overhead looping,                                                */
/*   . optimizations to software pipeline multiply-accumulate,               */
/*   . the lack of full-precision floating-immediate address mode,           */
/*   . relatively expensive fetch of non-tabular constants,                  */
/*   . the existance of auto-increment addressing for table access.          */
/*---------------------------------------------------------------------------*/

/* form of: r=(((K[0]*x + K[1])*x + K[2])*x); r not same as x */
#endif
#define POLYF(r,x,K,s) {int i; REAL *p=K;                             \
                        MPYF3(r,x,*p++);                              \
                        for (i=s-1; i>0; i--) MPYF3(r,x,ADDF(r,*p++));}

#if 0
/* extra add at the end */
/* form of: r=(((K[0]*x + K[1])*x + K[2])*x) + K[3];  r not same as x */
#endif
#define POLYaF(r,x,K,s) {int i; REAL *p=K;                             \
                         MPYF3(r,x,*p++);                              \
                         for (i=s-2; i>0; i--) MPYF3(r,x,ADDF(r,*p++));\
                         ADDF2(r,*p++);}

#if 0
/* form of: r=((x+K[0])*x + K[1])*x + K[2]) * x) + K[3]; r not same as x */
#endif
#define POLYbF(r,x,K,s) {int i; REAL *p=K;                             \
                         ADDF3(r,x,*p++);                              \
                         for (i=s-1; i>0; i--) ADDF3(r,*p++,MPYF(x,r));}

#if 0
/*---------------------------------------------------------------------------*/
/* Bind The Names Of The Math Library Routines                               */
/*---------------------------------------------------------------------------*/
#endif
#define SQRTF(x)    sqrt(x)
#define RSQRTF(x)   rsqrt(x)
#define EXPF(x)     exp(x)
#define EXP2F(x)    exp2(x)
#define EXP10F(x)   exp10(x)
#define LOGF(x)     log(x)
#define LOG2F(x)    log2(x)
#define LOG10F(x)   log10(x)
#define POWF(x,y)   pow(x,y)
#define POWIF(x,i)  powi(x,i)
#define SINF(x)     sin(x)
#define COSF(x)     cos(x)
#define TANF(x)     tan(x)
#define COTF(x)     cot(x)
#define ASINF(x)    asin(x)
#define ACOSF(x)    acos(x)
#define ATANF(x)    atan(x)
#define ATAN2F(y,x) atan2(y,x)
#define ACOTF(x)    acot(x)
#define ACOT2F(x,y) acot2(x,y)
#define SINHF(x)    sinh(x)
#define COSHF(x)    cosh(x)
#define TANHF(x)    tanh(x)
#define COTHF(x)    coth(x)
#define ASINHF(x)   asinh(x)
#define ACOSHF(x)   acosh(x)
#define ATANHF(x)   atanh(x)
#define ACOTHF(x)   acoth(x)

#define CEILF(x)    ceil(x)
#define FLOORF(x)   floor(x)
#define TRUNCF(x)   _trunc(x)
#define ROUNDF(x)   _round(x)

#define FABSF(x)    fabs(x)

#define LDEXPF(x,n)   ldexp(x,n)
#define FREXPF(x,exp) frexp(x,exp)
#define MODFF(x,ip)   modf(x,ip)
#define FMODF(x,y)    fmod(x,y)

#endif /*__syntd__*/

syntf.h/        868562442   0     0     0       15365     `
/****************************************************************************/
/*  syntf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:07 EDT 1997 */

#ifndef __syntf__
#define __syntf__

#if 0
/*---------------------------------------------------------------------------*/
/* Bind abstract REAL to "float" syntax, and use mathf.h routine names.      */
/* Use built-in operators for unary -, +,-,*,/, >,<,>=,<=,==,!=, =           */
/* Use ANSI names for float version of math.h routines (sqrtf, sinf, ... etc)*/
/*---------------------------------------------------------------------------*/
#endif

#define REAL float
#define EXPONENT_TYPE int

#if BPLEAN == 0
   #undef LEAN /* no next-smaller REAL */
#else
   #define LEAN float16 /* assume its a size 16-bit IEEE-like float */
#endif

#define CNST(x) (x##f)/* constants within statements */
#define TSNC
#define KNST(x) x##f  /* constants within tables     */
#define TSNK

#include "numconst.h" /* NUMerical CONSTants used by some definitions below */

#if 0
/*---------------------------------------------------------------------------*/
/* Define Compiler Syntax For Basic Operations                               */
/*---------------------------------------------------------------------------*/
/* Names have form: <operation> F { 1 | 2 | 3 }?                             */
/* Where <operation> is one of:                                              */
/*    CPY  -- simple assignment                                              */
/*    NEG  -- negative                                                       */
/*    ABS  -- absolute value                                                 */
/*    SQR  -- square                                                         */
/*    INV  -- inverse (1/x)                                                  */
/*    ADD  -- plus                                                           */
/*    SUB  -- subtract                                                       */
/*    MPY  -- multiply                                                       */
/*    DIV  -- division                                                       */
/*    EQL  -- ==                                                             */
/*    NEQ  -- !=                                                             */
/*    GTR  -- >                                                              */
/*    GEQ  -- >=                                                             */
/*    LSS  -- <                                                              */
/*    LEQ  -- <=                                                             */
/*    EQZ  -- == 0.0                                                         */
/*    NEZ  -- != 0.0                                                         */
/*    GTZ  -- >  0.0                                                         */
/*    GEZ  -- >= 0.0                                                         */
/*    LSZ  -- <  0.0                                                         */
/*    LEZ  -- <= 0.0                                                         */
/* F means REAL, G means BIGGER_REAL                             */
/* If no 1,2 or 3 suffix then is function returning result.                  */
/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */
/*    1 -> right = operation right;                                          */
/*    2 -> dst   = operation right;      ( unary operations)                 */
/*         left  = left operation right; (binary operations)                 */
/*    3 -> dst   = left operation right;                                     */
/*---------------------------------------------------------------------------*/
#endif

#define CPYF(dst,right) dst=(right)

#define NEGF(right) (-(right))
#define ABSF(right) (LSSF(right,ZERO) ? NEGF(right) : (right))
#define SQRF(right) MPYF(right,right)
#define INVF(right) DIVF(ONE,right)

#define ADDF(left,right) ((left)+(right))
#define SUBF(left,right) ((left)-(right))
#define MPYF(left,right) ((left)*(right))
#define DIVF(left,right) ((left)/(right))

#define NEGF2(dst,right) dst=(-(right))
#define ABSF2(dst,right) dst=(LSSF(right,ZERO)?NEGF(right):(right))
#define SQRF2(dst,right) dst=(right)*(right)
#define INVF2(dst,right) dst=INVF(right)

#define ADDF3(dst,left,right) dst=(left)+(right)
#define SUBF3(dst,left,right) dst=(left)-(right)
#define MPYF3(dst,left,right) dst=(left)*(right)
#define DIVF3(dst,left,right) dst=(left)/(right)

#define NEGF1(right) (right)=-(right)
#define ABSF1(right) if LSSF(right,ZERO) NEGF1(right)
#define SQRF1(right) (right)*=(right)
#define INVF1(right) (right)=INVF(right)

#define ADDF2(left,right) (left)+=(right)
#define SUBF2(left,right) (left)-=(right)
#define RSBF2(left,right) (left) =(right)-(left)
#define MPYF2(left,right) (left)*=(right)
#define DIVF2(left,right) (left)/=(right)

#define CMPF(left,right) ((left)<(right)?-1:((left)!=(right)))
#define CMPF3(dst,left,right) dst=CMPF(left,right)

#define EQLF(left,right) ((left)==(right))
#define NEQF(left,right) ((left)!=(right))
#define LEQF(left,right) ((left)<=(right))
#define GEQF(left,right) ((left)>=(right))
#define GTRF(left,right) ((left)>(right))
#define LSSF(left,right) ((left)<(right))

#define EQZF(left) EQLF(left,ZERO)
#define NEZF(left) NEQF(left,ZERO)
#define LEZF(left) LEQF(left,ZERO)
#define GEZF(left) GEQF(left,ZERO)
#define GTZF(left) GTRF(left,ZERO)
#define LSZF(left) LSSF(left,ZERO)



#if 0
/*---------------------------------------------------------------------------*/
/* Compose and Decompose REAL                                                */
/* integer <-> REAL conversion operations                                    */
/* REAL whole number conversions, caller KNOWS whole number fits in int      */
/* Exact Remainder                                                           */
/*---------------------------------------------------------------------------*/
/* Names have form: <operation> F { 1 | 2 | 3 }?                             */
/* Where <operation> is one of:                                              */
/*    SCL  -- f * RADIX**e                                                   */
/*    RIP  -- decompose x into f,e such that x == f*RADIX**e and 1/RADIX<=f<1*/
/*                                                                           */
/*    FIX  -- truncate towards zero and convert to int                       */
/*    FLT  -- convert int  to REAL                                           */
/*    FIXU -- truncate towards zero and convert to unsigned int              */
/*    FLTU -- convert unsigned int  to REAL                                  */
/*                                                                           */
/*    TNC  -- truncate towards 0                (x fits in int)              */
/*    RND  -- round to nearest whole number REAL(x fits in int)              */
/*    FLR  -- truncate towards minus infinity   (x fits in int)              */
/*    CEI  -- truncate towards plus  infinity   (x fits in int)              */
/*                                                                           */
/*    REM  -- *EXACT* remainder (big horrible by-hand divide routine)        */
/*                                                                           */
/* Note that the following whole number approximation rtns exist in math.h:  */
/*    TRUNCF -- truncate towards 0                (x any value)              */
/*    ROUNDF -- round to nearest whole number REAL(x any value)              */
/*    FLOORF -- truncate towards minus infinity   (x any value)              */
/*    CEILF  -- truncate towards plus  infinity   (x any value)              */
/*                                                                           */
/* F means REAL                                                              */
/* If no 1,2 or 3 suffix then is function returning result.                  */
/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */
/*    1 -> right = operation right;                                          */
/*    2 -> dst   = operation right;      ( unary operations)                 */
/*         left  = left operation right; (binary operations)                 */
/*    3 -> dst   = left operation right;                                     */
/*---------------------------------------------------------------------------*/
#endif

#define RIPF(x,f,e) f=FREXPF((x),&e)

#define SCLF(f,e)            LDEXPF((f),(e))
#define SCLF2(f,e)       f = LDEXPF((f),(e))
#define SCLF3(dst,f,e) dst = LDEXPF((f),(e))

#define FIXFC(x) ((char)(x))
#define FLTCF(x) ((REAL)(x))

#define FIXFB(x) ((unsigned char)(x))
#define FLTBF(x) ((REAL)(x))

#define FIXFSI(x) ((short)(x))
#define FLTSIF(x) ((REAL)(x)) 

#define FIXFUS(x) ((unsigned short)(x))
#define FLTUSF(x) ((REAL)(x))

#define FIXFI(x) ((int)(x))
#define FLTIF(x) ((REAL)(x))

#define FIXFU(x) ((unsigned)(x))
#define FLTUF(x) ((REAL)(x))

#define FIXFLI(x) ((long)(x))
#define FLTLIF(x) ((REAL)(x))

#define FIXFUL(x) ((unsigned long)(x))
#define FLTULF(x) ((REAL)(x))

#if 0
/* TNCF, RNDF, FLRF, CEIF, may all use FLTIF(FIXFI(f(x))).                  */
/* Call sites must be sure to enforce several rules:                      */
/* 1. TRUNCF(f(x)) must not exceed the integer range.                     */
/* 2. if REAL does unbiased round-towards-even,                           */
/*    input x to RNDF must never equal +/- RADIX_to_Mantissa-1.           */
#endif
#ifndef RND_GLITCH
   #error "REAL format .h file must be included before REAL syntax .h file"
#endif
#if (RND_GLITCH)
   #define RND_MAX_P1 RND_P_GLITCH
   #define RND_MIN    RND_M_GLITCH
#else
   #define RND_MAX_P1 INT_MOST_POS_P1
   #define RND_MIN    INT_MOST_NEG
#endif
#ifndef FLT_FIX_Faster_Than_MODF
   #error "target props .h file must be included before REAL syntax .h file"
#endif
#if (FLT_FIX_Faster_Than_MODF)
   #define TNCF(x) (FLTIF(FIXFI(x)))

   #define RNDF(x) (GEZF(x)? \
                    FLTIF(FIXFI((ADDF((x),HALF)))) : \
                    FLTIF(FIXFI((SUBF((x),HALF)))))

   #define FLRF(x) (GEZF(x) ? \
                    (FLTIF(FIXFI(x))) : \
                     (EQLF(x,FLTIF(FIXFI(x))) ? \
                      x : \
                      (FLTIF(NEGF(FIXFI(ADDF(NEGF(x),ONE)))))))

   #define CEIF(x) (LEZF(x) ? \
                    (FLTIF(FIXFI(x))) : \
                     (EQLF(x,FLTIF(FIXFI(x))) ? \
                      x : \
                      (FLTIF(NEGF(FIXFI(SUBF(NEGF(x),ONE)))))))

#else /* call through to general purpose routines */
   #define TNCF(x) (TRUNCF(x))
   #define RNDF(x) (ROUNDF(x))
   #define FLRF(x) (FLOORF(x))
   #define CEIF(x) (CEILF(x))
#endif

#define FIXFI1(x) x=FIXFI(x)
#define FLTIF1(x) x=FLTIF(x)
#define FIXFU1(x) x=FIXFU(x)
#define FLTUF1(x) x=FLTUF(x)

#define TNCF1(x) x=TNCF(x)
#define RNDF1(x) x=RNDF(x)
#define FLRF1(x) x=FLRF(x)
#define CEIF1(x) x=CEIF(x)

#define FIXFI2(dst,right) dst=FIXFI(right)
#define FLTIF2(dst,right) dst=FLTIF(right)
#define FIXFU2(dst,right) dst=FIXFU(right)
#define FLTUF2(dst,right) dst=FLTUF(right)

#define TNCF2(dst,right) dst=TNCF(right)
#define RNDF2(dst,right) dst=RNDF(right)
#define FLRF2(dst,right) dst=FLRF(right)
#define CEIF2(dst,right) dst=CEIF(right)


#define REMF(right,left)           (FMODF(right,left))
#define REMF1(right,left)     right=FMODF(right,left)
#define REMF2(dst,right,left) dst  =FMODF(right,left)


#if 0
/*---------------------------------------------------------------------------*/
/* IEEE software support specific routines                                   */
/*---------------------------------------------------------------------------*/
#endif
#ifdef LEAN
   #define GROWF(x) ((REAL)(x)) /* grow from LEAN to REAL */
   #define SLIMF(x) ((LEAN)(x)) /* slim from REAL to LEAN */
#endif


#if 0
/*---------------------------------------------------------------------------*/
/* Polynomial evaluation loops macros.                                       */
/*---------------------------------------------------------------------------*/
/* Loops are used for all polynomials.  It is assumed that this              */
/* is more DSP-friendly given that DSP hardware/software has:                */
/*   . zero-overhead looping,                                                */
/*   . optimizations to software pipeline multiply-accumulate,               */
/*   . the lack of full-precision floating-immediate address mode,           */
/*   . relatively expensive fetch of non-tabular constants,                  */
/*   . the existance of auto-increment addressing for table access.          */
/*---------------------------------------------------------------------------*/

/* form of: r=(((K[0]*x + K[1])*x + K[2])*x); r not same as x */
#endif
#define POLYF(r,x,K,s) {int i; REAL *p=K;                             \
                        MPYF3(r,x,*p++);                              \
                        for (i=s-1; i>0; i--) MPYF3(r,x,ADDF(r,*p++));}

#if 0
/* extra add at the end */
/* form of: r=(((K[0]*x + K[1])*x + K[2])*x) + K[3];  r not same as x */
#endif
#define POLYaF(r,x,K,s) {int i; REAL *p=K;                             \
                         MPYF3(r,x,*p++);                              \
                         for (i=s-2; i>0; i--) MPYF3(r,x,ADDF(r,*p++));\
                         ADDF2(r,*p++);}

#if 0
/* form of: r=((x+K[0])*x + K[1])*x + K[2]) * x) + K[3]; r not same as x */
#endif
#define POLYbF(r,x,K,s) {int i; REAL *p=K;                             \
                         ADDF3(r,x,*p++);                              \
                         for (i=s-1; i>0; i--) ADDF3(r,*p++,MPYF(x,r));}

#if 0
/*---------------------------------------------------------------------------*/
/* Bind The Names Of The Math Library Routines                               */
/*---------------------------------------------------------------------------*/
#endif
#define SQRTF(x)    sqrtf(x)
#define RSQRTF(x)   rsqrtf(x)
#define EXPF(x)     expf(x)
#define EXP2F(x)    exp2f(x)
#define EXP10F(x)   exp10f(x)
#define LOGF(x)     logf(x)
#define LOG2F(x)    log2f(x)
#define LOG10F(x)   log10f(x)
#define POWF(x,y)   powf(x,y)
#define POWIF(x,i)  powif(x,i)
#define SINF(x)     sinf(x)
#define COSF(x)     cosf(x)
#define TANF(x)     tanf(x)
#define COTF(x)     cotf(x)
#define ASINF(x)    asinf(x)
#define ACOSF(x)    acosf(x)
#define ATANF(x)    atanf(x)
#define ATAN2F(y,x) atan2f(y,x)
#define ACOTF(x)    acotf(x)
#define ACOT2F(x,y) acot2f(x,y)
#define SINHF(x)    sinhf(x)
#define COSHF(x)    coshf(x)
#define TANHF(x)    tanhf(x)
#define COTHF(x)    cothf(x)
#define ASINHF(x)   asinhf(x)
#define ACOSHF(x)   acoshf(x)
#define ATANHF(x)   atanhf(x)
#define ACOTHF(x)   acothf(x)

#define CEILF(x)    ceilf(x)
#define FLOORF(x)   floorf(x)
#define TRUNCF(x)   _truncf(x)
#define ROUNDF(x)   _roundf(x)

#define FABSF(x)    fabsf(x)

#define LDEXPF(x,n)   ldexpf(x,n)
#define FREXPF(x,exp) frexpf(x,exp)
#define MODFF(x,ip)   modff(x,ip)
#define FMODF(x,y)    fmodf(x,y)

#endif /*__syntf__*/

syntfi.h/       868562444   0     0     0       16366     `
/****************************************************************************/
/*  syntfi  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:01 EDT 1997 */

#ifndef __syntf__
#define __syntf__

#if 0
/*---------------------------------------------------------------------------*/
/* Bind abstract REAL to "float" syntax.                                     */
/* Use ANSI-style function calls for IEEE +,-,*,/, >,<,>=,<=,==,!=, =        */
/* Use ANSI names for float version of math.h routines (sqrtf, sinf, ... etc)*/
/*---------------------------------------------------------------------------*/
#endif

#define REAL float
#define EXPONENT_TYPE int

#if BPLEAN == 0
   #undef LEAN /* no next-smaller REAL */
#else
   #define LEAN float16 /* assume its a size 16-bit IEEE-like float */
#endif

#define CNST(x) (x##f)/* constants within statements */
#define TSNC
#define KNST(x) x##f  /* constants within tables     */
#define TSNK

#include "numconst.h" /* NUMerical CONSTants used by some definitions below */

#if 0
/*---------------------------------------------------------------------------*/
/* Define Compiler Syntax For Basic Operations                               */
/*---------------------------------------------------------------------------*/
/* Names have form: <operation> { F | G } { 1 | 2 | 3 }?                     */
/* Where <operation> is one of:                                              */
/*    CPY  -- simple assignment
/*    NEG  -- negative                                                       */
/*    ABS  -- absolute value                                                 */
/*    SQR  -- square                                                         */
/*    INV  -- inverse (1/x)                                                  */
/*    ADD  -- plus                                                           */
/*    SUB  -- subtract                                                       */
/*    MPY  -- multiply                                                       */
/*    DIV  -- division                                                       */
/*    EQL  -- ==                                                             */
/*    NEQ  -- !=                                                             */
/*    GTR  -- >                                                              */
/*    GEQ  -- >=                                                             */
/*    LSS  -- <                                                              */
/*    LEQ  -- <=                                                             */
/*    EQZ  -- == 0.0                                                         */
/*    NEZ  -- != 0.0                                                         */
/*    GTZ  -- >  0.0                                                         */
/*    GEZ  -- >= 0.0                                                         */
/*    LSZ  -- <  0.0                                                         */
/*    LEZ  -- <= 0.0                                                         */
/* F means REAL, G means BIGGER_REAL                                         */
/* If no 1,2 or 3 suffix then is function returning result.                  */
/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */
/*    1 -> right = operation right;                                          */
/*    2 -> dst   = operation right;      ( unary operations)                 */
/*         left  = left operation right; (binary operations)                 */
/*    3 -> dst   = left operation right;                                     */
/*---------------------------------------------------------------------------*/
#endif

#define CPYF(dst,right) dst=(right)

#define NEGF(right) _negf(right)
#define ABSF(right) _absf(right)
#define SQRF(right) MPYF(right,right)
#define INVF(right) DIVF(ONE,right)

#define ADDF(left,right) _addf(left,right)
#define SUBF(left,right) _subf(left,right)
#define MPYF(left,right) _mpyf(left,right)
#define DIVF(left,right) _divf(left,right)

#define NEGF2(dst,right) dst=NEGF(right)
#define ABSF2(dst,right) dst=ABSF(right)
#define SQRF2(dst,right) dst=MPYF(right,right)
#define INVF2(dst,right) dst=INVF(right)

#define ADDF3(dst,left,right) dst=ADDF(left,right)
#define SUBF3(dst,left,right) dst=SUBF(left,right)
#define MPYF3(dst,left,right) dst=MPYF(left,right)
#define DIVF3(dst,left,right) dst=DIVF(left,right)

#define NEGF1(right) (right)=NEGF(right)
#define ABSF1(right) (right)=ABSF(right)
#define SQRF1(right) (right)=MPYF(right,right)
#define INVF1(right) (right)=INVF(right)

#define ADDF2(left,right) (left)=ADDF(left,right)
#define SUBF2(left,right) (left)=SUBF(left,right)
#define RSBF2(left,right) (left)=SUBF(right,left)
#define MPYF2(left,right) (left)=MPYF(left,right)
#define DIVF2(left,right) (left)=DIVF(left,right)

#define EQLF(left,right) (_eqlf(left,right))
#define NEQF(left,right) (_neqf(left,right))
#define LEQF(left,right) (_leqf(left,right))
#define GEQF(left,right) (_geqf(left,right))
#define LSSF(left,right) (_lssf(left,right))
#define GTRF(left,right) (_gtrf(left,right))

#define CMPF(left,right) _cmpf(left,right) /* <0 if LT, 0 if EQ, >0 if GT */
#define CMPF3(dst,left,right) dst=CMPF(left,right)

#define EQZF(left) EQLF(left,ZERO)
#define NEZF(left) NEQF(left,ZERO)
#define LEZF(left) LEQF(left,ZERO)
#define GTZF(left) GTRF(left,ZERO)

#if (1 || defined(Support_INFNAN))
   #define GEZF(left) GEQF(left,ZERO)
   #define LSZF(left) LSSF(left,ZERO)
#else /* there are some uses of GEZF and LSZF that can't do "&left" */
   #if (MSB_In_Hi_Addr)
      #define GEZF(left) (*((int *)(&left)+((BPREAL/BPint)-1)) >= 0)
      #define LSZF(left) (*((int *)(&left)+((BPREAL/BPint)-1)) < 0)
   #else
      #define GEZF(left) (*((int *)(&left)) >= 0)
      #define LSZF(left) (*((int *)(&left)) < 0)
   #endif
#endif


#if 0
/*---------------------------------------------------------------------------*/
/* Compose and Decompose REAL                                                */
/* integer <-> REAL conversion operations                                    */
/* REAL whole number conversions, caller KNOWS whole number fits in int      */
/* Exact Remainder                                                           */
/*---------------------------------------------------------------------------*/
/* Names have form: <operation> { F | G } { 1 | 2 | 3 }?                     */
/* Where <operation> is one of:                                              */
/*    SCL  -- f * RADIX**e                                                   */
/*    RIP  -- decompose x into f,e such that x == f*RADIX**e and 1/RADIX<=f<1*/
/*                                                                           */
/*    FIX  -- truncate towards zero and convert to int                       */
/*    FLT  -- convert int  to REAL                                           */
/*    FIXU -- truncate towards zero and convert to unsigned int              */
/*    FLTU -- convert unsigned int  to REAL                                  */
/*                                                                           */
/*    TNC  -- truncate towards 0                (x fits in int)              */
/*    RND  -- round to nearest whole number REAL(x fits in int)              */
/*    FLR  -- truncate towards minus infinity   (x fits in int)              */
/*    CEI  -- truncate towards plus  infinity   (x fits in int)              */
/*                                                                           */
/*    REM  -- *EXACT* remainder (big horrible by-hand divide routine)        */
/*                                                                           */
/* Note that the following whole number approximation rtns exist in math.h:  */
/*    TRUNCF -- truncate towards 0                (x any value)              */
/*    ROUNDF -- round to nearest whole number REAL(x any value)              */
/*    FLOORF -- truncate towards minus infinity   (x any value)              */
/*    CEILF  -- truncate towards plus  infinity   (x any value)              */
/*                                                                           */
/* F means REAL, G means BIGGER_REAL                                         */
/* If no 1,2 or 3 suffix then is function returning result.                  */
/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */
/*    1 -> right = operation right;                                          */
/*    2 -> dst   = operation right;      ( unary operations)                 */
/*         left  = left operation right; (binary operations)                 */
/*    3 -> dst   = left operation right;                                     */
/*---------------------------------------------------------------------------*/
#endif

#define RIPF(x,f,e) f=FREXPF((x),&e)

#define SCLF(f,e)            LDEXPF((f),(e))
#define SCLF2(f,e)       f = LDEXPF((f),(e))
#define SCLF3(dst,f,e) dst = LDEXPF((f),(e))
 
#define FIXFC(x) _fixfc(x) /*((char)(x))    */
#define FLTCF(x) _fltcf(x) /*((REAL)(x))    */

#define FIXFB(x) _fixfb(x) /*((unsigned char)(x))*/
#define FLTBF(x) _fltbf(x) /*((REAL)(x))        */

#define FIXFSI(x) _fixfsi(x) /*((short)(x))   */
#define FLTSIF(x) _fltsif(x) /*((REAL)(x))    */

#define FIXFUS(x) _fixfus(x) /*((unsigned short)(x))*/
#define FLTUSF(x) _fltusf(x) /*((REAL)(x))          */

#define FIXFI(x) _fixfi(x) /*((int)(x))     */
#define FLTIF(x) _fltif(x) /*((REAL)(x))    */

#define FIXFU(x) _fixfu(x) /*((unsigned)(x))*/
#define FLTUF(x) _fltuf(x) /*((REAL)(x))    */

#define FIXFLI(x) _fixfli(x) /*((long)(x))    */
#define FLTLIF(x) _fltlif(x) /*((REAL)(x))    */

#define FIXFUL(x) _fixful(x) /*((unsigned long)(x))*/
#define FLTULF(x) _fltulf(x) /*((REAL)(x))         */


#if 0
/* TNCF, RNDF, FLRF, CEIF, may all use FLTIF(FIXFI(f(x))).                  */
/* Call sites must be sure to enforce several rules:                      */
/* 1. TRUNCF(f(x)) must not exceed the integer range.                     */
/* 2. if REAL does unbiased round-towards-even,                           */
/*    input x to RNDF must never equal +/- RADIX_to_Mantissa-1.           */
#endif
#ifndef RND_GLITCH
   #error "REAL format .h file must be included before REAL syntax .h file"
#endif
#if (RND_GLITCH)
   #define RND_MAX_P1 RND_P_GLITCH
   #define RND_MIN    RND_M_GLITCH
#else
   #define RND_MAX_P1 INT_MOST_POS_P1
   #define RND_MIN    INT_MOST_NEG
#endif
#ifndef FLT_FIX_Faster_Than_MODF
   #error "target props .h file must be included before REAL syntax .h file"
#endif
#if (FLT_FIX_Faster_Than_MODF)
   #define TNCF(x) (FLTIF(FIXFI(x)))

   #define RNDF(x) (GEZF(x)? \
                    FLTIF(FIXFI((ADDF((x),HALF)))) : \
                    FLTIF(FIXFI((SUBF((x),HALF)))))

   #define FLRF(x) (GEZF(x) ? \
                    (FLTIF(FIXFI(x))) : \
                     (EQLF(x,FLTIF(FIXFI(x))) ? \
                      x : \
                      (FLTIF(NEGF(FIXFI(ADDF(NEGF(x),ONE)))))))

   #define CEIF(x) (LEZF(x) ? \
                    (FLTIF(FIXFI(x))) : \
                     (EQLF(x,FLTIF(FIXFI(x))) ? \
                      x : \
                      (FLTIF(NEGF(FIXFI(SUBF(NEGF(x),ONE)))))))

#else /* call through to general purpose routines */
   #define TNCF(x) (TRUNCF(x))
   #define RNDF(x) (ROUNDF(x))
   #define FLRF(x) (FLOORF(x))
   #define CEIF(x) (CEILF(x))
#endif

#define FIXFI1(x) x=FIXFI(x)
#define FLTIF1(x) x=FLTIF(x)
#define FIXFU1(x) x=FIXFU(x)
#define FLTUF1(x) x=FLTUF(x)

#define TNCF1(x) x=TNCF(x)
#define RNDF1(x) x=RNDF(x)
#define FLRF1(x) x=FLRF(x)
#define CEIF1(x) x=CEIF(x)

#define FIXFI2(dst,right) dst=FIXFI(right)
#define FLTIF2(dst,right) dst=FLTIF(right)
#define FIXFU2(dst,right) dst=FIXFU(right)
#define FLTUF2(dst,right) dst=FLTUF(right)

#define TNCF2(dst,right) dst=TNCF(right)
#define RNDF2(dst,right) dst=RNDF(right)
#define FLRF2(dst,right) dst=FLRF(right)
#define CEIF2(dst,right) dst=CEIF(right)


#define REMF(right,left)           (FMODF(right,left))
#define REMF1(right,left)     right=FMODF(right,left)
#define REMF2(dst,right,left) dst  =FMODF(right,left)


#if 0
/*---------------------------------------------------------------------------*/
/* IEEE software support specific routines                                   */
/*---------------------------------------------------------------------------*/
#endif
#if (BPREAL == BPbigint)
   #define FRCMPYF(l,r) _frcmpyf(l,r)
   #define FRCDIVF(l,r) _frcdivf(l,r)
#elif (BPREAL == (BPbigint*2))
   #define RENORMF(x) _renormf(x)
   #define FRCADDF(lx,lf,rx,rf) _frcaddf(lx,lf,rx,rf)
   #define FRCMPYF(p,l,r) _frcmpyf(p,l,r)
   #define FRCDIVF(q,l,r) _frcdivf(q,l,r)
#else
   #error "IEEE lowest-level support routines NYI for this size REAL"
#endif
#ifdef LEAN
   #error "GROWF/SLIMF not yet defined for this size LEAN"
#endif

#if 0
/*---------------------------------------------------------------------------*/
/* Polynomial evaluation loops macros.                                       */
/*---------------------------------------------------------------------------*/
/* Loops are used for all polynomials.  It is assumed that this              */
/* is more DSP-friendly given that DSP hardware/software has:                */
/*   . zero-overhead looping,                                                */
/*   . optimizations to software pipeline multiply-accumulate,               */
/*   . the lack of full-precision floating-immediate address mode,           */
/*   . relatively expensive fetch of non-tabular constants,                  */
/*   . the existance of auto-increment addressing for table access.          */
/*---------------------------------------------------------------------------*/

/* form of: r=(((K[0]*x + K[1])*x + K[2])*x); r not same as x */
#endif
#define POLYF(r,x,K,s) {int i; REAL *p=K;                             \
                        MPYF3(r,x,*p++);                              \
                        for (i=s-1; i>0; i--) MPYF3(r,x,ADDF(r,*p++));}

#if 0
/* extra add at the end */
/* form of: r=(((K[0]*x + K[1])*x + K[2])*x) + K[3];  r not same as x */
#endif
#define POLYaF(r,x,K,s) {int i; REAL *p=K;                             \
                         MPYF3(r,x,*p++);                              \
                         for (i=s-2; i>0; i--) MPYF3(r,x,ADDF(r,*p++));\
                         ADDF2(r,*p++);}

#if 0
/* form of: r=((x+K[0])*x + K[1])*x + K[2]) * x) + K[3]; r not same as x */
#endif
#define POLYbF(r,x,K,s) {int i; REAL *p=K;                             \
                         ADDF3(r,x,*p++);                              \
                         for (i=s-1; i>0; i--) ADDF3(r,*p++,MPYF(x,r));}

#if 0
/*---------------------------------------------------------------------------*/
/* Bind The Names Of The Math Library Routines                               */
/*---------------------------------------------------------------------------*/
#endif
#define SQRTF(x)    sqrtf(x)
#define RSQRTF(x)   rsqrtf(x)
#define EXPF(x)     expf(x)
#define EXP2F(x)    exp2f(x)
#define EXP10F(x)   exp10f(x)
#define LOGF(x)     logf(x)
#define LOG2F(x)    log2f(x)
#define LOG10F(x)   log10f(x)
#define POWF(x,y)   powf(x,y)
#define POWIF(x,i)  powif(x,i)
#define SINF(x)     sinf(x)
#define COSF(x)     cosf(x)
#define TANF(x)     tanf(x)
#define COTF(x)     cotf(x)
#define ASINF(x)    asinf(x)
#define ACOSF(x)    acosf(x)
#define ATANF(x)    atanf(x)
#define ATAN2F(y,x) atan2f(y,x)
#define ACOTF(x)    acotf(x)
#define ACOT2F(x,y) acot2f(x,y)
#define SINHF(x)    sinhf(x)
#define COSHF(x)    coshf(x)
#define TANHF(x)    tanhf(x)
#define COTHF(x)    cothf(x)
#define ASINHF(x)   asinhf(x)
#define ACOSHF(x)   acoshf(x)
#define ATANHF(x)   atanhf(x)
#define ACOTHF(x)   acothf(x)

#define CEILF(x)    ceilf(x)
#define FLOORF(x)   floorf(x)
#define TRUNCF(x)   _truncf(x)
#define ROUNDF(x)   _roundf(x)

#define FABSF(x)    fabsf(x)

#define LDEXPF(x,n)   ldexpf(x,n)
#define FREXPF(x,exp) frexpf(x,exp)
#define MODFF(x,ip)   modff(x,ip)
#define FMODF(x,y)    fmodf(x,y)

#endif /*__syntf__*/
time.h/         868562444   0     0     0       2961      `
/*****************************************************************************/
/* time.h     v1.10#                                                         */
/* Copyright (c) 1993-1977 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _TIME
#define _TIME

#define CLOCKS_PER_SEC 200000000 /* 200 MHz */
#ifndef NULL
#define NULL      0
#endif

#if defined(_TMS320C6X)
typedef unsigned int clock_t;
typedef unsigned int time_t;
#else
typedef unsigned long clock_t;
typedef unsigned long time_t;
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

struct tm {
	    unsigned int tm_sec;      /* seconds after the minute   - [0,59]  */
	    int          tm_min;      /* minutes after the hour     - [0,59]  */
	    int          tm_hour;     /* hours after the midnight   - [0,23]  */
	    int          tm_mday;     /* day of the month           - [1,31]  */
	    int          tm_mon;      /* months since January       - [0,11]  */
	    int          tm_year;     /* years since 1900                     */
	    int          tm_wday;     /* days since Sunday          - [0,6]   */
	    int          tm_yday;     /* days since Jan 1st         - [0,365] */
	    int          tm_isdst;    /* Daylight Savings Time flag           */
	  };

/*************************************************************************/
/* TIME ZONE STRUCTURE DEFINITION                                        */
/*************************************************************************/
typedef struct {
                 short   daylight;
		 time_t  timezone;
		 char    tzname[4];
		 char    dstname[4];
               } TZ;
extern TZ _tz;

#ifdef _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

/****************************************************************************/
/* FUNCTION DECLARATIONS.  (NOTE : clock AND time ARE SYSTEM SPECIFIC)      */
/****************************************************************************/
         clock_t    clock(void);             
         time_t     time(time_t *_timer);   

         time_t     mktime(struct tm *_tptr);
         double     difftime(time_t _time1, time_t _time0);
__INLINE char      *ctime(const time_t *_timer);
         char      *asctime(const struct tm *_timeptr);
         struct tm *gmtime(const time_t *_timer);
         struct tm *localtime(const time_t *_timer);
         size_t     strftime(char *_out, size_t _maxsize, const char *_format,
                             const struct tm *_timeptr);

#ifdef _INLINE

/****************************************************************************/
/*  ctime                                                                   */
/****************************************************************************/
static inline char *ctime(const time_t *timer)
{
   return(asctime(localtime(timer)));
}

#endif
#undef __INLINE

#endif


trgcio.h/       868562444   0     0     0       9870      `
/*****************************************************************************/
/*  TRGCIO.H v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*  This file contains OTIS-driven CIO constant definitions                  */
/*****************************************************************************/

/*---------------------------------------------------------------------------*/
/* constants for the data transfer functions for the predefined driver       */
/*---------------------------------------------------------------------------*/
#define _DTOPEN    (0xF0)
#define _DTCLOSE   (0xF1)
#define _DTREAD    (0xF2)
#define _DTWRITE   (0xF3)
#define _DTLSEEK   (0xF4)
#define _DTUNLINK  (0xF5)
#define _DTGETENV  (0xF6)
#define _DTRENAME  (0xF7)
#define _DTGETTIME (0xF8)
#define _DTGETCLK  (0xF9)
#define _DTSYNC    (0xFF)

#define CIOBUFSIZ BUFSIZ+32

#if defined(_TMS320C25) || defined(_TMS320C50) || defined(_TMS320C5XX) || defined(_TMS320C2XX)
/*---------------------------------------------------------------------------*/
/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */
/*                                                                           */
/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */
/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */
/*---------------------------------------------------------------------------*/
#define LOADSHORT(x,y,z)  { x[(z)]   = (unsigned short) (y); \
                            x[(z)+1] = (unsigned short) (y) >> 8;  }

#define UNLOADSHORT(x,z)   ((short) ( (((long) x[(z)]   << 16) + \
			               ((long) x[(z)+1] << 24)) >> 16))

#define LOAD32(x,y,z) { x[(z)]   = (unsigned long) (y); \
                          x[(z)+1] = (unsigned long) (y) >> 8; \
                          x[(z)+2] = (unsigned long) (y) >> 16;  \
                          x[(z)+3] = (unsigned long) (y) >> 24;   }

#define UNLOAD32(x,z) ( (long) x[(z)]           +  \
                         ((long) x[(z)+1] << 8)   +  \
                         ((long) x[(z)+2] << 16)  +  \
			 ((long) x[(z)+3] << 24))

/*---------------------------------------------------------------------------*/
/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */
/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */
/*---------------------------------------------------------------------------*/
#define PACKCHAR(val, base, byte) ( ((byte)%2 == 0) ?  \
	 (*((base) + ((byte)/2))  = ((val) & 0xFF)) : \
	 (*((base) + ((byte)/2)) |= ((val) & 0xFF) << (((byte)%2) * 8)) )

#define UNPACKCHAR(base, byte) \
         ( (*((base) + ((byte)/2)) >> (((byte)%2) * 8)) & 0xFF )

#define BSSCIOBUF 1
#endif /* TMS32025 || TMS32050 || TMS320C5XX (LEAD) */

#if defined(_TMS320C30) || defined(_TMS320C40)
/*---------------------------------------------------------------------------*/
/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */
/*                                                                           */
/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */
/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */
/*---------------------------------------------------------------------------*/
#define LOADSHORT(x,y,z)  { x[(z)]   = (unsigned short) (y); \
                            x[(z)+1] = (unsigned short) (y) >> 8;  }

#define UNLOADSHORT(x,z) (((long)((x[(z)] << 16) + (x[(z)+1] << 24))) >> 16)

#define LOAD32(x,y,z) { x[(z)]   = (unsigned long) (y); \
                          x[(z)+1] = (unsigned long) (y) >> 8; \
                          x[(z)+2] = (unsigned long) (y) >> 16;  \
                          x[(z)+3] = (unsigned long) (y) >> 24;   }

#define UNLOAD32(x,z) ((long) (x[(z)]          + (x[(z)+1] << 8) + \
                                (x[(z)+2] << 16) + (x[(z)+3] << 24)))

/*---------------------------------------------------------------------------*/
/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */
/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */
/*---------------------------------------------------------------------------*/
#define PACKCHAR(val, base, byte) ( ((byte)%4 == 0) ?  \
	 (*((base) + ((byte)/4))  = ((val) & 0xFF)) : \
	 (*((base) + ((byte)/4)) |= ((val) & 0xFF) << (((byte)%4) * 8)) )

#define UNPACKCHAR(base, byte) \
         ( (*((base) + ((byte)/4)) >> (((byte)%4) * 8)) & 0xFF )

#define BSSCIOBUF 0
#endif  /* TMS32030 */

#if defined(_TMS37016) || defined(_TMS340)
/*---------------------------------------------------------------------------*/
/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */
/*                                                                           */
/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */
/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */
/*---------------------------------------------------------------------------*/
#define LOADSHORT(x,y,z)  { x[(z)]   = (unsigned short) (y); \
                            x[(z)+1] = (unsigned short) (y) >> 8;  }

#define UNLOADSHORT(x,z) ((short) ( (short) x[(z)] +             \
				   ((short) x[(z)+1] << 8)))

#define LOAD32(x,y,z) { x[(z)]   = (unsigned long) (y); \
                          x[(z)+1] = (unsigned long) (y) >> 8; \
                          x[(z)+2] = (unsigned long) (y) >> 16;  \
                          x[(z)+3] = (unsigned long) (y) >> 24;   }

#define UNLOAD32(x,z) ( (long) x[(z)]           +  \
                         ((long) x[(z)+1] << 8)   +  \
                         ((long) x[(z)+2] << 16)  +  \
			 ((long) x[(z)+3] << 24))

/*---------------------------------------------------------------------------*/
/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */
/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */
/*---------------------------------------------------------------------------*/
#define PACKCHAR(val, base, byte) ( (base)[(byte)] = (val) )

#define UNPACKCHAR(base, byte)    ( (base)[byte] )

#define BSSCIOBUF 1
#endif /* _TMS37016 || _TMS340 */

#if defined(_MVP_PP) || defined(_MVP_MP) || defined(_TMS470) || defined(_TMS370C8) 
/*---------------------------------------------------------------------------*/
/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */
/*                                                                           */
/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */
/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */
/*---------------------------------------------------------------------------*/
#define LOADSHORT(x,y,z)  { x[(z)]   = (unsigned short) (y); \
                            x[(z)+1] = (unsigned short) (y) >> 8;  }

#define UNLOADSHORT(x,z) ((short) ( (short) x[(z)] +             \
				   ((short) x[(z)+1] << 8)))

#define LOAD32(x,y,z) { x[(z)]   = (unsigned long) (y); \
                          x[(z)+1] = (unsigned long) (y) >> 8; \
                          x[(z)+2] = (unsigned long) (y) >> 16;  \
                          x[(z)+3] = (unsigned long) (y) >> 24;   }

#define UNLOAD32(x,z) ( (long) x[(z)]           +  \
                         ((long) x[(z)+1] << 8)   +  \
                         ((long) x[(z)+2] << 16)  +  \
			 ((long) x[(z)+3] << 24))

/*---------------------------------------------------------------------------*/
/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */
/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */
/*---------------------------------------------------------------------------*/
#define PACKCHAR(val, base, byte) ( (base)[(byte)] = (val) )

#define UNPACKCHAR(base, byte)    ( (base)[byte] )

#define BSSCIOBUF 0
#endif 

#if defined(_TMS320C6X)
/*---------------------------------------------------------------------------*/
/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */
/*                                                                           */
/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */
/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */
/*---------------------------------------------------------------------------*/
#define LOADSHORT(x,y,z)  { x[(z)]   = (unsigned short) (y); \
                            x[(z)+1] = (unsigned short) (y) >> 8;  }

#define UNLOADSHORT(x,z) ((short) ( (short) x[(z)] +             \
				   ((short) x[(z)+1] << 8)))

#define LOAD32(x,y,z) { x[(z)]   = (unsigned int) (y); \
                          x[(z)+1] = (unsigned int) (y) >> 8; \
                          x[(z)+2] = (unsigned int) (y) >> 16;  \
                          x[(z)+3] = (unsigned int) (y) >> 24;   }

#define UNLOAD32(x,z) ( (int) x[(z)]           +  \
		       ((int) x[(z)+1] << 8)   +  \
		       ((int) x[(z)+2] << 16)  +  \
		       ((int) x[(z)+3] << 24))

/*---------------------------------------------------------------------------*/
/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */
/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */
/*---------------------------------------------------------------------------*/
#define PACKCHAR(val, base, byte) ( (base)[(byte)] = (val) )

#define UNPACKCHAR(base, byte)    ( (base)[byte] )

#define BSSCIOBUF 0
#endif 


_bufread.c/     868562434   0     0     0       3128      `
/*****************************************************************************/
/*  _BUFREAD.C v1.10#                                                        */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/
 
/*****************************************************************************/
/* Functions:                                                                */
/*    _BUFF_READ  -  Fill a stream's buffer from its file                    */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int  _ft_end;
extern int  _doflush(FILE *_fp);






/*****************************************************************************/
/* _BUFF_READ  -   Fill a stream's buffer from its file                      */
/*                                                                           */
/*    This function fills stream _FP's buffer with the contents of the file  */
/*    it is associated with.  It returns nothing, but sets flags in the      */
/*    stream if any I/O errors occur.                                        */
/*                                                                           */
/*****************************************************************************/
void _buff_read(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   errchk,
         j,
         buffer_size    = _fp->bufend - _fp->buf;

   /*------------------------------------------------------------------------*/
   /* If this is a line buffered stream, flush all line buffered streams.    */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IOLBF)
      for(j=0; j < _ft_end; j++)
         if(_BUFFMODE(&_ftable[j]) == _IOLBF)
            _doflush(&_ftable[j]);

   /*------------------------------------------------------------------------*/
   /* Read in the next characters from the file.                             */
   /*------------------------------------------------------------------------*/
   errchk = read(_fp->fd, (char *)_fp->buf, buffer_size);

   /*------------------------------------------------------------------------*/
   /* Adjust the buffer pointers.                                            */
   /*------------------------------------------------------------------------*/
   _fp->buff_stop = _fp->buf + errchk;
   _fp->pos = _fp->buf;

   /*------------------------------------------------------------------------*/
   /* Set any error flags if necessary.                                      */
   /*------------------------------------------------------------------------*/
   switch(errchk)
   {
      case -1 : _SET(_fp, _STATERR);
                break;
 
      case 0  : _SET(_fp, _STATEOF);
                break;
   }

   return;
 
}
 
_io_perm.c/     868562434   0     0     0       5796      `
/*****************************************************************************/
/*  _IO_PERM.C v1.10#                                                        */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    _RD_OK   -  Check to make sure that the stream is readable             */
/*    _WRT_OK  -  Check to make sure that the stream is writeable            */
/*****************************************************************************/
#include <stdio.h>






/*****************************************************************************/
/* _RD_OK   -  Check to make sure that the stream is readable.               */
/*                                                                           */
/*    This function checks to make sure that the stream _FP has been opened  */
/*    for reading, and allocates a buffer for the stream if one hasn't been  */
/*    already.  The function returns a 1 if it is alright to write to this   */
/*    stream, otherwise it returns a 0.                                      */
/*                                                                           */
/*****************************************************************************/
int _rd_ok(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   result   =  0;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (0);

   /*------------------------------------------------------------------------*/
   /* If this stream is currently being written to, return a 0.              */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEW)) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If this stream was opened in update mode, and is able to either read   */
   /* or write currently, put it in read mode.                               */
   /*------------------------------------------------------------------------*/
   if(!_STCHK(_fp, _MODER) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODER);
 
   /*------------------------------------------------------------------------*/
   /* Allocate a buffer for the stream if needed, and none exist.            */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);
 
   return (! result);
 
}






/*****************************************************************************/
/* _WRT_OK()   -  Check to make sure that a stream is writeable              */
/*                                                                           */
/*    This function takes the FILE pointer _FP, and makes sure that it is ok */
/*    to write to it.  It also allocates a buffer if one is needed.  The     */
/*    function returns a 1 if it is ok to write to this stream, otherwise it */
/*    returns a 0.                                                           */
/*                                                                           */
/*****************************************************************************/
int _wrt_ok(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   result   = 0;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (0);

   /*------------------------------------------------------------------------*/
   /* If this stream is currently being read return a 0.                     */
   /*------------------------------------------------------------------------*/
   if (_STCHK(_fp, _MODER)) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If the stream is in append mode, move the file pointer to the end of   */
   /* the file.                                                              */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEA)) fseek(_fp, 0L, SEEK_END);
 
   /*------------------------------------------------------------------------*/
   /* If this stream was opened in update mode, and is able to either read   */
   /* or write currently, put it in write mode.                              */
   /*------------------------------------------------------------------------*/
   if(!_STCHK(_fp, _MODEW) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODEW);
 
   /*------------------------------------------------------------------------*/
   /* Allocate a buffer for the stream if needed, and none exist.            */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);
 
   return (! result);
}

_printfi.c/     868562434   0     0     0       49729     `
/*****************************************************************************/
/*  _PRINTFI.C v1.10#                                                        */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the main routines that all six variations of the    */
/*    printf function use.  The main function in the file is _printfi,       */
/*    and the other functions here are called by it.                         */
/*                                                                           */
/* FUNCTIONS:                                                                */
/*    _printfi       -  Perform the main printf routine                      */
/*    _pproc_fflags  -  Process the format flags for a conversion            */
/*    _pproc_fwp     -  Convert field width and precision into numbers       */
/*    _pproc_str     -  Process the string (%s) conversion                   */
/*    _setfield      -  Performs conversions when the '%' is encountered     */
/*    _pproc_fge     -  Process the conversion for f, g, G, e, and E         */
/*    _pconv_f       -  Perform the %f conversion                            */
/*    _pconv_e       -  Perform the %e conversion                            */
/*    _pconv_g       -  Perform the %g conversion                            */
/*    _fcpy          -  Copy the fraction part of a float to a string        */
/*    _ecpy          -  Copy the "E+xx" part of a float to a string          */
/*    _mcpy          -  Copy the whole number part of a float to a string    */
/*    _pproc_diouxp  -  Process the conversion for d, i, o, u, x, and p      */
/*    _getarg_diouxp -  Get the argument for d, i, o, u, x, or p conversion  */
/*    _ltostr        -  Convert an integer to a string of up to base 16      */
/*    _div           -  Divide two integers                                  */
/*                                                                           */
/* Note:  If NOFLOAT is defined at compile time, this file will be compiled  */
/*        without floating point support.                                    */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#define SIGNED_CONV (pfield->conv != 'u' && pfield->conv != 'o' && \
                     pfield->conv != 'x' && pfield->conv != 'X')

extern char *fcvt(double value, register int ndigit, int *decpt, int *sign);
extern char *ecvt(double value, register int ndigit, int *decpt, int *sign);
extern char *memccpy(char *dest, const char *src, int ch, int count);

static void _pproc_fflags(_PFIELD *pfield, char **it);
static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap);
static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,
                       int (*_outs)(char *, void *));
static char *_setfield(_PFIELD *pfield, va_list *_ap);
static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it,
                       va_list *_ap);
static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it);
static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it);
static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it);
static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision,
                   char **a_it);
static char *_ecpy(int exp, char letter, char **a_it);
static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it);
static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it,
                         va_list *_ap);
static unsigned long _getarg_diouxp(_PFIELD *pfield, va_list *_ap);
static int _ltostr(unsigned long cvt, int base, char conv, char **a_it);
static unsigned long _div(unsigned long cvt, int base);






/*****************************************************************************/
/* _PRINTFI -  Perform the main printf routine                               */
/*                                                                           */
/*    This function processes the format string.  It copies the format       */
/*    string into the result string until a '%' is encountered, where any    */
/*    flags, the field width, the precision, and the type of conversion are  */
/*    read in, stored in a structure called PFIELD, and passed to _SETFIELD, */
/*    where the actual conversion is processed.  This function returns       */
/*    the number of characters output.                                       */
/*                                                                           */
/*****************************************************************************/
int _printfi(char **_format, va_list _ap, void *_op, 
             int (*_outc)(char, void *), int (*_outs)(char *, void *))
{
   /*------------------------------------------------------------------------*/
   /* Local Variables                                                        */
   /*                                                                        */
   /*    *end     -  A pointer to the end of the format string               */
   /*    *pfield  -  A pointer to a structure _PFIELD, which stores all of   */
   /*                flags and parameters needed to perform a conversion.    */
   /*------------------------------------------------------------------------*/
   char     *end           =  *_format + strlen(*_format);
   int      count          =  0;
   _PFIELD  pfield;

   /*------------------------------------------------------------------------*/
   /* Iterate through the format string until the end of it is reached.      */
   /*------------------------------------------------------------------------*/
   while(*_format < end)
   {
      /*---------------------------------------------------------------------*/
      /* Initialize PFIELD.                                                  */
      /*---------------------------------------------------------------------*/
      memset(&pfield, '\0', sizeof(_PFIELD));
      pfield.precision = -1;

      /*---------------------------------------------------------------------*/
      /* Copy the format string directly to the target string until a '%'    */
      /* is encountered.                                                     */
      /*---------------------------------------------------------------------*/
      for(; **_format != '%' && **_format != '\0'; 
          _outc(*((*_format)++), _op), count++);

      /*---------------------------------------------------------------------*/
      /* If the end of the format string has been reached, break out of the  */
      /* while loop.                                                         */
      /*---------------------------------------------------------------------*/
      if(! (**_format)) break;

      (*_format)++;                   /* Skip to the character after the '%' */

      /*---------------------------------------------------------------------*/
      /* Process the flags immediately after the '%'.                        */
      /*---------------------------------------------------------------------*/
      _pproc_fflags(&pfield, _format);

      /*---------------------------------------------------------------------*/
      /* Convert the field width and precision into numbers.                 */
      /*---------------------------------------------------------------------*/
      _pproc_fwp(&pfield, _format, &_ap);
 
      /*---------------------------------------------------------------------*/
      /* If the h, l, or L flag was specified, set the corresponding flag    */
      /* in pfield.                                                          */
      /*---------------------------------------------------------------------*/
      if(**_format == 'h' || **_format == 'l' || **_format == 'L')
      {
         _SET(&pfield, (**_format == 'h') ? _MFH : (**_format == 'l') ? 
              _MFL : _MFLD);
         (*_format)++;
      }
      /*---------------------------------------------------------------------*/
      /* Set the conversion character in pfield.                             */
      /*---------------------------------------------------------------------*/
      pfield.conv = *((*_format)++);

      /*---------------------------------------------------------------------*/
      /* If 'n' is the conversion specifier, process it in this function,    */
      /* since it is the only one that makes no conversions.  It just stores */
      /* the number of characters printed so far into the next argument.     */
      /* Otherwise, call _SETFIELD which performs the conversion.            */
      /*---------------------------------------------------------------------*/
      if(pfield.conv == 'n')
         switch (pfield.flags & (_MFL | _MFH))
         {
                           /* The 'l' flag was specified */
            case _MFL   :  *(va_arg(_ap, long*)) = (long)count;
                           break;

                           /* The 'h' flag was specified */
            case _MFH   :  *(va_arg(_ap, short*)) = (short)count;
                           break;

            default     :  *(va_arg(_ap, int*)) = (int)count;
                           break;

         }
      else if(pfield.conv == 's') 
         _pproc_str(&pfield, _op, &_ap, &count, _outs);   
      else
      {
         /*------------------------------------------------------------------*/
         /* Append the converted string to the result string, and reposition */
         /* its iterator, it2.                                               */
         /*------------------------------------------------------------------*/
         count += _outs(_setfield(&pfield, &_ap), _op);
      }
   }

   return (count);
}






/*****************************************************************************/
/* _PPROC_FFLAGS   -  Process the format flags for a conversion              */
/*                                                                           */
/*    This function takes the flags directly after the '%' and stores them   */
/*    in the _PFIELD structure PFIELD for later reference.                   */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fflags(_PFIELD *pfield, char **it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int flags_done = 0;

   /*---------------------------------------------------------------------*/
   /* Read in all of the flags associated with this conversion, and set   */
   /* the corresponding flags in the PFIELD structure.                    */
   /*---------------------------------------------------------------------*/
   while(! flags_done)
      switch (**it)
      {
         case '-' :  _SET(pfield, _PFMINUS);
                     (*it)++;
                     break;   

         case '+' :  _SET(pfield, _PFPLUS);
                     (*it)++;
                     break;

         case ' ' :  _SET(pfield, _PFSPACE);
                     (*it)++;
                     break;

         case '#' :  _SET(pfield, _PFPOUND);
                     (*it)++;
                     break;

         case '0' :  _SET(pfield, _PFZERO);
                     (*it)++;
                     break;

         default  :  flags_done = 1;
      }

   return;
}






/*****************************************************************************/
/* _PPROC_FWP   -  Convert the field width and precision from the format     */
/*                 string into numbers.                                      */
/*                                                                           */
/*    This function reads the field and precision out of the format string   */
/*    and converts them into numbers that will be stored in the _PFIELD      */
/*    structure pointed to by PFIELD.  They will be needed for future        */
/*    reference.                                                             */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap)
{
   char tmpstr[10];
   char *tmpptr;

   /*------------------------------------------------------------------------*/
   /* If a '*' was given for the field width, use the next argument as       */
   /* the field width for the conversion.  Otherwise, copy the following     */
   /* numerical characters into a temporary string, and convert that         */
   /* string into an integer, which will be used for the field width.        */
   /*------------------------------------------------------------------------*/
   if(**it == '*')
   {
      pfield->fwidth = va_arg(*_ap, int);

      /*---------------------------------------------------------------------*/
      /* If the argument given for the field width is negative, treat it as  */
      /* if the '-' flag was used, and the field width was positive.         */
      /*---------------------------------------------------------------------*/
      if(pfield->fwidth < 0) 
      {
         pfield->fwidth = -(pfield->fwidth);
         _SET(pfield, _PFMINUS);
      }

      (*it)++;
   }
   else
   {
      /*---------------------------------------------------------------------*/
      /* Initialize the temporary string and iterator that will hold the     */
      /* field width temporarily.                                            */
      /*---------------------------------------------------------------------*/
      tmpptr = tmpstr;
      memset(tmpptr, '\0', 10);

      while((**it >= '0') && (**it <= '9')) *(tmpptr++) = *((*it)++);

      if(*tmpstr != '\0') pfield->fwidth = atoi(tmpstr);
   }

   /*------------------------------------------------------------------------*/
   /* If a '.' appears as the next character, process the following          */
   /* characters as a precision.                                             */
   /*------------------------------------------------------------------------*/
   if(**it == '.')
   {
      (*it)++;

      /*---------------------------------------------------------------------*/
      /* Cancel any effects of the zero flag.                                */
      /*---------------------------------------------------------------------*/
      _UNSET(pfield, _PFZERO);

      /*---------------------------------------------------------------------*/
      /* If a '*' was given for the precision, use the next argument as      */
      /* the precision for the conversion.  Otherwise, copy the following    */
      /* numerical characters into a temporary string, and convert that      */
      /* string into an integer, which will be used for the precision.       */
      /*---------------------------------------------------------------------*/
      if(**it == '*')
      {
         pfield->precision = va_arg(*_ap, int);
         (*it)++;
      }
      else
      {
         /*------------------------------------------------------------------*/
         /* Initialize the temporary string and iterator that will hold      */
         /* the field width temporarily.                                     */
         /*------------------------------------------------------------------*/
         tmpptr = tmpstr;
         memset(tmpptr, '\0', 10);

         while((**it >= '0') && (**it <= '9'))
            *(tmpptr++) = *((*it)++);

         if(*tmpstr != '\0') pfield->precision = atoi(tmpstr);
         else pfield->precision = 0;
      }
   }
   return;
}






/*****************************************************************************/
/* _PPROC_STR  -  Processes the string conversion (%s)                       */
/*                                                                           */
/*    This function places all or a portion of the input string into the     */
/*    the temporary string.  It returns a zero, unless the input string had  */
/*    a length of zero.  In this case, a one is returned.                    */
/*                                                                           */
/*****************************************************************************/
static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,
                       int (*_outs)(char *, void *))
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  *strbuf;
   char  *tmpstr;
   char  *tmpptr;
   int   len, buflen;

   /*------------------------------------------------------------------------*/
   /* Get the next argument.                                                 */
   /*------------------------------------------------------------------------*/
   strbuf = va_arg(*_ap, char*);

   /*------------------------------------------------------------------------*/
   /* Handle NULL strings.                                                   */
   /*------------------------------------------------------------------------*/
   if(strbuf == NULL)
   {
      _outs("(null)", _op);
      return;
   }

   buflen = (pfield->precision >= 0 && pfield->precision < strlen(strbuf)) ?
            pfield->precision : strlen(strbuf);
   len = (pfield->fwidth > buflen) ? pfield->fwidth : buflen;
   *count += len;

   if(!(tmpstr = (char *)malloc(len + 1))) return;
   tmpptr = tmpstr;

   if(buflen < len && !_STCHK(pfield, _PFMINUS))
   {
      memset(tmpptr, ' ', (len - buflen));
      tmpptr += (len - buflen);  
   }

   strncpy(tmpptr, strbuf, buflen);
   tmpptr += buflen;

   if(buflen < len && _STCHK(pfield, _PFMINUS))
   {
      memset(tmpptr, ' ', (len - buflen));
      tmpptr += (len - buflen);
   }

   *(tmpstr + len) = '\0';

   _outs(tmpstr, _op);

   free(tmpstr);

   return;
}






/*****************************************************************************/
/* _SETFIELD   -  Performs conversions when the '%' is encountered           */
/*                                                                           */
/*    This function takes pfield, and calls the appropriate processing       */
/*    function for the conversion required in the _PFIELD structure.  It     */
/*    returns a pointer to the result string.                                */
/*                                                                           */
/*****************************************************************************/
static char *_setfield(_PFIELD *pfield, va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variable declarations, and a description of their use            */
   /*                                                                        */
   /*    FLD is a temporary string that will hold the conversion.  F_START   */
   /*    will be a pointer to the beginning of the field, and if a           */
   /*    field width was specified, F_END will be a pointer to the end of    */
   /*    the field.  This designated field is located at the beginning of    */
   /*    the string FLD.   A_END is a pointer to the end of the string FLD,  */
   /*    and this is where the primary conversion will take place.  Using    */
   /*    A_IT, an iterator beginning at the end of FLD, the number will be   */
   /*    written one digit at a time starting with the rightmost digit.      */
   /*    Using the pointer WHERE, the number in string form will be moved    */
   /*    to its appropriate place within the field after making adjustments  */
   /*    called for by various flags in the format specification (a minus    */
   /*    sign, leading zeros, etc.).  The string FLD will then be returned.  */
   /*                                                                        */
   /*    MINUS_FLAG is exactly what it says ( = 1 if number is negative).    */
   /*                                                                        */
   /*------------------------------------------------------------------------*/
   static   char fld[_ARSIZE];
            char *f_start           =  (char *)fld;
            char *f_end             =  f_start + pfield->fwidth;
            char *a_end             =  f_start + _ARSIZE -1; 
            char *a_it              =  a_end;
            char *where;
            int  minus_flag         = 0;
            int  plus_flag          = 0;

   /*------------------------------------------------------------------------*/
   /* Clear the temporary string.  Then, since we are working from right to  */
   /* left, begin with the NULL character.                                   */
   /*------------------------------------------------------------------------*/
   memset(fld, ' ', _ARSIZE);
   *(a_it--) = '\0'; 

   /*------------------------------------------------------------------------*/
   /* Call the appropriate processing function.                              */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'd' :
      case 'i' :
      case 'o' :
      case 'u' :
      case 'x' :
      case 'X' :  
      case 'p' :  _pproc_diouxp(pfield, &minus_flag, &a_it, _ap);
                  break;  

#ifndef NOFLOAT
      case 'g' :  
      case 'G' : 
      case 'e' :
      case 'E' :
      case 'f' :  _pproc_fge(pfield, &minus_flag, &a_it, _ap);
                  break;
#endif
  
      case 'c' :  *(a_it--) = va_arg(*_ap, int);
                  _UNSET(pfield, _PFPLUS);
                  break;

      case '%' :  strcpy(f_start, "%"); return((char *)fld);


   }

   plus_flag = (_STCHK(pfield, _PFPLUS) && SIGNED_CONV);

   /*------------------------------------------------------------------------*/
   /* If the number was negative, or the '+' flag was used, insert the sign. */
   /* Make sure unsigned conversions don't get a '+' sign.                   */
   /*------------------------------------------------------------------------*/
   if(minus_flag) *(a_it--) = '-';
   else if(plus_flag) *(a_it--) = '+';

   /*------------------------------------------------------------------------*/
   /* If the number was positive, the '+' flag was not used, and the ' '     */
   /* flag was used, insert a space.                                         */
   /*------------------------------------------------------------------------*/
   if(! minus_flag && ! plus_flag && _STCHK(pfield, _PFSPACE)) *(a_it--) = ' ';

   /*------------------------------------------------------------------------*/
   /* If the '-' flag was used or the resulting string is larger than the    */
   /* field, left justify the result in the array.  Otherwise right-justify  */
   /* it.                                                                    */
   /*------------------------------------------------------------------------*/
   where = (_STCHK(pfield, _PFMINUS) ||
           ((a_end - a_it) > pfield->fwidth)) ? f_start :
           (f_end - (a_end - a_it)+1);

   a_it = (char *)memccpy(where, a_it+1, '\0', _ARSIZE);

   /*------------------------------------------------------------------------*/
   /* If a resulting left-justified string is smaller than the field width,  */
   /* move the terminating NULL character to the end of the field.           */
   /*------------------------------------------------------------------------*/
   if(a_it <= f_end)
   {
      *(a_it-1) = ' ';
      *f_end = '\0';
   }

   /*------------------------------------------------------------------------*/
   /* If the '0' flag was used, and the resulting string is right-justified, */
   /* fill in the leading zeros.                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(pfield, _PFZERO))
   {
      memset(f_start, '0', (where - f_start));


      /*---------------------------------------------------------------------*/
      /* Make sure any sign or leading space is moved to the left side of    */
      /* any leading zeros.                                                  */
      /*---------------------------------------------------------------------*/
      if((minus_flag || plus_flag || _STCHK(pfield, _PFSPACE)) &&
          where != f_start)
      {
         *f_start = *where;
         *where = '0';
      }
   }

   /*------------------------------------------------------------------------*/
   /* Return the result string.                                              */
   /*------------------------------------------------------------------------*/
   return ((char *)fld);                     
}






#ifndef NOFLOAT
/*****************************************************************************/
/* _PPPROC_FGE   -  Process the conversion for f, g, G, e, and E             */
/*                                                                           */
/*    This function takes the structure PFIELD, which contains all of the    */
/*    flags and parameters to process the conversion, and it does this       */
/*    conversion, and stores the result in the string pointed to by          */
/*    *A_IT.                                                                 */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it, 
                       va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   long double cvt =  0;

   /*------------------------------------------------------------------------*/
   /* Determine what kind of argument is coming next, and read it into CVT.  */
   /*------------------------------------------------------------------------*/
   switch(_STCHK(pfield, _MFLD))
   {
      case  0  :  cvt = (double)va_arg((*_ap), double);
                  break;

      default  :  cvt = va_arg((*_ap), long double);

   }

   /*------------------------------------------------------------------------*/
   /* If CVT is negative, set the MINUS_FLAG and reverse the sign of CVT.    */
   /*------------------------------------------------------------------------*/
   if(*minus_flag = (cvt < 0)) cvt = -cvt;

   /*------------------------------------------------------------------------*/
   /* Call the proper conversion function                                    */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'f' :  _pconv_f(cvt, pfield, a_it);
                  break;
      case 'e' :
      case 'E' :  _pconv_e(cvt, pfield, a_it);
                  break;
      case 'g' :
      case 'G' :  _pconv_g(cvt, pfield, a_it);
   }
}






/*****************************************************************************/
/* _PCONV_F -  Perform the %f conversion                                     */
/*****************************************************************************/
static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   int   dpt, 
         sign, 
         putdec;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   /*------------------------------------------------------------------------*/
   /* Call the FCVT float to string function, then copy the fractional part, */
   /* determine whether or not a decimal point should be placed, and copy    */
   /* whole number part.                                                     */
   /*------------------------------------------------------------------------*/
   strcpy(tmpbuf, fcvt(cvt, pfield->precision, &dpt, &sign));
   _fcpy(tmpbuf, dpt, 1, pfield->precision, a_it);
   putdec = (dpt != (int)strlen(tmpbuf) || _STCHK(pfield, _PFPOUND)) ? 1 : 0;
   _mcpy(tmpbuf, dpt, putdec, a_it);
}






/*****************************************************************************/
/* _PCONV_E -  Perform the %e conversion                                     */
/*****************************************************************************/
static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   int   dpt, 
         sign, 
         putdec, 
         exp      = 0;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   /*------------------------------------------------------------------------*/
   /* Convert CVT to x.xxxe+xx form, keeping the exponent in EXP.            */
   /*------------------------------------------------------------------------*/
   if(cvt)
   {
      for(;cvt < 1; cvt *= 10, exp--);
      for(;cvt >= 10; cvt /= 10, exp++);
   }

   /*------------------------------------------------------------------------*/
   /* Call the FCVT float to string function, copy the exponent part, the    */
   /* fractional part, then determine whether or not a decimal point should  */
   /* be placed, and copy the whole number part.                             */
   /*------------------------------------------------------------------------*/
   strcpy(tmpbuf, fcvt(cvt, pfield->precision, &dpt, &sign));
   if(dpt==2) /* fcvt() might have rounded the number */
   {
       dpt--; exp++;
   }
   _ecpy(exp, pfield->conv, a_it);
   _fcpy(tmpbuf, dpt, 1, pfield->precision, a_it);
   putdec = (dpt != (int)strlen(tmpbuf) || _STCHK(pfield, _PFPOUND)) ? 1 : 0;
   _mcpy(tmpbuf, dpt, putdec, a_it);
}






/*****************************************************************************/
/* _PCONV_G -  Perform the %g conversion                                     */
/*****************************************************************************/
static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   char  *check;
   int   dpt, 
         sign, 
         putdec, 
         exp         = 0, 
         change_test = 0;

   /*------------------------------------------------------------------------*/
   /* If the precision was given as 0, set it to one.                        */
   /*------------------------------------------------------------------------*/
   if(pfield->precision == 0) pfield->precision = 1;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   strcpy(tmpbuf, ecvt((double)cvt, pfield->precision, &dpt, &sign));

   /*------------------------------------------------------------------------*/
   /* If the exponent is less than -4, or greater than or equal to the       */
   /* precision, convert the number as a %e conversion.  Otherwise convert   */
   /* it as a %f conversion.                                                 */
   /*------------------------------------------------------------------------*/
   if(dpt < -3 || dpt > pfield->precision)
   {
      for(;dpt > 1; dpt--, exp++);
      for(;dpt < 1; dpt++, exp--);

      _ecpy(exp, pfield->conv-2, a_it);
   }

   /*------------------------------------------------------------------------*/
   /* Copy the fractional part of the number.  CHANGE_TEST will be set if    */
   /* there was a fractional part, otherwise it will remain a zero.          */
   /*------------------------------------------------------------------------*/
   check = *a_it;
   _fcpy(tmpbuf, dpt, (_STCHK(pfield, _PFPOUND)) ? 1 : 0, pfield->precision,
         a_it);
   change_test = (check != *a_it);

   /*------------------------------------------------------------------------*/
   /* If the '#' flag was used, or there was a fractional part to the number */
   /* a decimal point will be placed.                                        */
   /*------------------------------------------------------------------------*/
   putdec = (_STCHK(pfield, _PFPOUND) || change_test) ? 1 : 0;

   _mcpy(tmpbuf, dpt, putdec, a_it);

}






/*****************************************************************************/
/* _FCPY -  Copy the fraction part of a float to a string                    */
/*****************************************************************************/
static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision, 
                   char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   i;
   char  *tmpptr = (char *)tmpbuf + strlen(tmpbuf) -1;

   /*------------------------------------------------------------------------*/
   /* Fill all unused precision spaces with zeros.                           */
   /*------------------------------------------------------------------------*/
   for(i = 0; i < precision && dpt > (int)strlen(tmpbuf) && trail; i++)
      *((*a_it)--) = '0';
 
   /*------------------------------------------------------------------------*/
   /* Copy the fractional part of the float into the string.                 */
   /*------------------------------------------------------------------------*/
   if(dpt < (int)strlen(tmpbuf) && dpt >= 0)
   {
      i = (int)strlen(tmpbuf) - dpt;

      /*---------------------------------------------------------------------*/
      /* Skip trailing zeros if TRAIL is not set.                            */
      /*---------------------------------------------------------------------*/
      if(! trail) for(; i > 0 && *tmpptr == '0'; tmpptr--, i--);

      for(; i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;

   }

 
   /*------------------------------------------------------------------------*/
   /* Place any leading fractional zeros if necessary.                       */
   /*------------------------------------------------------------------------*/
   if(dpt < 0)
   {
      for(i = strlen(tmpbuf); i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;
      for(i = -dpt; i > 0; i--) *((*a_it)--) = '0';
   }

   return (*a_it);
}
  





/*****************************************************************************/
/* _ECPY -  Copy the "e+xx" part of a float to a string                      */
/*****************************************************************************/
static char *_ecpy(int exp, char letter, char **a_it)
{
   _ltostr((exp > 0) ? exp : -exp, 10, 'd', a_it);
   if(exp < 10 && exp > -10) *((*a_it)--) = '0';
   *((*a_it)--) = (exp < 0) ? '-' : '+';
   *((*a_it)--) = letter;

   return (*a_it);
}






/*****************************************************************************/
/* _MCPY -  Copy the whole number part of a float to a string                */
/*****************************************************************************/
static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   i;
   char  *tmpptr;


   /*------------------------------------------------------------------------*/
   /* If the number has both a whole number part and a fractional part,      */
   /* position TMPPTR to the last character of the whole number.             */
   /*------------------------------------------------------------------------*/
   if(dpt > 0 && dpt <= (int)strlen(tmpbuf)) tmpptr = (char *)tmpbuf + dpt -1;

   /*------------------------------------------------------------------------*/
   /* Place a decimal point if PUTDEC is set.                                */
   /*------------------------------------------------------------------------*/
   if(putdec) *((*a_it)--) = '.';

   /*------------------------------------------------------------------------*/
   /* Place any whole number trailing zeros.                                 */
   /*------------------------------------------------------------------------*/
   for(i = dpt; i > (int)strlen(tmpbuf); i--) *((*a_it)--) = '0';

   /*------------------------------------------------------------------------*/
   /* Copy the rest of the whole number.                                     */
   /*------------------------------------------------------------------------*/
   if(i > 0) for(; tmpptr >= tmpbuf; tmpptr--) *((*a_it)--) = *tmpptr;
   else *((*a_it)--) = '0';

   return (*a_it);
}





#endif

/*****************************************************************************/
/* _PPROC_DIOUXP   -  Process the conversion for d, i, o, u, x, and p        */
/*                                                                           */
/*    This function takes the structure PFIELD, which contains all of the    */
/*    flags and parameters to process the conversion, and it does this       */
/*    conversion, and stores the result in the string pointed to by          */
/*    *A_IT.                                                                 */
/*                                                                           */
/*****************************************************************************/
static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it, 
                         va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int digits           =  0;
   int base;
   unsigned long cvt;

   /*------------------------------------------------------------------------*/
   /* If no precision was given, set it to 1.                                */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 1; 

   /*------------------------------------------------------------------------*/
   /* Set the base of the number by the type of conversion specified.        */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'p' :
      case 'x' :
      case 'X' :  base = 16;
                  break;

      case 'o' :  base = 8;
                  break;

      case 'u' :
      case 'd' :
      case 'i' :  base = 10;
   }  

   /*------------------------------------------------------------------------*/
   /* Get the next argument.                                                 */
   /*------------------------------------------------------------------------*/
   cvt = _getarg_diouxp(pfield, _ap);

   /*------------------------------------------------------------------------*/
   /* If the precision is 0, and the number is 0, do nothing and return 1.   */
   /*------------------------------------------------------------------------*/
   if(pfield->precision == 0 && cvt == 0) return 1;

   /*------------------------------------------------------------------------*/
   /* If the number is signed and negative, set the minus sign flag, and     */
   /* multiply the number by -1.                                              */
   /*------------------------------------------------------------------------*/
   if((pfield->conv == 'd' || pfield->conv == 'i')
      && ((long)cvt < 0))
   {
      *minus_flag = 1;
      cvt = (long)cvt * -1;
   }

   /*------------------------------------------------------------------------*/
   /* Call the function to convert the number to a string, and add the       */
   /* total number of digits assigned into DIGITS.                           */
   /*------------------------------------------------------------------------*/
   digits += _ltostr(cvt, base, pfield->conv, a_it);

   /*------------------------------------------------------------------------*/
   /* Fill in the remainder of the precision with zeros.                     */
   /*------------------------------------------------------------------------*/
   while(digits++ < pfield->precision) *((*a_it)--) = '0';


   /*------------------------------------------------------------------------*/
   /* If the "#" flag was used in the X or x conversion, prefix a "0x" or    */
   /* "0X" to the hexadecimal number.                                        */
   /*------------------------------------------------------------------------*/
   if((pfield->conv == 'x' || pfield->conv == 'X') && _STCHK(pfield, _PFPOUND))
   {
      *((*a_it)--) = pfield->conv;
      *((*a_it)--) = '0';
   }

   /*------------------------------------------------------------------------*/
   /* If the "#' flag was used in the o conversion, prefix a "0" to the      */
   /* octal number.                                                          */
   /*------------------------------------------------------------------------*/
   if(pfield->conv == 'o' && _STCHK(pfield, _PFPOUND)) *((*a_it)--) = '0';

   return (0);

}






/*****************************************************************************/
/* _GETARG_DIOUXP -  Get the argument for a d, i, o, u, x, or p conversion   */
/*                                                                           */
/*    This function takes the next argument off the argument list, after     */
/*    determining what kind of argument it is.  It decides this by checking  */
/*    to see if the 'h' or the 'l' flag was used.  It returns the next       */
/*    argument.                                                              */
/*                                                                           */
/*****************************************************************************/
static unsigned long _getarg_diouxp(_PFIELD *pfield, va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned long cvt;

   /*------------------------------------------------------------------------*/
   /* Get the number from the next argument.  Determine what kind of         */
   /* argument by checking for the h or l flag in the format specification.  */
   /*------------------------------------------------------------------------*/
   switch(_STCHK(pfield, (_MFH | _MFL)))
   {
      case _MFH   :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : cvt = va_arg(*_ap, int);
                                   break;

                        case 'p' :
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : cvt = 
   			           (unsigned short) va_arg(*_ap, unsigned int);
                     }
                     break;

      case _MFL   :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : cvt = va_arg(*_ap, long int);
                                   break;

                        case 'p' : 
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : cvt = va_arg(*_ap, unsigned long int);
                     }
                     break;
   
      default     :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : cvt = va_arg(*_ap, int);;
                                   break;
 
                        case 'p' :
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : cvt = va_arg(*_ap, unsigned int);
                     }
                     break;
   
   }

   return (cvt);
}






/*****************************************************************************/
/* _LTOSTR  -  Convert an integer to a string of up to base 16               */
/*                                                                           */
/*    This function takes an unsigned long integer, converts it to a string  */
/*    which is pointed to by *A_IT.  The result will also be converted to    */
/*    a base corresponding to the variable base.                             */
/*                                                                           */
/*****************************************************************************/
static int _ltostr(unsigned long cvt, int base, char conv, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local Variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned long  quot,
                  rem;
            char  *bnum = "0123456789abcdef0123456789ABCDEF";

   /*------------------------------------------------------------------------*/
   /* The number CVT will be converted to a string by taking the remainder   */
   /* of a division of it by its base, and converting it to a character.     */
   /* The number CVT is then set equat to itself divided by its base, and    */
   /* this continues until CVT is 0.                                         */
   /*------------------------------------------------------------------------*/

   if(! cvt) *((*a_it)--) = '0';

   while(cvt)
   {
      quot = _div(cvt, base);
      rem = cvt - (quot * base);

      if(conv == 'X') rem += 16;

      *((*a_it)--) = bnum[rem];
      cvt = quot;
   }

   return (strlen(*a_it) -1);
}






/*****************************************************************************/
/* _DIV  -  Divide two integers                                              */
/*                                                                           */
/*    This function takes an unsigned long, and divides it by an integer.    */
/*    This function exists because when an integer is greater than the       */
/*    largest signed long integer, the conventional '/' operator overflows.  */
/*    This function is used by _LTOSTR when it is converting an unsigned int */
/*    to a string.                                                           */
/*                                                                           */
/*****************************************************************************/
static unsigned long _div(unsigned long cvt, int base)
{

   /*------------------------------------------------------------------------*/
   /* If the '/' operator will not overflow, use it.                         */
   /*------------------------------------------------------------------------*/

   if(cvt <= LONG_MAX) return (cvt / base);

   /*------------------------------------------------------------------------*/
   /* In the case that the base is 8 or 16, the division can be done using   */
   /* bit operations.  For base 10, the numerator and the divisor are        */
   /* converted into double floating point numbers, where the '/' operator   */
   /* will work properly.                                                    */
   /*------------------------------------------------------------------------*/

   else  
      switch(base)
      {
         case  8  :  
         case 16  :  while((base >>=1) > 0) cvt >>=1; break;
         case 10  :  cvt >>= 1;
                     cvt /= 5;
                     break;
      }

   return (cvt);
}


_scanfi.c/      868562434   0     0     0       32249     `
/*****************************************************************************/
/*  _SCANFI.C v1.10#                                                         */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the main routines that all three variations of the  */
/*    scanf function use.  The main function in the file is _scanfi, and     */
/*    the other functions here are called by it.                             */
/*                                                                           */
/* FUNCTIONS:                                                                */
/*    _scanfi        -  The main scanf handling routine                      */
/*    _sget_conv     -  Read the format flags into the _SFIELD pointer sfield*/
/*    _sget_scanset  -  Read in the scanset from the format statement        */
/*    _sproc_int     -  Read an integer string into a temporary string       */
/*    _sproc_float   -  Read a float string into a temporary string          */
/*    _sproc_str     -  Copy a string from the input source to a temporary   */
/*                      string                                               */
/*    _sproc_lb      -  Process the %[ conversion                            */
/*    _sset_arg      -  Assign the converted value to the next argument      */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

static int _sget_conv(char **_format, _SFIELD *sfield);
static int _sget_scanset(_SFIELD *sfield, char **_format);
static int _sproc_int(int w_counter, char (*_inpchar)(void **inp),
                       void (*_uninpchar)(void **inp, char outchar),
                       char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_float(int w_counter, char (*_inpchar)(void **inp),
                         void (*_uninpchar)(void **inp, char outchar),
                         char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_str(int w_counter, char (*_inpchar)(void **inp),
                       void (*_uninpchar)(void **inp, char outchar),
                       char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_lb(char (*_inpchar)(void **inp),
                      void (*_uninpchar)(void **inp, char outchar),
                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read);
static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf);






/*****************************************************************************/
/* _SCANFI  -  The main scanf handling routine                               */
/*                                                                           */
/*    This function parses all non-conversion characters in the format       */
/*    string, passes control to the appropriate function when a '%' is       */
/*    encountered, then calls _SSET_ARG, which assignes the result to the    */
/*    next argument.                                                         */
/*                                                                           */
/*****************************************************************************/
int _scanfi(void *inp, const char *_format, va_list _ap, 
            int (*_chkmbc)(void **inp, char **_format, int *num_read),
            char (*_inpchar)(void **inp), 
            void (*_uninpchar)(void **inp, char outchar))
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   _SFIELD  sfield;
   char     tmpbuf[256],
            *tmpptr,
            inchar,
            *f_ptr         = (char *)_format;
   int      num_assigned   =  0,
            num_read       =  0,
            stat           =  0;

   /*------------------------------------------------------------------------*/
   /* If the first character in the format string is a white space character */
   /* parse the format string until a non-white space character is found.    */
   /* Do the same for the input, but put the first non-white space character */
   /* back onto the input stream when finished.                              */
   /*------------------------------------------------------------------------*/
   if (isspace(*f_ptr))
   {
      for(;isspace(*f_ptr);f_ptr++);

      inchar = _inpchar(&inp);
      num_read++;

      for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);

      _uninpchar(&inp, inchar);
      num_read--;
   }

   while(1)
   {
      /*---------------------------------------------------------------------*/
      /* Initialize sfield                                                   */
      /*---------------------------------------------------------------------*/
      memset(&sfield, 0, sizeof(_SFIELD));
      sfield.fwidth = -1;

      /*---------------------------------------------------------------------*/
      /* Call _chkmbc to compare the format string to the input.  If a       */
      /* mismatch occurs, return an EOF, if the end of the format string     */
      /* is reached, return the number of arguments assigned.  Otherwise     */
      /* a '%' has been encountered, so call _sget_conv to process it.       */
      /*---------------------------------------------------------------------*/
      switch(_chkmbc(&inp, &f_ptr, &num_read))
      {
         case  EOF   : return (EOF);
   
         case  0     : return (num_assigned);
   
         case  1     :  _sget_conv(&f_ptr, &sfield);
   
      }
   
      tmpptr = tmpbuf;

      /*---------------------------------------------------------------------*/
      /* Unless the conversion specifier is a [, c, or n, skip to the next   */
      /* non-white space character in the input.                             */
      /*---------------------------------------------------------------------*/
      if (sfield.conv != '[' && sfield.conv != 'c' && sfield.conv != 'n')
      {
         inchar = _inpchar(&inp);
         num_read++;
    
         for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);
    
         _uninpchar(&inp, inchar);
         num_read--;
      }

      /*---------------------------------------------------------------------*/
      /* The flags have been set in sfield, so process the conversion by     */
      /* calling the appropriate function.                                   */
      /*---------------------------------------------------------------------*/
      switch(sfield.conv)
      {
         case  'X'   :  sfield.conv = 'x';
         case  'i'   :
         case  'p'   :  
         case  'x'   :
         case  'u'   :
         case  'o'   :
         case  'd'   :  stat = _sproc_int(sfield.fwidth, _inpchar, _uninpchar, 
                                         tmpptr, sfield.conv, &inp, &num_read); 
                        break;
         case  'f'   :
         case  'e'   :
         case  'E'   :
         case  'g'   :
         case  'G'   :  stat = _sproc_float(sfield.fwidth, _inpchar, _uninpchar,
                                     tmpptr, sfield.conv, &inp, &num_read);
                        break;

         case  'c'   :  
         case  's'   : {
                          char *stptr = (sfield.flags & _SFSTAR) ?
                                         NULL : va_arg(_ap, char*);

                          stat = _sproc_str(sfield.fwidth, _inpchar, _uninpchar,
                                     stptr, sfield.conv, &inp, &num_read);
                       }
                       stat = (stat != EOF);
                       if (!(sfield.flags & _SFSTAR) && stat) num_assigned++;
                       break;

         case  '['   :  stat = _sproc_lb(_inpchar, _uninpchar, tmpptr, &sfield,
                                         &inp, &num_read);

      }

      stat = (stat != EOF);

      /*---------------------------------------------------------------------*/
      /* Now, call the function to handle the actual assignment, or if there */
      /* is no assignment to take place, process it here.                    */
      /*---------------------------------------------------------------------*/
      switch(sfield.conv)
      {
         case  'i'   :
         case  'd'   :  
         case  'x'   :
         case  'u'   :
         case  'o'   :  
         case  'p'   : 
         case  'e'   :
         case  'f'   :
         case  'g'   :
         case  'E'   :
         case  'G'   :  _sset_arg(&sfield, &_ap, tmpbuf);
                        if ((!(sfield.flags & _SFSTAR)) && stat) num_assigned++;
                        break;
 
         case  'n'   :  if (!(sfield.flags & _SFSTAR))
                           switch(sfield.flags & (_MFH | _MFL))
                           {
                              case  _MFH  :  *(va_arg(_ap, short int*)) =
                                             (short int)num_read;
                                             break;
 
                              case _MFL   :  *(va_arg(_ap, long int*)) =
                                             (long int)num_read;
                                             break;
 
                              default     :  *(va_arg(_ap, int*)) =
                                             num_read;
                                             break;
                           }
                        break;

         case  '%'   :  inchar = _inpchar(&inp);
                        if (inchar != '%') return (EOF);
                        else num_read++;
                        break;
                              
         case  '['   :  if ((!(sfield.flags & _SFSTAR)) && stat)
                        {
                           strcpy(va_arg(_ap, char *), tmpbuf);
                           num_assigned++;
                        }
      }
   }

}






/*****************************************************************************/
/* _SGET_CONV  -  Read the format flags into the _SFIELD pointer sfield      */
/*                                                                           */
/*    This function reads the characters directly after the '%' character,   */
/*    and stores them as flags in sfield, a pointer to a _SFIELD structure.  */
/*    These flags will later be used to process the conversion.              */
/*                                                                           */
/*****************************************************************************/
static int _sget_conv(char **_format, _SFIELD *sfield)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[8],
         *tmpptr     =  tmpbuf,
         *strend     =  (*_format) + strlen(*_format);

   (*_format)++;                        /* Go to the character after the '%' */

   /*------------------------------------------------------------------------*/
   /* If the next character in the format statement is a '*', set the        */
   /* _SFSTAR flag in sfield                                                 */
   /*------------------------------------------------------------------------*/
   if (**_format == '*')
   {
      _SET(sfield, _SFSTAR);
      (*_format)++;
   }
 
   /*------------------------------------------------------------------------*/
   /* If numerical characters follow, read them into a temporary string,     */
   /* convert it into a number, and store it as the field width in sfield    */
   /*------------------------------------------------------------------------*/
   for(;**_format >= '0' && **_format <= '9'; *(tmpptr++) = *((*_format)++));
   *tmpptr = '\0';
 
   if (strlen(tmpbuf)) sfield->fwidth = atoi(tmpbuf);
 
   /*------------------------------------------------------------------------*/
   /* Set the h, l, or L flags if they were specified                        */
   /*------------------------------------------------------------------------*/
   switch(**_format)
   {
      case  'h'   :  _SET(sfield, _MFH);
                     (*_format)++;
                     break;
 
      case  'l'   :  _SET(sfield, _MFL);
                     (*_format)++;
                     break;
  
      case  'L'   :  _SET(sfield, _MFLD);
                     (*_format)++;
                     break;
   }

   /*------------------------------------------------------------------------*/
   /* Read in the last character as the conversion specifier                 */
   /*------------------------------------------------------------------------*/
   sfield->conv = *((*_format)++);

   /*------------------------------------------------------------------------*/
   /* For the '[' conversion, read in the scanset.  Return an EOF if         */
   /* _SGET_SCANSET fails.                                                   */
   /*------------------------------------------------------------------------*/
   if ((sfield->conv == '[') && _sget_scanset(sfield, _format)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If we read past the end of the format string, return an error          */
   /*------------------------------------------------------------------------*/
   if (*_format > strend) return (EOF);
   else return (0);
}






/*****************************************************************************/
/* _SGET_SCANSET  -  Read in the scanset from the format statement           */
/*                                                                           */
/*    This function is called when the '[' conversion specifier has been     */
/*    encountered.  It reads in the scanset from the format statement,       */
/*    and stores it in sfield for later reference during the conversion.     */
/*                                                                           */
/*****************************************************************************/
static int _sget_scanset(_SFIELD *sfield, char **_format)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  *tmpptr  =  sfield->scanset;

   if (**_format == '^')
   {
      _SET(sfield, _SFCIRC);
      (*_format)++;
   }

   if (**_format == ']') *(tmpptr++) = *((*_format)++);

   while(**_format != ']' && **_format != '\0') *(tmpptr++) = *((*_format)++);

   *tmpptr = '\0';
   if (**_format == ']') (*_format)++;
   if (**_format == '\0') return (EOF);

   return(0);
}






/*****************************************************************************/
/* _SPROC_INT  -  Read an integer string into a temporary string             */
/*                                                                           */
/*    This function takes the next integer in character form from the        */
/*    current input source, and copies it into a temporary string, where     */
/*    it can later be converted into a numerical value.                      */
/*                                                                           */
/*****************************************************************************/
static int _sproc_int(int w_counter, char (*_inpchar)(void **inp), 
                       void (*_uninpchar)(void **inp, char outchar), 
                       char *tmpptr, char conv, void **inp, int *num_read) 
{
   /*------------------------------------------------------------------------*/
   /* Note: w_counter is a parameter that holds the field width.  When       */
   /*       the number of digits specified by w_counter has been read from   */
   /*       input, the function finishes.  w_counter is checked before each  */
   /*       read to make sure that it is not equal to zero, and it is        */
   /*       decremented after each read.  If no field width was specified,   */
   /*       w_counter will be equal to -1, in which case it will never       */
   /*       equal zero, and the function will read from input until it       */
   /*       encounters the first invalid character.                          */
   /*------------------------------------------------------------------------*/

   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char inchar;
   int bnum_read = *num_read;

   /*------------------------------------------------------------------------*/
   /* Read in the next character                                             */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a sign for the number               */
   /*------------------------------------------------------------------------*/
   if ((inchar == '+' || inchar == '-') && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }


   /*------------------------------------------------------------------------*/
   /* Accept a leading '0' for an octal number, or a '0x' or '0X' for a      */
   /* hexadecimal number.                                                    */
   /*------------------------------------------------------------------------*/
   if ((conv == 'o' || conv == 'i' || conv =='x' || conv == 'p') && 
      w_counter != 0 && inchar == '0')
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   if ((conv == 'x' || conv == 'p' || conv == 'i') && w_counter != 0 &&
     (inchar == 'x' || inchar == 'X'))
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   /*------------------------------------------------------------------------*/
   /* Accept digits 0-9 for decimal numbers, or 0-F for hexadecimal numbers  */
   /*------------------------------------------------------------------------*/
   while(((inchar >= '0' && inchar <= '9') || 
          ((conv == 'x' || conv == 'p' || conv == 'i') &&
          ((inchar >= 'A' && inchar <= 'F') ||
          (inchar >= 'a' && inchar <= 'f')))) && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   _uninpchar(inp, inchar);
   (*num_read)--;

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SPROC_FLOAT   -  Read a float string into a temporary string             */
/*                                                                           */
/*    This function takes the next float in character form from the          */
/*    current input source, and copies it into a temporary string, where     */
/*    it can later be converted into a numerical value.                      */
/*                                                                           */
/*****************************************************************************/
static int _sproc_float(int w_counter, char (*_inpchar)(void **inp), 
                         void (*_uninpchar)(void **inp, char outchar), 
                         char *tmpptr, char conv, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Note: w_counter is a parameter that holds the field width.  When       */
   /*       the number of digits specified by w_counter has been read from   */
   /*       input, the function finishes.  w_counter is checked before each  */
   /*       read to make sure that it is not equal to zero, and it is        */
   /*       decremented after each read.  If no field width was specified,   */
   /*       w_counter will be equal to -1, in which case it will never       */
   /*       equal zero, and the function will read from input until it       */
   /*       encounters the first invalid character.                          */
   /*------------------------------------------------------------------------*/
 
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char  inchar;
   int          invalid   = 0;
   int          bnum_read = *num_read;
   int          dec_flag  =  0;
   int          e_flag    =  0;

   /*------------------------------------------------------------------------*/
   /* Read in the next character                                             */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a sign                              */
   /*------------------------------------------------------------------------*/
   if ((inchar == '+' || inchar == '-') && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }
 
   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a numerical digit.                  */
   /* The characters '.', 'e', 'E', '+', and '-' are accepted under the      */
   /* following conditions:                                                  */
   /*                                                                        */
   /* '.'         :  a '.', an 'e', or an 'E' has not yet been encountered   */
   /* 'e' or 'E'  :  neither of these characters have been encounterd yet    */
   /* '+' or '-'  :  If the last character read was an 'E' or an 'e'         */
   /*------------------------------------------------------------------------*/
   while((inchar >= '0' && inchar <= '9') || inchar == '.' || inchar == 'e'
          || inchar == 'E' || inchar == '+' || inchar == '-')
   {

      switch(inchar)
      {
         case  '.'   :  if (dec_flag || e_flag) { invalid = 1; break; } 
                        else dec_flag = 1;
                        break;

         case  'e'   :
         case  'E'   :  if (e_flag) { invalid = 1; break; }
                        else e_flag = 1;
                        break;

         case  '+'   :  
         case  '-'   :  if (*(tmpptr-1) != 'E' && *(tmpptr-1) != 'e')
                        { invalid = 1; break; }
      }

      if (invalid) break;
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      if (inchar != EOF) (*num_read)++;
      w_counter--;
   }

   _uninpchar(inp, inchar);
   (*num_read)--;

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SPROC_STR  -  Copy a string from the input source to a temporary string  */
/*                                                                           */
/*    This function takes a string from the input source, and copies it      */
/*    into a temporary string, to be later assigned to a scanf argument.     */
/*                                                                           */
/*****************************************************************************/
static int _sproc_str(int w_counter, char (*_inpchar)(void **inp), 
                       void (*_uninpchar)(void **inp, char outchar), 
                       char *tmpptr, char conv, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char inchar;
   int bnum_read = *num_read;

   /*------------------------------------------------------------------------*/
   /*	If no precision was given for the %c conversion, set it to one.        */
   /*------------------------------------------------------------------------*/
   if ((conv == 'c') && (w_counter < 0)) w_counter = 1;

   /*------------------------------------------------------------------------*/
   /* Read in the next character, then while that character is not a white   */
   /* space character, a null terminator, an EOF character, and the field    */
   /* width has not been exceeded, copy it to the temporary string, and      */
   /* get another character.                                                 */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   while((conv == 'c' || !isspace(inchar)) && inchar != '\0' &&
         inchar != EOF && w_counter--)
   { 
      if (tmpptr) *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
   }
   
   /*------------------------------------------------------------------------*/
   /* The %s conversion specifies that a null terminator be placed at the    */
   /* end of the conversion.                                                 */
   /*------------------------------------------------------------------------*/
   if (conv == 's' && tmpptr) *tmpptr = '\0';

   _uninpchar(inp, inchar);
   (*num_read)--;

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SPROC_LB   -  Process the %[ conversion                                  */
/*                                                                           */
/*    This function copies characters from the input stream into a           */
/*    temporary string until it satisfies the field width, or encounters a   */
/*    character that is not in the scanset.  The scanset is defined as the   */
/*    characters passed between the left and right brackets.  If a '^' is    */
/*    first character after the left bracket, then the scanset is every      */
/*    character that is not listed between the two brackets.                 */
/*                                                                           */
/*****************************************************************************/
static int _sproc_lb(char (*_inpchar)(void **inp), 
                      void (*_uninpchar)(void **inp, char outchar),
                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char  inchar;
   int          bnum_read = *num_read;
   int          w_counter =  sfield->fwidth;
   int          test;

   inchar = _inpchar(inp);
   (*num_read)++;

   for (; w_counter != 0 && inchar != EOF; w_counter--)
   {
      test = (int)strrchr(sfield->scanset, inchar);
      if (_STCHK(sfield, _SFCIRC)) test = !test;
             
      if (test)
      {
         *(tmpptr++) = inchar;
         inchar = _inpchar(inp);
         (*num_read)++;
      }
      else
      {
         _uninpchar(inp, inchar);
         (*num_read)--;
         break;
      }
   }

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SSET_ARG   -  Assign the converted value to the next argument            */
/*                                                                           */
/*    This function takes a pointer to the result conversion string, and     */
/*    assigns it to the next argument.  The type of argument to be assigned  */
/*    is determined by the conversion specifier, and the h, l, or L flags    */
/*    if they were used.                                                     */
/*                                                                           */
/*****************************************************************************/
static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int base;

   /*------------------------------------------------------------------------*/
   /* Do the assignment only if the result string has a length greater than  */
   /* zero, and the '*' flag was not used                                    */
   /*------------------------------------------------------------------------*/
   if (tmpbuf[0] != '\0' && !_STCHK(sfield, _SFSTAR))
      switch(sfield->conv)
      {
         case  'i'   :
         case  'd'   :  base = (sfield->conv == 'd') ? 10 : 0;
   
                        switch(_STCHK(sfield, (_MFH | _MFL)))
                        {
                           case  _MFH  :  *(va_arg(*_ap, short int*)) =
                                          (short int)strtol(tmpbuf, NULL,
                                          base);
                                          break;

                           case _MFL   :  *(va_arg(*_ap, long int*)) =
                                          strtol(tmpbuf, NULL, base);
                                          break;

                           default     :  *(va_arg(*_ap, int*)) =
                                          (int)strtol(tmpbuf, NULL, base);
                                          break;
                        }
                        break;

      case  'p'   :
      case  'x'   :
      case  'u'   :
      case  'o'   :  base = (sfield->conv == 'u') ? 10 :
                            (sfield->conv == 'x' || sfield->conv == 'p') ? 16 :
                            8;

                     switch(_STCHK(sfield, (_MFH | _MFL)))
                     {
                        case _MFH : *(va_arg(*_ap, unsigned short int*))=
                                    (unsigned short int)strtoul(tmpbuf,
                                    NULL, base);
                                    break;

                        case _MFL : *(va_arg(*_ap, unsigned long int*)) =
                                    strtoul(tmpbuf, NULL, base);
                                    break;

                        default   : *(va_arg(*_ap, unsigned int*)) =
                                    (unsigned int)strtoul(tmpbuf, NULL,
                                    base);
                                    break;
                     }
                     break;

      case  'e'   :
      case  'f'   :
      case  'g'   :
      case  'E'   :
      case  'G'   :  switch(_STCHK(sfield, (_MFL | _MFLD)))
                     {
                        case _MFL : *(va_arg(*_ap, double*))=
                                    strtod(tmpbuf, NULL);
                                    break;

                        case _MFLD: *(va_arg(*_ap, long double*)) =
                                    (long double)strtod(tmpbuf, NULL);
                                    break;

                        default   : *(va_arg(*_ap, float*)) =
                                    (float)strtod(tmpbuf, NULL);
                                    break;
                     }
                     break;

   }
}


abs.c/          868562434   0     0     0       454       `
/****************************************************************************/
/*  abs labs v1.10#                                                         */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include "stdlib.h"

int abs(int i)
{
    if (i < 0) i = -i;
    return i;
}

long labs(long i)
{
    if (i < 0) i = -i;
    return i;
}

absd.c/         868562434   0     0     0       639       `
/****************************************************************************/
/*  absd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:01 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ABSF(REAL x)
{
   MSC(x) &= (char)(~(1<<(8 -1)));
   return x;
} /* ABSF */

absf.c/         868562434   0     0     0       639       `
/****************************************************************************/
/*  absf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:01 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ABSF(REAL x)
{
   MSC(x) &= (char)(~(1<<(8 -1)));
   return x;
} /* ABSF */

acos.c/         868562434   0     0     0       1889      `
/****************************************************************************/
/*  acos  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:41 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ACOSF(REAL x)
{

    {
    
       static REAL asin_consts[12] = /* max of 55 mantissa bits*/
         {KNST( 3.20113401984953224E-02), 
          KNST(-1.63844362782365558E-02), 
          KNST( 1.96423966100052853E-02), 
          KNST( 6.48085538386000953E-03), 
          KNST( 1.21816790811969532E-02), 
          KNST( 1.38830278305348564E-02), 
          KNST( 1.73599699654365820E-02), 
          KNST( 2.23717366032023795E-02), 
          KNST( 3.03819602714948831E-02), 
          KNST( 4.46428567912157295E-02), 
          KNST( 7.50000000040485847E-02), 
          KNST( 1.66666666666648389E-01)};

       REAL g, y, Result, z;

       ABSF2(y,x);

       if GTRF(y, HALF) 
       {
          if GTRF(y, ONE) { errno = EDOM; CPYF(y, ONE); }

          MPYF3(g, ADDF(SUBF(HALF,y), HALF), HALF);
          MPYF3(y, CNST(-2.0), SQRTF(g));

          POLYF(Result, g, asin_consts, 12 );

 	  ADDF3(Result, y,  MPYF(y, Result));
 	  if LEZF(x) 
             ADDF3(Result, ADDF(Pi_Over_Two, Result), Pi_Over_Two);
          else NEGF1(Result);

       } 
       else /* y < 0.5 */
       { 
          SQRF2(g,y);

          POLYF(Result, g, asin_consts, 12 );

          ADDF3(Result, y, MPYF(y, Result));
 	  if LEZF(x)
             ADDF3(Result, ADDF(Pi_Over_Four, Result), Pi_Over_Four);
          else
             ADDF3(Result, SUBF(Pi_Over_Four, Result), Pi_Over_Four);
       }
       return Result;
    }

} /*ACOSF*/

acosf.c/        868562434   0     0     0       1677      `
/****************************************************************************/
/*  acosf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:07 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ACOSF(REAL x)
{

    {
    
       /* NOTE: this is the table for 2**-23 error. */
       /* The lost precision is very small.         */
       /* The 2**-24 table has one extra term.      */
       
       static REAL asin_consts[4] = /* max of 23 mantissa bits */
         {KNST( 5.0505363E-02), 
          KNST( 3.9721134E-02), 
          KNST( 7.5464795E-02), 
          KNST( 1.6665163E-01)};

       REAL g, y, Result, z;

       ABSF2(y,x);

       if GTRF(y, HALF) 
       {
          if GTRF(y, ONE) { errno = EDOM; CPYF(y, ONE); }

          MPYF3(g, ADDF(SUBF(HALF,y), HALF), HALF);
          MPYF3(y, CNST(-2.0), SQRTF(g));

          POLYF(Result, g, asin_consts, 4 );

 	  ADDF3(Result, y,  MPYF(y, Result));
 	  if LEZF(x) 
             ADDF3(Result, ADDF(Pi_Over_Two, Result), Pi_Over_Two);
          else NEGF1(Result);

       } 
       else /* y < 0.5 */
       { 
          SQRF2(g,y);

          POLYF(Result, g, asin_consts, 4 );

          ADDF3(Result, y, MPYF(y, Result));
 	  if LEZF(x)
             ADDF3(Result, ADDF(Pi_Over_Four, Result), Pi_Over_Four);
          else
             ADDF3(Result, SUBF(Pi_Over_Four, Result), Pi_Over_Four);
       }
       return Result;
    }

} /*ACOSF*/

acosh.c/        868562434   0     0     0       1637      `
/****************************************************************************/
/*  acosh  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:41 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ACOSHF(REAL x)
{
   /* Taken from "Handbook of Mathematical Functions with Formulas, Graphs,  */
   /* and Mathematical Tables",                                              */
   /* Milton Abramowitz and Irene A. Stegun,                                 */
   /* National Bureau of Standards (Applied Mathematics Series 55),          */
   /* Washington D.C., 1964 (reprinted 1970). 4.6.21, page 87.               */

   REAL Result;

   if LSSF(x, ONE) { errno = EDOM; return ZERO; }

   /* Apply the identity: acosh(x) = log(x + sqrt(x*x - 1.0)).               */
   /* We need not compute sqrt(x*x - 1.0) if x*x is so big that the          */
   /* 1.0 term is lost.                                                      */
   /* The biggest positive number that can be held in REAL                   */
   /* that still has a 1's digit is RADIX**REAL_MANTISSA-1,                  */
   /* so the cut-off is about sqrt(2**REAL_MANTISSA) or                      */
   /* RADIX**(REAL_MANTISSA/2)                                               */
   if LSSF(x, CNST(67108864.0) )
      return LOGF(ADDF(x,SQRTF(SUBF(SQRF(x),ONE))));

   return ADDF(LOGF(x), Ln_2);

} /* ACOSF */

acoshf.c/       868562434   0     0     0       1634      `
/****************************************************************************/
/*  acoshf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:08 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ACOSHF(REAL x)
{
   /* Taken from "Handbook of Mathematical Functions with Formulas, Graphs,  */
   /* and Mathematical Tables",                                              */
   /* Milton Abramowitz and Irene A. Stegun,                                 */
   /* National Bureau of Standards (Applied Mathematics Series 55),          */
   /* Washington D.C., 1964 (reprinted 1970). 4.6.21, page 87.               */

   REAL Result;

   if LSSF(x, ONE) { errno = EDOM; return ZERO; }

   /* Apply the identity: acosh(x) = log(x + sqrt(x*x - 1.0)).               */
   /* We need not compute sqrt(x*x - 1.0) if x*x is so big that the          */
   /* 1.0 term is lost.                                                      */
   /* The biggest positive number that can be held in REAL                   */
   /* that still has a 1's digit is RADIX**REAL_MANTISSA-1,                  */
   /* so the cut-off is about sqrt(2**REAL_MANTISSA) or                      */
   /* RADIX**(REAL_MANTISSA/2)                                               */
   if LSSF(x, CNST(4096.0) )
      return LOGF(ADDF(x,SQRTF(SUBF(SQRF(x),ONE))));

   return ADDF(LOGF(x), Ln_2);

} /* ACOSF */
acot.c/         868562434   0     0     0       628       `
/****************************************************************************/
/*  acot  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:41 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ACOTF(REAL x)
{
   REAL Result;
   if EQZF(x) return Pi_Over_Two;
   Result = ATANF(INVF(x));
   if LSZF(Result) return ADDF(Result, Pi);
   return Result; 
} /* ACOTF */
acot2.c/        868562434   0     0     0       522       `
/****************************************************************************/
/*  acot2  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:42 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ACOT2F(REAL x, REAL y)
{
   return ATAN2F(y, x);
} /* ACOT2F */
acot2f.c/       868562434   0     0     0       523       `
/****************************************************************************/
/*  acot2f  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:09 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ACOT2F(REAL x, REAL y)
{
   return ATAN2F(y, x);
} /* ACOT2F */

acotf.c/        868562434   0     0     0       629       `
/****************************************************************************/
/*  acotf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:09 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ACOTF(REAL x)
{
   REAL Result;
   if EQZF(x) return Pi_Over_Two;
   Result = ATANF(INVF(x));
   if LSZF(Result) return ADDF(Result, Pi);
   return Result; 
} /* ACOTF */

acoth.c/        868562434   0     0     0       771       `
/****************************************************************************/
/*  acoth  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:42 EDT 1997 */

#ifndef _TI_ENHANCED_MATH_H
#define _TI_ENHANCED_MATH_H 1
#endif
#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ACOTHF(REAL x)
{
   if LSSF(ABSF(x),ONE) 
   {
      errno = (LSSF(ABSF(x),ONE) ? EDOM : ERANGE);
      if LSZF(x) return CNST(-1.7976931348623157e+308) ;
      return CNST( 1.7976931348623157e+308) ;
   }
   return ATANHF(INVF(x));
} /* ACOTHF */

acothf.c/       868562434   0     0     0       756       `
/****************************************************************************/
/*  acothf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:10 EDT 1997 */

#ifndef _TI_ENHANCED_MATH_H
#define _TI_ENHANCED_MATH_H 1
#endif
#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ACOTHF(REAL x)
{
   if LSSF(ABSF(x),ONE) 
   {
      errno = (LSSF(ABSF(x),ONE) ? EDOM : ERANGE);
      if LSZF(x) return CNST(-3.402823466E+38) ;
      return CNST( 3.402823466E+38) ;
   }
   return ATANHF(INVF(x));
} /* ACOTHF */
addd.c/         868562434   0     0     0       3042      `
/****************************************************************************/
/*  addd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:01 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ADDF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE floating add.  return left + right                                   */

/* Does *NOT* handle +/- INFINITY, NAN.                                      */

/* Does *NOT* handle denormalized numbers.                                   */

/*---------------------------------------------------------------------------*/
{

   /*------------------------------------------------------------------------*/
   /* The IEEE format is exactly as big as two int's (or two long's)         */
   /*------------------------------------------------------------------------*/

   int  lexp, rexp;
   REAL_2UNS lft, rgt;
   int  lsign, rsign;

   /*------------------------------------------------------------------------*/
   /* Unpack fraction and exponent, ignoring signs for now.                  */
   /* Reinsert hidden bit or re-normalize fraction as appropriate.           */
   /*------------------------------------------------------------------------*/
   lft.r = left; 
   rgt.r = right;

   lsign = lft.u.msh & MINUS;
   rsign = rgt.u.msh & MINUS;

   lexp = lft.u.msh - lsign;       /* remove sign bit but don't shift yet */
   rexp = rgt.u.msh - rsign;

   lft.u.msh = (lexp & REAL_FRC_MASK) + REAL_HIDDEN_BIT; /* - exp + hidden */
   if (!(lexp >>= (REAL_FRC_MSBs))) {

      if (rexp == 0) {                                  /* signed 0+0 rules */
         lft.r = left; rgt.u.msh &= lft.u.msh;
      }
      return rgt.r;

   }
   if (lsign) NEG2sCOMP(lft);                       /* make 2's complement */

   rgt.u.msh = (rexp & REAL_FRC_MASK) + REAL_HIDDEN_BIT; /* - exp + hidden */
   if (!(rexp >>= (REAL_FRC_MSBs))) {
   
      return left;
   
   }
   if (rsign) NEG2sCOMP(rgt);                       /* make 2's complement */
 
   lexp = FRCADDF(lexp, &lft, rexp, &rgt);

   /*-----------------------------------------------------------------------*/
   /* Check for overflow and underflow                                      */
   /*-----------------------------------------------------------------------*/
   if ((lexp -= 1) < 0) {    /* underflow */
   
         lft.r = 0.0;   /* no significant bits remain */
   }
   else if (lexp >= REAL_EXP_INFNAN-1) {        /* overflow */
   
      lft.u.msh = (lft.u.msh & MINUS) + REAL_INFNAN;
      lft.u.lsh = 0;
   
   }
   else lft.u.msh += (((int )lexp) << REAL_FRC_MSBs);

   return lft.r;

} /* ADDF */

addf.c/         868562434   0     0     0       4775      `
/****************************************************************************/
/*  addf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:02 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ADDF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE floating add.  return left + right                                   */

/* Does *NOT* handle +/- INFINITY, NAN.                                      */

/* Does *NOT* handle denormalized numbers.                                   */

/*---------------------------------------------------------------------------*/
{

   int  lft , rgt ; /* int register versions of left,right REAL params   */
   int  lfrc, rfrc; /* fraction of left/dest operand and right operand   */
   int    lexp, rexp; /* exponent of left/dest operand and right operand   */
   int  sign;
   int    expdif;

   /*------------------------------------------------------------------------*/
   /* Transfer the left,right bits to lft,rgt.                               */
   /* REALasINT may force left and right to memory if dumb compiler.         */
   /* This is OK since they won't be needed again except for unusual cases.  */
   /* lft,rgt will hopefully wind up in integer registers.                   */
   /*------------------------------------------------------------------------*/
   REALasINT(lft,left); 
   REALasINT(rgt,right);

   /*------------------------------------------------------------------------*/
   /* Unpack fraction and exponent, ignoring signs for now.                  */
   /* Reinsert hidden bit or re-normalize fraction as appropriate.           */
   /*------------------------------------------------------------------------*/

   if ((lfrc = lft & ~MINUS) == 0) {        /* signed 0 + 0 rules */
      rfrc = rgt;
      if ((rfrc & ~MINUS) == 0) rfrc &= lft;
      return_INTasREAL(rfrc);
   }
   if ((rfrc = rgt & ~MINUS) == 0) return left;

   if (lexp = lfrc >> REAL_FRC_MSBs)
      lfrc = (lfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT; /*insert hidden bit*/
   else

      return right;

   if (lft < 0) lfrc = -lfrc; /* make 2's complement */

   if (rexp = rfrc >> REAL_FRC_MSBs)
      rfrc = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT; /*insert hidden bit*/
   else

      return left;

   if (rgt < 0) rfrc = -rfrc;  /* make 2's complement */

   /*------------------------------------------------------------------------*/
   /* Shift fractions to align radix point and add.                          */
   /* Result has one rounding bit.                                           */
   /*------------------------------------------------------------------------*/
   lfrc <<= 1; rfrc <<= 1;
   if ((expdif = lexp - rexp) >= 0) {  /* |left| >= |right| */
       if (expdif <  23 +2) lfrc += (rfrc >> expdif);

   } else {                            /* |left| <  |right| */
       if (expdif > - 23 -2) rfrc += lfrc >> -expdif;
       lfrc = rfrc; lexp = rexp;
   }

   sign = 0;
   if (lfrc <= 0) { /* back to sign-magnitude */
      if (lfrc == 0) return_INTasREAL(lfrc);
      lfrc = -lfrc; sign = MINUS;
   }

   /*------------------------------------------------------------------------*/
   /* Round and normalize the result                                         */
   /*------------------------------------------------------------------------*/
   if (lfrc < REAL_HIDDEN_BIT*2) RENORM2F(lfrc, lexp);
   else {
      lfrc += 1;             /* biased rounding */
      if (lfrc >= (REAL_HIDDEN_BIT<<2)) {
          lfrc = ((lfrc -1) >> 1) +1; lexp += 1;
      }
   }

   /*------------------------------------------------------------------------*/
   /* Check for overflow and underflow                                       */
   /*------------------------------------------------------------------------*/
   if (lexp <= 0) { /* underflow? */

      lfrc = 0;  /* no significant bits remain */

      lexp = 0;
   }
   else if (lexp >= REAL_EXP_INFNAN) { /* overflow? */

      lexp = REAL_EXP_INFNAN; lfrc = 0;

   }

   /*------------------------------------------------------------------------*/
   /* Assemble result and return                                             */
   /*------------------------------------------------------------------------*/
   lfrc = ((lfrc>>1)& REAL_FRC_MASK) + (((int )lexp) << REAL_FRC_MSBs) +sign;

   return_INTasREAL(lfrc);


} /* ADDF */


asctime.c/      868562434   0     0     0       1001      `
/****************************************************************************/
/*  asctime v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h> 

extern int sprintf(char *_string, const char *_format, ...);

static const char *const day[7]  = { "Sun","Mon","Tue","Wed","Thu","Fri","Sat" };
static const char *const mon[12] = { "Jan","Feb","Mar","Apr","May","Jun", 
                                     "Jul","Aug","Sep","Oct","Nov","Dec" };
char *asctime(const struct tm *timeptr)
{
    struct tm   tptr = *timeptr;
    static char result[26];

    mktime(&tptr);      /* MAKE SURE THIS A SANE TIME */

    sprintf(result, "%s %s%3d %02d:%02d:%02d %d\n",
		    day[tptr.tm_wday], mon[tptr.tm_mon], tptr.tm_mday, 
		    tptr.tm_hour, tptr.tm_min, tptr.tm_sec,
		    tptr.tm_year + 1900);

    return (result);
}

asin.c/         868562434   0     0     0       1834      `
/****************************************************************************/
/*  asin  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:43 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ASINF(REAL x)
{

    {
    
        static REAL asin_consts[12] = /* max of 55 mantissa bits*/
          {KNST( 3.20113401984953224E-02), 
           KNST(-1.63844362782365558E-02), 
           KNST( 1.96423966100052853E-02), 
           KNST( 6.48085538386000953E-03), 
           KNST( 1.21816790811969532E-02), 
           KNST( 1.38830278305348564E-02), 
           KNST( 1.73599699654365820E-02), 
           KNST( 2.23717366032023795E-02), 
           KNST( 3.03819602714948831E-02), 
           KNST( 4.46428567912157295E-02), 
           KNST( 7.50000000040485847E-02), 
           KNST( 1.66666666666648389E-01)};

        REAL g, y, Result, z;

        ABSF2(y,x);

        if GTRF(y, HALF) 
        {
           if GTRF(y, ONE) { errno = EDOM; CPYF(y, ONE); }

           MPYF3(g, ADDF(SUBF(HALF,y), HALF), HALF);
           MPYF3(y, CNST(-2.0), SQRTF(g));

           POLYF(Result, g, asin_consts, 12 );

           /* Result = (Pi_Over_Four + (y + y*Result)) + Pi_Over_Four; */
           ADDF3(Result,
                 ADDF(Pi_Over_Four,
                      ADDF(y,MPYF(y,Result))),
                 Pi_Over_Four);
       } 
       else  /* y < 0.5 */
       {
          SQRF2(g,y);
          POLYF(Result, g, asin_consts, 12 );

          ADDF3(Result, y, MPYF(y, Result));
       }
       if LSZF(x) NEGF1(Result);
       return Result;
    }

} /* ASINF */

asinf.c/        868562434   0     0     0       1618      `
/****************************************************************************/
/*  asinf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:11 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ASINF(REAL x)
{

    {
    
        /* NOTE: this is the table for 2**-23 error. */
        /* The lost precision is very small.         */
        /* The 2**-24 table has one extra term.      */
        
        static REAL asin_consts[4] = /* max of 23 mantissa bits */
          {KNST( 5.0505363E-02), 
           KNST( 3.9721134E-02), 
           KNST( 7.5464795E-02), 
           KNST( 1.6665163E-01)};

        REAL g, y, Result, z;

        ABSF2(y,x);

        if GTRF(y, HALF) 
        {
           if GTRF(y, ONE) { errno = EDOM; CPYF(y, ONE); }

           MPYF3(g, ADDF(SUBF(HALF,y), HALF), HALF);
           MPYF3(y, CNST(-2.0), SQRTF(g));

           POLYF(Result, g, asin_consts, 4 );

           /* Result = (Pi_Over_Four + (y + y*Result)) + Pi_Over_Four; */
           ADDF3(Result,
                 ADDF(Pi_Over_Four,
                      ADDF(y,MPYF(y,Result))),
                 Pi_Over_Four);
       } 
       else  /* y < 0.5 */
       {
          SQRF2(g,y);
          POLYF(Result, g, asin_consts, 4 );

          ADDF3(Result, y, MPYF(y, Result));
       }
       if LSZF(x) NEGF1(Result);
       return Result;
    }

} /* ASINF */

asinh.c/        868562434   0     0     0       2273      `
/****************************************************************************/
/*  asinh  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:44 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ASINHF(REAL x)
{
   /* Taken from "Handbook of Mathematical Functions with Formulas, Graphs,  */
   /* and Mathematical Tables",                                              */
   /* Milton Abramowitz and Irene A. Stegun,                                 */
   /* National Bureau of Standards (Applied Mathematics Series 55),          */
   /* Washington D.C., 1964 (reprinted 1970). 4.6.20, page 87.               */

   static REAL asinh_consts[11] = /* max of 56 mantissa bits */
     {KNST(-2.16989595698168691E-03), 
      KNST( 5.77365635202187448E-03), 
      KNST(-8.89613248556152165E-03), 
      KNST( 1.13604085054945323E-02), 
      KNST(-1.39361311669709167E-02), 
      KNST( 1.73498471338541638E-02), 
      KNST(-2.23719621474302462E-02), 
      KNST( 3.03819359645514891E-02), 
      KNST(-4.46428569265288321E-02), 
      KNST( 7.49999999971403928E-02), 
      KNST(-1.66666666666651829E-01)};

   REAL g, Result;

   ABSF2(g,x);
   if GTRF(g, HALF)
   {
      /* Apply the identity: asinh(x) = log(x + sqrt(x*x + 1.0)).         */
      /* We need not compute sqrt(x*x + 1.0) if x*x is so big that the    */
      /* 1.0 term is lost.                                                */
      /* The biggest positive number that can be held in REAL             */
      /* that still has a 1's digit is RADIX**REAL_MANTISSA -1,           */
      /* so the cut-off is about sqrt(RADIX**REAL_MANTISSA) or            */
      /* RADIX**(REAL_MANTISSA/2)                                         */

      if LSSF(g, CNST(67108864.0) )
         CPYF(Result, LOGF(ADDF(g,SQRTF(ADDF(SQRF(x),ONE)))));
      else ADDF3(Result,LOGF(g),Ln_2);
      if LSZF(x) NEGF1(Result);
      return Result;
   }

   SQRF2(g, x);
   POLYF(Result, g, asinh_consts, 11 );

   return ADDF(x,MPYF(x,Result));
} /* ASINHF */

asinhf.c/       868562434   0     0     0       1959      `
/****************************************************************************/
/*  asinhf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:11 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ASINHF(REAL x)
{
   /* Taken from "Handbook of Mathematical Functions with Formulas, Graphs,  */
   /* and Mathematical Tables",                                              */
   /* Milton Abramowitz and Irene A. Stegun,                                 */
   /* National Bureau of Standards (Applied Mathematics Series 55),          */
   /* Washington D.C., 1964 (reprinted 1970). 4.6.20, page 87.               */

   static REAL asinh_consts[4] = /* max of 25 mantissa bits */
     {KNST( 1.98887612E-02), 
      KNST(-4.25708399E-02), 
      KNST( 7.48242149E-02), 
      KNST(-1.66661337E-01)};

   REAL g, Result;

   ABSF2(g,x);
   if GTRF(g, HALF)
   {
      /* Apply the identity: asinh(x) = log(x + sqrt(x*x + 1.0)).         */
      /* We need not compute sqrt(x*x + 1.0) if x*x is so big that the    */
      /* 1.0 term is lost.                                                */
      /* The biggest positive number that can be held in REAL             */
      /* that still has a 1's digit is RADIX**REAL_MANTISSA -1,           */
      /* so the cut-off is about sqrt(RADIX**REAL_MANTISSA) or            */
      /* RADIX**(REAL_MANTISSA/2)                                         */

      if LSSF(g, CNST(4096.0) )
         CPYF(Result, LOGF(ADDF(g,SQRTF(ADDF(SQRF(x),ONE)))));
      else ADDF3(Result,LOGF(g),Ln_2);
      if LSZF(x) NEGF1(Result);
      return Result;
   }

   SQRF2(g, x);
   POLYF(Result, g, asinh_consts, 4 );

   return ADDF(x,MPYF(x,Result));
} /* ASINHF */

assert.c/       868562434   0     0     0       1522      `
/****************************************************************************/
/*  assert   v1.10#                                                         */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

/****************************************************************************/
/* _ASSERT() - Implements the assert macro. Checks the argument. Aborts     */
/*             with a message if not true.                                  */
/****************************************************************************/
void _assert(int expr, char *string)
{
    if (!expr) _abort_msg(string);
}

/****************************************************************************/
/* _NASSERT() - Special version of assert, which assumes the expression is  */
/*              true.                                                       */
/****************************************************************************/
void _nassert(int expr)
{
    return;
}

/****************************************************************************/
/* _ABORT_MSG() - Write out a string and never return.  Abort function for  */
/*                false assertions.                                         */
/****************************************************************************/
void _abort_msg(char *string)
{
    fprintf(stderr,"%s",string);
    abort();
}
atan.c/         868562434   0     0     0       1830      `
/****************************************************************************/
/*  atan  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:44 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ATANF(REAL y)
{
    
    REAL f, g, Result;
    int n;

    ABSF2(f,y);

    n = 0;
    if GTRF(f, ONE) { INVF1(f); n = 2; }

    if GTRF(f, CNST(0.26794919243112270647) ) 
    {
       DIVF3(f, ADDF(SUBF(SUBF(MPYF(CNST(0.73205080756887729353) ,f),HALF),HALF),f),
                ADDF(Sqrt_3,f));
       n += 1;
    }

    SQRF2(g, f);

    {
    
       static REAL arctan_consts[8] = /* max of 55 mantissa bits */
         {KNST( 4.43866445452355097E-02), 
          KNST(-6.48311114205796814E-02), 
          KNST( 7.67935909024826520E-02), 
          KNST(-9.09037055918752267E-02), 
          KNST( 1.11110978784541423E-01), 
          KNST(-1.42857141024675987E-01), 
          KNST( 1.99999999987262364E-01), 
          KNST(-3.33333333333299198E-01)};

       POLYF(Result, g, arctan_consts, 8 );
    }

    ADDF3(Result, f, MPYF(f,Result));

    {
       static REAL A[4] =
         {KNST(0.0),
          KNST(3.14159265358979323846264338327950288419716939937510/6.0),
          KNST(3.14159265358979323846264338327950288419716939937510/2.0),
          KNST(3.14159265358979323846264338327950288419716939937510/3.0)};

       if GEZF(y)
          if (n > 1) RSBF2(Result, A[n]);
          else       ADDF2(Result, A[n]);
       else if (n > 1) SUBF2(Result, A[n]);
       else            SUBF3(Result, NEGF(Result), A[n]);
    }

    return Result;

} /* ATANF */
atan2.c/        868562434   0     0     0       1204      `
/****************************************************************************/
/*  atan2  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:45 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ATAN2F(REAL y, REAL x)
{
   REAL    Result, yf, xf, z;
   EXPONENT_TYPE yn, xn;

   if EQZF(x) 
   {
      if EQZF(y) { errno = EDOM; return ZERO; }
      else Result = Pi_Over_Two;
   }
   else 
   {
      /* Will the divide overflow?                 */
      /* Can be slightly conservative since        */
      /* atan(x) is about pi/2 for any x >= 2**big */
      RIPF(y, yf, yn);
      RIPF(x, xf, xn);
      /* max float is 2#.111..#Emax.  Use Emax-2 for safety */
      if ((yn - xn) > 1024 -2) 
         CPYF(Result, Pi_Over_Two);
      else 
      {
         DIVF3(Result,y,x);
         CPYF(Result, ATANF(ABSF(Result)));
         if LSZF(x) RSBF2(Result, Pi);
      }
   }
   if LSZF(y) NEGF1(Result);
   return Result;
} /* ATAN2F */
atan2f.c/       868562434   0     0     0       1204      `
/****************************************************************************/
/*  atan2f  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:12 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ATAN2F(REAL y, REAL x)
{
   REAL    Result, yf, xf, z;
   EXPONENT_TYPE yn, xn;

   if EQZF(x) 
   {
      if EQZF(y) { errno = EDOM; return ZERO; }
      else Result = Pi_Over_Two;
   }
   else 
   {
      /* Will the divide overflow?                 */
      /* Can be slightly conservative since        */
      /* atan(x) is about pi/2 for any x >= 2**big */
      RIPF(y, yf, yn);
      RIPF(x, xf, xn);
      /* max float is 2#.111..#Emax.  Use Emax-2 for safety */
      if ((yn - xn) > 128 -2) 
         CPYF(Result, Pi_Over_Two);
      else 
      {
         DIVF3(Result,y,x);
         CPYF(Result, ATANF(ABSF(Result)));
         if LSZF(x) RSBF2(Result, Pi);
      }
   }
   if LSZF(y) NEGF1(Result);
   return Result;
} /* ATAN2F */
atanf.c/        868562434   0     0     0       1652      `
/****************************************************************************/
/*  atanf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:12 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ATANF(REAL y)
{
    
    REAL f, g, Result;
    int n;

    ABSF2(f,y);

    {
       /* Adapted from "Software Manual for the Elementary Functions"   */
       /* Cody and Waite, Prentice Hall 1980. pages 150-163             */
       /* And from "Handbook of Mathematical Functions with Formulas,   */
       /* Graphs, and Mathematical Tables",                             */
       /* Milton Abramowitz and Irene A. Stegun,                        */
       /* National Bureau of Standards (Applied Mathematics Series 55), */
       /* Washington D.C., 1964 (reprinted 1970). 4.4.49, page 81       */

       static REAL arctan_consts[8] =
         {KNST( 0.0028662257),
          KNST(-0.0161657367),
          KNST( 0.0429096138),
          KNST(-0.0752896400),
          KNST( 0.1065626393),
          KNST(-0.1420889944),
          KNST( 0.1999355085),
          KNST(-0.3333314528)};
    
       n = 0;
       if GTRF(f, ONE) { NEGF2(f, INVF(f)); n = 2; }

       SQRF2(g,f);

       POLYF(Result, g, arctan_consts, 8 );
       ADDF3(Result, f, MPYF(f, Result));

       if NEZF(n) ADDF2(Result, Pi_Over_Two);
       if LSZF(y) NEGF1(Result);
       return Result;
    }

} /* ATANF */
atanh.c/        868562434   0     0     0       2043      `
/****************************************************************************/
/*  atanh  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:45 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ATANHF(REAL x)
{
   /* Taken from "Handbook of Mathematical Functions                        */
   /* with Formulas, Graphs and Mathematical Tables",                       */
   /* Milton Abramowitz and Irene A. Stegun,                                */
   /* National Bureau of Standards (Applied Mathematics Series 55),         */
   /* Washington D.C., 1964 (reprinted 1970). 4.6.22, page 87.              */

    static REAL atanh_consts[12] = /* max of 53 mantissa bits */
      {KNST( 2.1228942626427469E-01), 
       KNST(-1.1748303955885372E-01), 
       KNST( 1.2434577315837858E-01), 
       KNST( 3.0206143982156029E-02), 
       KNST( 6.3136302499099010E-02), 
       KNST( 6.6105770662158143E-02), 
       KNST( 7.6972523228749300E-02), 
       KNST( 9.0906189426936578E-02), 
       KNST( 1.1111121987477515E-01), 
       KNST( 1.4285714043936430E-01), 
       KNST( 2.0000000002784950E-01), 
       KNST( 3.3333333333320755E-01)};

   REAL g, Result, One_Plus_G, One_Minus_G;

   ABSF2(g,x);
   if GTRF(g,HALF) 
   {
      if GEQF(g,ONE)
      {
         errno = (EQLF(g,ONE) ? ERANGE : EDOM);
         if GEQF(x,ONE) return CNST( 1.7976931348623157e+308) ;
         return CNST(-1.7976931348623157e+308) ;
      } else CPYF(g,x);

      /* Apply the identity: atanh(x) = 0.5 * log((1.0 + x) / (1.0 - x)) */
      ADDF3(One_Minus_G, SUBF(HALF,g), HALF);
      ADDF3(One_Plus_G , ADDF(HALF,g), HALF);
      return MPYF(HALF,LOGF(DIVF(One_Plus_G,One_Minus_G)));
   }

   SQRF2(g,x);

   POLYF(Result,g,atanh_consts,12 );

   return ADDF(x,MPYF(x,Result));

} /* ATANHF */

atanhf.c/       868562434   0     0     0       1713      `
/****************************************************************************/
/*  atanhf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:13 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ATANHF(REAL x)
{
   /* Taken from "Handbook of Mathematical Functions                        */
   /* with Formulas, Graphs and Mathematical Tables",                       */
   /* Milton Abramowitz and Irene A. Stegun,                                */
   /* National Bureau of Standards (Applied Mathematics Series 55),         */
   /* Washington D.C., 1964 (reprinted 1970). 4.6.22, page 87.              */

    static REAL atanh_consts[5] = /* max of 25 mantissa bits */
      {KNST( 1.83766196E-01), 
       KNST( 8.10419885E-02), 
       KNST( 1.47040305E-01), 
       KNST( 1.99744113E-01), 
       KNST( 3.33338978E-01)};

   REAL g, Result, One_Plus_G, One_Minus_G;

   ABSF2(g,x);
   if GTRF(g,HALF) 
   {
      if GEQF(g,ONE)
      {
         errno = (EQLF(g,ONE) ? ERANGE : EDOM);
         if GEQF(x,ONE) return CNST( 3.402823466E+38) ;
         return CNST(-3.402823466E+38) ;
      } else CPYF(g,x);

      /* Apply the identity: atanh(x) = 0.5 * log((1.0 + x) / (1.0 - x)) */
      ADDF3(One_Minus_G, SUBF(HALF,g), HALF);
      ADDF3(One_Plus_G , ADDF(HALF,g), HALF);
      return MPYF(HALF,LOGF(DIVF(One_Plus_G,One_Minus_G)));
   }

   SQRF2(g,x);

   POLYF(Result,g,atanh_consts,5 );

   return ADDF(x,MPYF(x,Result));

} /* ATANHF */

atof.c/         868562434   0     0     0       419       `
/****************************************************************************/
/*  atof v1.10#                                                             */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include "stdlib.h"

double atof(const char *st)
{
    return strtod(st, (char **)0);
}

atoi.c/         868562434   0     0     0       796       `
/****************************************************************************/
/*  atoi v1.10#                                                             */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <stdlib.h>
#include <ctype.h>

int atoi(register const char *st)
{
    register long result = 0;
    register char cp;
    register int  sign;

    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *st) == '-')) cp = *++st;
    else if (cp == '+')             cp = *++st;

    while (_isdigit(cp))
    {
        result *= 10;
        result += cp - '0';
        cp = *++st;
    }

    if (sign) result *= -1;
    return result;
}

atol.c/         868562434   0     0     0       412       `
/****************************************************************************/
/*  atol v1.10#                                                             */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <stdlib.h>

long atol(register const char *st)
{
    return atoi(st);
}
autoinit.c/     868562434   0     0     0       1113      `
/*****************************************************************************/
/* AUTO_INIT()   v1.10# - Perform initialization of C variables.             */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                  */
/*****************************************************************************/
#include <assert.h>
#define COPY_TYPE  unsigned int
#define COPY_SIZE  4


#define ALIGN_MASK (COPY_SIZE-1)


void auto_init(const void *cinit)
{
   const unsigned int *recptr = cinit;
   unsigned int        length;

   if ((int)recptr == -1) return;

   while ((length = *recptr++) != 0)
   {
      COPY_TYPE       *to   = (COPY_TYPE *) *recptr++; 
      const COPY_TYPE *from = (COPY_TYPE *)  recptr; 

      for ( ; length >= COPY_SIZE; length -= COPY_SIZE) *to++ = *from++;

      if (length > 0)  
      {
         char       *cto   = (char *) to; 
	 const char *cfrom = (char *) from;

	 _nassert(length < COPY_SIZE);

	 while (length-- > 0) *cto++ = *cfrom++;
	 recptr = (unsigned *)(((unsigned)cfrom + ALIGN_MASK) & ~ALIGN_MASK);
      }
      else
	 recptr = (unsigned *)from;
   }
}

boot.c/         868562434   0     0     0       3509      `
/*****************************************************************************/
/* BOOT.C   v1.10# - Initialize the C60 C runtime environment                */
/* Copyright (c) 1993-1977  Texas Instruments Incorporated                   */
/*****************************************************************************/
extern void main(), exit(), auto_init();

/*---------------------------------------------------------------------------*/
/* ALLOCATE THE MEMORY FOR THE SYSTEM STACK.  THIS SECTION WILL BE SIZED     */
/* BY THE LINKER.                                                            */
/*---------------------------------------------------------------------------*/
asm(" .global __STACK_SIZE");
asm(" .global __stack");
asm("__stack: .usect   .stack, 0, 8");

/*****************************************************************************/
/* C_INT00() - C ENVIRONMENT ENTRY POINT                                     */
/*****************************************************************************/
extern void interrupt c_int00()
{
   /*------------------------------------------------------------------------*/
   /* SET UP THE STACK POINTER IN B15.                                       */
   /* THE STACK POINTER POINTS 1 WORD PAST THE TOP OF THE STACK, SO SUBTRACT */
   /* 1 WORD FROM THE SIZE.                                                  */
   /*------------------------------------------------------------------------*/
   asm("      mvk  __stack,SP");
   asm("      mvkh __stack,SP");
   asm("      mvk  __STACK_SIZE - 4,B0");
   asm("      mvkh __STACK_SIZE - 4,B0");
   asm("      add  B0,SP,SP");

   /*------------------------------------------------------------------------*/
   /* THE SP MUST BE ALIGNED ON AN 8-BYTE BOUNDARY.                          */
   /*------------------------------------------------------------------------*/
   asm("      and  ~7,SP,SP");               

   /*------------------------------------------------------------------------*/
   /* SET UP THE GLOBAL PAGE POINTER IN B14.                                 */
   /*------------------------------------------------------------------------*/
   asm("      .global $bss");
   asm("      mvk  $bss,DP");
   asm("      mvkh $bss,DP");

   /*------------------------------------------------------------------------*/
   /* SET UP FLOATING POINT REGISTERS FOR C70 ONLY                           */
   /*------------------------------------------------------------------------*/

   /*------------------------------------------------------------------------*/
   /* GET THE POINTER TO THE AUTOINITIALIZATION TABLES INTO THE FIRST        */
   /* ARGUMENT REGISTER (A4), AND CALL A FUNCTION TO PERFORM                 */
   /* AUTOINITIALIZATION.                                                    */
   /*------------------------------------------------------------------------*/
   asm("      .global cinit");
   asm("      mvk  cinit,A4");
   asm("      mvkh cinit,A4");

   auto_init();

   /*------------------------------------------------------------------------*/
   /* CALL THE USER'S PROGRAM.                                               */
   /*------------------------------------------------------------------------*/
   main();

   /*------------------------------------------------------------------------*/
   /* CALL EXIT.                                                             */
   /*------------------------------------------------------------------------*/
   exit(1);
}

bsearch.c/      868562434   0     0     0       1199      `
/****************************************************************************/
/*  bsearch v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include "stdlib.h"

void *bsearch(register const void *key,     /* ITEM TO SEARCH FOR           */
              register const void *base,    /* POINTER TO ARRAY OF ELEMENTS */
              size_t nmemb,                 /* NUMBER OF ELEMENTS TO SORT   */
              size_t size,                  /* SIZE IN BYTES OF EACH ITEM   */
              int (*compar)(const void *,const void *)) /* COMPARE FUNCTION */

{
   register int i       = 0;             /* left scan index  */
   register int j       = nmemb - 1;     /* right scan index */

   while( i <= j )
   {
      register int pivot = (j + i) / 2;            
      int result = (*compar) (key, (char *)base + (pivot * size));
      if (result == 0) return((char *)base + (pivot * size));
      if (result < 0) j = pivot - 1;
		 else i = pivot + 1;
   }

   return ((void *)0);   /* IF WE GET TO HERE, WE FAILED */
}



ceil.c/         868562434   0     0     0       564       `
/****************************************************************************/
/*  ceil  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:46 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL CEILF(REAL x)
{

   {
      REAL y;
      return (GTZF(MODFF(x,&y)) ? ADDF(y,ONE) : y);
   }
} /* CEILF */
ceilf.c/        868562434   0     0     0       565       `
/****************************************************************************/
/*  ceilf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:14 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL CEILF(REAL x)
{

   {
      REAL y;
      return (GTZF(MODFF(x,&y)) ? ADDF(y,ONE) : y);
   }
} /* CEILF */

clearerr.c/     868562434   0     0     0       868       `
/*****************************************************************************/
/*  CLEARERR.C v1.10#                                                        */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <stdio.h>


/*****************************************************************************/
/* CLEARERR -  Clear the I/O error flag (_STATERR)                           */
/*                                                                           */
/*    This function calls a macro defined in stdio.h                         */
/*                                                                           */
/*****************************************************************************/
void clearerr(FILE *_fp) { _clearerr(_fp); }

clock.c/        868562434   0     0     0       1060      `
/****************************************************************************/
/*  clock v1.10#                                                            */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/****************************************************************************/
/* OBVIOUSLY, THIS IS SIMPLY A STUB, WHICH BY DEFINITION RETURNS -1         */
/* IF THE SYSTEM TIME IS UNAVAILABLE.                                       */ 
/*--------------------------------------------------------------------------*/
/* OBVIOUSLY, THIS IS NO LONGER A STUB.  THIS WILL RETURN THE CLK REGISTER  */
/* FROM THE EMULATOR OR SIMULATOR.  THIS IS A CYCLE ACURATE COUNT OF THE    */ 
/* NUMBER OF CYCLES THAT HAVE ELAPSED SINCE THE START OF THE PROGRAM.       */ 
/****************************************************************************/
#include <time.h> 
extern clock_t HOSTclock();

clock_t clock(void)   
{
    return (clock_t)HOSTclock();
}
cmpd.c/         868562434   0     0     0       12102     `
/****************************************************************************/
/*  cmpd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:02 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

int CMPF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE floating compare.                                                    */
/*                                                                           */

/* return <0 if left <  right                                                */
/* return  0 if left == right                                                */
/* return >0 if left >  right                                                */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY.                                                     */
/*                                                                           */

/* Returns |NAN| > |INFINITY|                                                */

/*---------------------------------------------------------------------------*/
{ 

   REAL_2UNS lft, rgt;
   int  l,r;

   lft.r =  left; l = lft.u.msh;
   rgt.r = right; r = rgt.u.msh;

   if ((l^r) < 0) {                           /* different signs?            */
      if (((l | r) == MINUS) &&               /* one is zero or denorm       */
          ((lft.u.lsh | rgt.u.lsh) == 0))     /* filter denorms              */
         return 0;                            /* 0 == 0, ignoring signs      */
      l |= 1;                                 /* make sure l != 0            */
   } else {                                   /* same signs                  */
      l -= r;
      if (l==0) {                             /* msh bits equal (uncommon)   */
         unsigned  ul = lft.u.lsh;
         unsigned  ur = rgt.u.lsh;
         l = (ul < ur) ? -1 : (ul != ur);     /*l indicates magnitude compare*/
      }
      if (r < 0) l = -l;                      /* deal with sign-magnitude    */
   }

   return l;
 
} /* CMPF */


int EQLF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE equals                                                               */
/* return (left == right)                                                    */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{ 

   REAL_2UNS lft, rgt;
   int  l,r;

   lft.r =  left; l = lft.u.msh;
   rgt.r = right; r = rgt.u.msh;

   if ((l^r) < 0)                             /* different signs?            */
      return (((l | r) == MINUS) &&
              ((lft.u.lsh | rgt.u.lsh) == 0));/* 0 == 0, ignoring signs      */
   if ((l != r) || (lft.u.lsh != rgt.u.lsh))  /* not equal if bits not same  */
      return 0;
   l &= ~MINUS;                               /* remove sign bit             */
   if (l < REAL_INFNAN) return 1;             /* equal if not INFINITY, NAN  */
   if (l > REAL_INFNAN) return 0;             /* not equal if NAN            */
   return (lft.u.lsh == 0);                   /* equal if INFINITY           */

} /* EQLF */


int NEQF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE not equals                                                           */
/* return (left != right)                                                    */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{

   REAL_2UNS lft, rgt;
   int  l,r;

   lft.r =  left; l = lft.u.msh;
   rgt.r = right; r = rgt.u.msh;

   if ((l^r) < 0)                             /* different signs?            */
      return (((l | r) != MINUS) ||
              ((lft.u.lsh | rgt.u.lsh) != 0));/* 0 == 0, ignoring signs      */
   if ((l != r) || (lft.u.lsh != rgt.u.lsh))  /* not equal if bits not same  */
      return 1;
   l &= ~MINUS;                               /* remove sign bit             */
   if (l < REAL_INFNAN) return 0;             /* equal if not INFINITY, NAN  */
   if (l > REAL_INFNAN) return 1;             /* not equal if NAN            */
   return (lft.u.lsh != 0);                   /* equal if INFINITY           */

} /* NEQF */


int LSSF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE less than                                                            */
/* return (left < right)                                                     */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{ 

   REAL_2UNS lft, rgt;
   int  l,r;

   lft.r =  left; l = lft.u.msh;
   rgt.r = right; r = rgt.u.msh;

   if ((l & ~MINUS) >= REAL_INFNAN) {  /*NAN's are unordered */
      if ((l & ~MINUS) > REAL_INFNAN) return 0;
      if (lft.u.lsh != 0) return 0;
   }
   if ((r & ~MINUS) >= REAL_INFNAN) {  /*NAN's are unordered */
      if ((r & ~MINUS) > REAL_INFNAN) return 0;
      if (rgt.u.lsh != 0) return 0;
   }

   if ((l^r) < 0) {                           /* different signs?            */
      if (((l | r) == MINUS) &&
          ((lft.u.lsh | rgt.u.lsh) == 0))
         return 0;                            /* 0 == 0, ignoring signs      */
   } else {                                   /* same signs                  */
      l -= r;
      if (l==0) {                             /* msh bits equal (uncommon)   */
         unsigned  ul = lft.u.lsh;
         unsigned  ur = rgt.u.lsh;
         l = (ul < ur) ? -1 : (ul != ur);     /*l indicates magnitude compare*/
      }
      if (r < 0) l = -l;                      /* deal with sign-magnitude    */
   }
   return (l < 0);

} /* LSSF */


int GTRF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE greater than                                                         */
/* return (left > right)                                                     */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{ 

   REAL_2UNS lft, rgt;
   int  l,r;

   lft.r =  left; l = lft.u.msh;
   rgt.r = right; r = rgt.u.msh;

   if ((l & ~MINUS) >= REAL_INFNAN) {  /*NAN's are unordered */
      if ((l & ~MINUS) > REAL_INFNAN) return 0;
      if (lft.u.lsh != 0) return 0;
   }
   if ((r & ~MINUS) >= REAL_INFNAN) {  /*NAN's are unordered */
      if ((r & ~MINUS) > REAL_INFNAN) return 0;
      if (rgt.u.lsh != 0) return 0;
   }

   if ((l^r) < 0) {                           /* different signs?            */
      if (((l | r) == MINUS) &&
          ((lft.u.lsh | rgt.u.lsh) == 0))
         return 0;                            /* 0 == 0, ignoring signs      */
      l |= 1;                                 /* make sure l != 0            */
   } else {                                   /* same signs                  */
      l -= r;
      if (l==0) {                             /* msh bits equal (uncommon)   */
         unsigned  ul = lft.u.lsh;
         unsigned  ur = rgt.u.lsh;
         l = (ul < ur) ? -1 : (ul != ur);     /*l indicates magnitude compare*/
      }
      if (r < 0) l = -l;                      /* deal with sign-magnitude    */
   }
   return (l > 0);

} /* GTRF */


int LEQF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE less than or equals                                                  */
/* return (left <= right)                                                    */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{

   REAL_2UNS lft, rgt;
   int  l,r;

   lft.r =  left; l = lft.u.msh;
   rgt.r = right; r = rgt.u.msh;

   if ((l & ~MINUS) >= REAL_INFNAN) {  /*NAN's are unordered */
      if ((l & ~MINUS) > REAL_INFNAN) return 0;
      if (lft.u.lsh != 0) return 0;
   }
   if ((r & ~MINUS) >= REAL_INFNAN) {  /*NAN's are unordered */
      if ((r & ~MINUS) > REAL_INFNAN) return 0;
      if (rgt.u.lsh != 0) return 0;
   }

   if ((l^r) < 0) {                           /* different signs?            */
      if (((l | r) == MINUS) &&
          ((lft.u.lsh | rgt.u.lsh) == 0))
         return 1;                            /* 0 == 0, ignoring signs      */
      l |= 1;                                 /* make sure l != 0            */
   } else {                                   /* same signs                  */
      l -= r;
      if (l==0) {                             /* msh bits equal (uncommon)   */
         unsigned  ul = lft.u.lsh;
         unsigned  ur = rgt.u.lsh;
         l = (ul < ur) ? -1 : (ul != ur);     /*l indicates magnitude compare*/
      }
      if (r < 0) l = -l;                      /* deal with sign-magnitude    */
   }
   return (l <= 0);

} /* LEQF */


int GEQF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE greater than or equal                                                */
/* return (left >= right)                                                    */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{ 

   REAL_2UNS lft, rgt;
   int  l,r;

   lft.r =  left; l = lft.u.msh;
   rgt.r = right; r = rgt.u.msh;

   if ((l & ~MINUS) >= REAL_INFNAN) {  /*NAN's are unordered */
      if ((l & ~MINUS) > REAL_INFNAN) return 0;
      if (lft.u.lsh != 0) return 0;
   }
   if ((r & ~MINUS) >= REAL_INFNAN) {  /*NAN's are unordered */
      if ((r & ~MINUS) > REAL_INFNAN) return 0;
      if (rgt.u.lsh != 0) return 0;
   }

   if ((l^r) < 0) {                           /* different signs?            */
      if (((l | r) == MINUS) &&
          ((lft.u.lsh | rgt.u.lsh) == 0))
         return 1;                            /* 0 == 0, ignoring signs      */
   } else {                                   /* same signs                  */
      l -= r;
      if (l==0) {                             /* msh bits equal (uncommon)   */
         unsigned  ul = lft.u.lsh;
         unsigned  ur = rgt.u.lsh;
         l = (ul < ur) ? -1 : (ul != ur);     /*l indicates magnitude compare*/
      }
      if (r < 0) l = -l;                      /* deal with sign-magnitude    */
   }
   return (l >= 0);

} /* GEQF */

cmpf.c/         868562434   0     0     0       9069      `
/****************************************************************************/
/*  cmpf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:03 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

int CMPF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE floating compare.                                                    */
/*                                                                           */

/* return <0 if left <  right                                                */
/* return  0 if left == right                                                */
/* return >0 if left >  right                                                */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY.                                                     */
/*                                                                           */

/* Returns |NAN| > |INFINITY|                                                */

/*---------------------------------------------------------------------------*/
{ 

   int  lft;
   int  rgt;
   REALasINT(lft, left);
   REALasINT(rgt, right);

   if ((lft^rgt) < 0) {                      /* different signs?             */
      if ((lft | rgt) == MINUS) return 0;    /* 0 == 0, ignoring signs       */

      lft |= 1;                              /* make sure lft != 0           */

   } else {                                  /* same signs                   */
      lft -= rgt;
      if (rgt < 0) lft = -lft;               /* deal with sign-magnitude     */
   }
 
   return lft;
 
} /* CMPF */


int EQLF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE equals                                                               */
/* return (left == right)                                                    */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{ 

   int  lft;
   int  rgt;
   REALasINT(lft, left);
   REALasINT(rgt,right);

   if ((lft^rgt) < 0)                        /* different signs?             */
      return ((lft | rgt) == MINUS);         /* 0 == 0, ignoring signs       */
   if (lft != rgt) return 0;                 /* not equal if bits not same   */
   return ((lft & ~MINUS) <= REAL_INFNAN);   /* NAN's are never equal.       */

} /* EQLF */


int NEQF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE not equals                                                           */
/* return (left != right)                                                    */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{

   int  lft;
   int  rgt;
   REALasINT(lft, left);
   REALasINT(rgt,right);

   if ((lft^rgt) < 0)                          /* different signs?           */
      return ((lft | rgt) != MINUS);           /* 0 == 0, ignoring signs     */
   if (lft != rgt) return 1;                   /* not equal if bits not same */
   return ((lft & ~MINUS) > REAL_INFNAN);      /* NAN's are never equal.     */

} /* NEQF */


int LSSF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE less than                                                            */
/* return (left < right)                                                     */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{ 

   int  lft;
   int  rgt;
   REALasINT(lft, left);
   REALasINT(rgt,right);

   if ((lft & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */
   if ((rgt & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */

   if ((lft^rgt) < 0) {                      /* different signs?             */
      if ((lft | rgt) == MINUS) return 0;    /* 0 == 0, ignoring signs       */
   } else {                                  /* same signs                   */
      lft -= rgt;
      if (rgt < 0) lft = -lft;               /* deal with sign-magnitude     */
   }
   return (lft < 0);

} /* LSSF */


int GTRF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE greater than                                                         */
/* return (left > right)                                                     */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{ 

   int  lft;
   int  rgt;
   REALasINT(lft, left);
   REALasINT(rgt,right);

   if ((lft & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */
   if ((rgt & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */

   if ((lft^rgt) < 0) {                      /* different signs?             */
      if ((lft | rgt) == MINUS) return 0;    /* 0 == 0, ignoring signs       */
      lft |= 1;                              /* make sure lft != 0           */
   } else {                                  /* same signs                   */
      lft -= rgt;
      if (rgt < 0) lft = -lft;               /* deal with sign-magnitude     */
   }
   return (lft > 0);

} /* GTRF */


int LEQF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE less than or equals                                                  */
/* return (left <= right)                                                    */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{

   int  lft;
   int  rgt;
   REALasINT(lft, left);
   REALasINT(rgt,right);

   if ((lft & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */
   if ((rgt & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */

   if ((lft^rgt) < 0) {                      /* different signs?             */
      if ((lft | rgt) == MINUS) return 1;    /* 0 == 0, ignoring signs       */
      lft |= 1;                              /* make sure lft != 0           */
   } else {                                  /* same signs                   */
      lft -= rgt;
      if (rgt < 0) lft = -lft;               /* deal with sign-magnitude     */
   }
   return (lft <= 0);

} /* LEQF */


int GEQF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE greater than or equal                                                */
/* return (left >= right)                                                    */
/*                                                                           */
/* Handles denormalized numbers.                                             */
/* Handles +/- INFINITY, NANs.                                               */
/*---------------------------------------------------------------------------*/
{ 

   int  lft;
   int  rgt;
   REALasINT(lft, left);
   REALasINT(rgt,right);

   if ((lft & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */
   if ((rgt & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */

   if ((lft^rgt) < 0) {                      /* different signs?             */
      if ((lft | rgt) == MINUS) return 1;    /* 0 == 0, ignoring signs       */
   } else {                                  /* same signs                   */
      lft -= rgt;
      if (rgt < 0) lft = -lft;               /* deal with sign-magnitude     */
   }
   return (lft >= 0);

} /* GEQF */


cos.c/          868562434   0     0     0       2345      `
/****************************************************************************/
/*  cos  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:47 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL COSF(REAL x)
{

/* Adapted from "Software Manual for the Elementary Functions" */
/* Cody and Waite, Prentice Hall 1980. pages 127-133           */

    static REAL R[8] =
       {KNST( 0.27204790957888846175e-14),
        KNST(-0.76429178068910467734e-12),
        KNST( 0.16058936490371589114e-9),
        KNST(-0.25052106798274584544e-7),
        KNST( 0.27557319210152756119e-5),
        KNST(-0.19841269841201840457e-3),
        KNST( 0.83333333333331650314e-2),
        KNST(-0.16666666666666665052e+0)};

    int n, i;
    REAL absx, y, xn, f, g, x1, Result;

    ABSF2(absx, x);
    if EQZF(absx) return ONE;
    if GEQF(absx, Pi) 
    {
       ADDF3(y, absx, Pi_Over_Two);
       MPYF3(xn, y, One_Over_Pi);

       if GEQF(y, CNST( 2147483648.0) )

       {
          REAL ip;
          CPYF(xn, ROUNDF(xn));
          n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */
          CPYF(x1,TRUNCF(absx));
       }
       else 
       { 
          FIXFI2(n, ADDF(xn,HALF)); /* round (xn > 0) */
          FLTIF2(xn, n);
          TNCF2(x1,absx);
       }
       SUBF2(xn, HALF); /* TO FORM COS INSTEAD OF SIN */

       /* f = ((x1 - xn * C1) + (absx - x1)) - xn * C2; */
       SUBF3(f, ADDF(SUBF(x1, 
                          MPYF(xn,CNST(3.1416015625) )), 
                     SUBF(absx,x1)), 
                MPYF(xn,CNST(-0.8908910206761537356617e-5) ));

       /* protect against round-off and enhanced precision problems */
       if GTRF(ABSF(f), Pi_Over_Two)
          CPYF(f, (GTZF(f) ? Pi_Over_Two : NEGF(Pi_Over_Two)));

       if (n & 1) NEGF1(f);
    }
    else SUBF3(f,Pi_Over_Two,absx); /*fast code for -Pi..Pi*/

    SQRF2(g, f);

    POLYF(Result, g, R, 8 );

    ADDF3(Result, f, MPYF(f, Result));

    /* deal with round-off errors */
    if GTRF(ABSF(Result), ONE)
       Result = (GTRF(Result,ONE) ? ONE : CNST(-1.0));

    return Result;
} /* COSF */

cosf.c/         868562434   0     0     0       2112      `
/****************************************************************************/
/*  cosf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:15 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL COSF(REAL x)
{

/* Adapted from "Software Manual for the Elementary Functions" */
/* Cody and Waite, Prentice Hall 1980. pages 127-133           */

    static REAL R[4] = 
       {KNST( 0.2601903036e-5),
        KNST(-0.1980741872e-3),
        KNST( 0.8333025139e-2),
        KNST(-0.1666665668e+0)};

    int n, i;
    REAL absx, y, xn, f, g, x1, Result;

    ABSF2(absx, x);
    if EQZF(absx) return ONE;
    if GEQF(absx, Pi) 
    {
       ADDF3(y, absx, Pi_Over_Two);
       MPYF3(xn, y, One_Over_Pi);

       if GEQF(xn, RND_MAX_P1)

       {
          REAL ip;
          CPYF(xn, ROUNDF(xn));
          n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */
          CPYF(x1,TRUNCF(absx));
       }
       else 
       { 
          FIXFI2(n, ADDF(xn,HALF)); /* round (xn > 0) */
          FLTIF2(xn, n);
          TNCF2(x1,absx);
       }
       SUBF2(xn, HALF); /* TO FORM COS INSTEAD OF SIN */

       /* f = ((x1 - xn * C1) + (absx - x1)) - xn * C2; */
       SUBF3(f, ADDF(SUBF(x1, 
                          MPYF(xn,CNST(3.140625) )), 
                     SUBF(absx,x1)), 
                MPYF(xn,CNST(9.67653589793e-4) ));

       /* protect against round-off and enhanced precision problems */
       if GTRF(ABSF(f), Pi_Over_Two)
          CPYF(f, (GTZF(f) ? Pi_Over_Two : NEGF(Pi_Over_Two)));

       if (n & 1) NEGF1(f);
    }
    else SUBF3(f,Pi_Over_Two,absx); /*fast code for -Pi..Pi*/

    SQRF2(g, f);

    POLYF(Result, g, R, 4 );

    ADDF3(Result, f, MPYF(f, Result));

    /* deal with round-off errors */
    if GTRF(ABSF(Result), ONE)
       Result = (GTRF(Result,ONE) ? ONE : CNST(-1.0));

    return Result;
} /* COSF */
cosh.c/         868562434   0     0     0       1059      `
/****************************************************************************/
/*  cosh  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:47 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL COSHF(REAL x)
{
    
    REAL w, y, z;

    ABSF2(y,x);
    if LEQF(y, CNST(7.097827128933838594e+02) ) 
    {
       CPYF(z,EXPF(y));
       MPYF3(z, ADDF(z,INVF(z)), HALF);
       if LSSF(z,ONE) CPYF(z,ONE);
       return z;
    }
    SUBF3(w, y, 0.69316101074218750000E+0 );
    if GTRF(w, ADDF(SUBF(CNST(7.097827128933838594e+02) ,0.69316101074218750000E+0 ),0.69) )
    {
       errno = EDOM;
       if LSZF(x) return CNST(-1.7976931348623157e+308) ;
       return CNST( 1.7976931348623157e+308) ;
    }
    CPYF(z, EXPF(w));
    return ADDF(z, MPYF(0.13830277879601902638E-4 ,z));
} /* COSHF */


coshf.c/        868562434   0     0     0       1020      `
/****************************************************************************/
/*  coshf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:15 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL COSHF(REAL x)
{
    
    REAL w, y, z;

    ABSF2(y,x);
    if LEQF(y, CNST( 88.72283382) ) 
    {
       CPYF(z,EXPF(y));
       MPYF3(z, ADDF(z,INVF(z)), HALF);
       if LSSF(z,ONE) CPYF(z,ONE);
       return z;
    }
    SUBF3(w, y, 0.69316101074218750000E+0 );
    if GTRF(w, ADDF(SUBF(CNST( 88.72283382) ,0.69316101074218750000E+0 ),0.69) )
    {
       errno = EDOM;
       if LSZF(x) return CNST(-3.402823466E+38) ;
       return CNST( 3.402823466E+38) ;
    }
    CPYF(z, EXPF(w));
    return ADDF(z, MPYF(0.13830277879601902638E-4 ,z));
} /* COSHF */

cot.c/          868562436   0     0     0       2498      `
/****************************************************************************/
/*  cot  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:48 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL COTF(REAL x)
{
/* Adapted from "Software Manual for the Elementary Functions" */
/* Cody and Waite, Prentice Hall 1980. pages 150-163           */

    static REAL P[3] =
       {KNST(-0.17861707342254426711e-4),
        KNST( 0.34248878235890589960e-2),
        KNST(-0.13338350006421960681e+0)};

    static REAL Q[4] =
       {KNST( 0.49819433993786512270e-6),
        KNST(-0.31181531907010027307e-3),
        KNST( 0.25663832289440112864e-1),
        KNST(-0.46671683339755294240e+0)};

    REAL y, xn, f, g, x1, xnum, xden;
    int n, i;

    ABSF2(y, x);

    MPYF3(xn, x, Two_Over_Pi);

    if GEQF(y, CNST( 2147483648.0) )

    {
       REAL ip;
       CPYF(xn,ROUNDF(xn));
       n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */
       CPYF(x1,TRUNCF(x));
    } 
    else 
    {
       if GEZF(xn) FIXFI2(n, ADDF(xn,HALF));
       else        FIXFI2(n, SUBF(xn,HALF));
       FLTIF2(xn, n);
       TNCF2(x1, x);
    }

    /* f  = ((x1 - xn * C1) + (x - x1)) - xn * C2; */
    SUBF3(f, ADDF(SUBF(x1,MPYF(xn,CNST(1.57080078125) )), SUBF(x,x1)), MPYF(xn,CNST(-0.4454455103380768678308e-5) ));

    /* protect against round-off and enhanced precision problems */
    if GTRF(ABSF(f), Pi_Over_Four)
       f = (GTZF(f) ? Pi_Over_Four : NEGF(Pi_Over_Four));

    SQRF2(g,f);

    /* xnum = ((                P1)*g*f + f); */
    /* xnum = (((       P2)*g + P1)*g*f + f); */
    /* xnum = (((P3*g + P2)*g + P1)*g*f + f); */
    POLYF(xnum, g, P, 3 )
    MPYF2(xnum,f);
    ADDF2(xnum,f);

    /* xden = ((((                Q2)*g + Q1)*g + 0.5) + 0.5); */
    /* xden = (((((       Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */
    /* xden = (((((Q4*g + Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */
    POLYF(xden, g, Q, 4 );
    ADDF2(xden,HALF);  /* do not compose these two adds! */
    ADDF2(xden,HALF);

    if (n & 1)    return NEGF(DIVF(xnum, xden));
    if NEZF(xnum) return      DIVF(xden, xnum);

    errno = ERANGE;
    if LSZF(xden) return CNST(-1.7976931348623157e+308) ;
    return CNST( 1.7976931348623157e+308) ;
} /* COTF */
cotf.c/         868562436   0     0     0       2256      `
/****************************************************************************/
/*  cotf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:16 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL COTF(REAL x)
{
/* Adapted from "Software Manual for the Elementary Functions" */
/* Cody and Waite, Prentice Hall 1980. pages 150-163           */

    static REAL P[1] =
       {KNST(-0.958017723e-1)};

    static REAL Q[2] =
       {KNST( 0.971685835e-2),
        KNST(-0.429135777e+0)};

    REAL y, xn, f, g, x1, xnum, xden;
    int n, i;

    ABSF2(y, x);

    MPYF3(xn, x, Two_Over_Pi);

    if GEQF(y, RND_MAX_P1)

    {
       REAL ip;
       CPYF(xn,ROUNDF(xn));
       n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */
       CPYF(x1,TRUNCF(x));
    } 
    else 
    {
       if GEZF(xn) FIXFI2(n, ADDF(xn,HALF));
       else        FIXFI2(n, SUBF(xn,HALF));
       FLTIF2(xn, n);
       TNCF2(x1, x);
    }

    /* f  = ((x1 - xn * C1) + (x - x1)) - xn * C2; */
    SUBF3(f, ADDF(SUBF(x1,MPYF(xn,CNST(1.5703125) )), SUBF(x,x1)), MPYF(xn,CNST(4.83826794897e-4) ));

    /* protect against round-off and enhanced precision problems */
    if GTRF(ABSF(f), Pi_Over_Four)
       f = (GTZF(f) ? Pi_Over_Four : NEGF(Pi_Over_Four));

    SQRF2(g,f);

    /* xnum = ((                P1)*g*f + f); */
    /* xnum = (((       P2)*g + P1)*g*f + f); */
    /* xnum = (((P3*g + P2)*g + P1)*g*f + f); */
    POLYF(xnum, g, P, 1 )
    MPYF2(xnum,f);
    ADDF2(xnum,f);

    /* xden = ((((                Q2)*g + Q1)*g + 0.5) + 0.5); */
    /* xden = (((((       Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */
    /* xden = (((((Q4*g + Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */
    POLYF(xden, g, Q, 2 );
    ADDF2(xden,HALF);  /* do not compose these two adds! */
    ADDF2(xden,HALF);

    if (n & 1)    return NEGF(DIVF(xnum, xden));
    if NEZF(xnum) return      DIVF(xden, xnum);

    errno = ERANGE;
    if LSZF(xden) return CNST(-3.402823466E+38) ;
    return CNST( 3.402823466E+38) ;
} /* COTF */
coth.c/         868562436   0     0     0       585       `
/****************************************************************************/
/*  coth  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:48 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL COTHF (REAL x)
{
   if EQZF(x) {errno = EDOM; return CNST( 1.7976931348623157e+308) ; }
   return INVF(TANHF(x));
} /* COTHF */

cothf.c/        868562436   0     0     0       578       `
/****************************************************************************/
/*  cothf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:17 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL COTHF (REAL x)
{
   if EQZF(x) {errno = EDOM; return CNST( 3.402823466E+38) ; }
   return INVF(TANHF(x));
} /* COTHF */
ctime.c/        868562436   0     0     0       425       `
/****************************************************************************/
/*  ctime   v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <time.h>

char *ctime(const time_t *timer)
{
   return(asctime(localtime(timer)));
}

ctype.c/        868562436   0     0     0       7486      `
/****************************************************************************/
/*  ctype.c v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <ctype.h>

/****************************************************************************/
/*  DECLARATION OF CHARACTER TYPING LOOKUP TABLE                            */
/****************************************************************************/
unsigned char _ctypes_[] = {
                     /*  -1   EOF   */      0,
                     /* 0x00  NUL   */     _C_,
                     /* 0x01  SOH   */     _C_,
                     /* 0x02  STX   */     _C_,
                     /* 0x03  ETX   */     _C_,
                     /* 0x04  EOT   */     _C_,
                     /* 0x05  ENQ   */     _C_,
                     /* 0x06  ACK   */     _C_,
                     /* 0x07  BEL   */     _C_,
                     /* 0x08  BS    */     _C_,
                     /* 0x09  HT    */     _C_ | _S_,
                     /* 0x0A  LF    */     _C_ | _S_,
                     /* 0x0B  VT    */     _C_ | _S_,
                     /* 0x0C  FF    */     _C_ | _S_,
                     /* 0x0D  CR    */     _C_ | _S_,
                     /* 0x0E  SO    */     _C_,
                     /* 0x0F  SI    */     _C_,

                     /* 0x10  DLE   */     _C_,
                     /* 0x11  DC1   */     _C_,
                     /* 0x12  DC2   */     _C_,
                     /* 0x13  DC3   */     _C_,
                     /* 0x14  DC4   */     _C_,
                     /* 0x15  NAK   */     _C_,
                     /* 0x16  SYN   */     _C_,
                     /* 0x17  ETB   */     _C_,
                     /* 0x18  CAN   */     _C_,
                     /* 0x19  EM    */     _C_,
                     /* 0x1A  SUB   */     _C_,
                     /* 0x1B  ESC   */     _C_,
                     /* 0x1C  FS    */     _C_,
                     /* 0x1D  GS    */     _C_,
                     /* 0x1E  RS    */     _C_,
                     /* 0x1F  US    */     _C_,

                     /* 0x20  ' '   */     _S_ | _B_,
                     /* 0x21  '!'   */     _P_,
                     /* 0x22  '"'   */     _P_,
                     /* 0x23  '#'   */     _P_,
                     /* 0x24  '$'   */     _P_,
                     /* 0x25  '%'   */     _P_,
                     /* 0x26  '&'   */     _P_,
                     /* 0x27  '''   */     _P_,
                     /* 0x28  '('   */     _P_,
                     /* 0x29  ')'   */     _P_,
                     /* 0x2A  '*'   */     _P_,
                     /* 0x2B  '+'   */     _P_,
                     /* 0x2C  ','   */     _P_,
                     /* 0x2D  '-'   */     _P_,
                     /* 0x2E  '.'   */     _P_,
                     /* 0x2F  '/'   */     _P_,

                     /* 0x30  '0'   */     _N_ | _H_,
                     /* 0x31  '1'   */     _N_ | _H_,
                     /* 0x32  '2'   */     _N_ | _H_,
                     /* 0x33  '3'   */     _N_ | _H_,
                     /* 0x34  '4'   */     _N_ | _H_,
                     /* 0x35  '5'   */     _N_ | _H_,
                     /* 0x36  '6'   */     _N_ | _H_,
                     /* 0x37  '7'   */     _N_ | _H_,
                     /* 0x38  '8'   */     _N_ | _H_,
                     /* 0x39  '9'   */     _N_ | _H_,
                     /* 0x3A  ':'   */     _P_,
                     /* 0x3B  ';'   */     _P_,
                     /* 0x3C  '<'   */     _P_,
                     /* 0x3D  '='   */     _P_,
                     /* 0x3E  '>'   */     _P_,
                     /* 0x3F  '?'   */     _P_,

                     /* 0x40  '@'   */     _P_,
                     /* 0x41  'A'   */     _U_ | _H_,
                     /* 0x42  'B'   */     _U_ | _H_,
                     /* 0x43  'C'   */     _U_ | _H_,
                     /* 0x44  'D'   */     _U_ | _H_,
                     /* 0x45  'E'   */     _U_ | _H_,
                     /* 0x46  'F'   */     _U_ | _H_,
                     /* 0x47  'G'   */     _U_,
                     /* 0x48  'H'   */     _U_,
                     /* 0x49  'I'   */     _U_,
                     /* 0x4A  'J'   */     _U_,
                     /* 0x4B  'K'   */     _U_,
                     /* 0x4C  'L'   */     _U_,
                     /* 0x4D  'M'   */     _U_,
                     /* 0x4E  'N'   */     _U_,
                     /* 0x4F  'O'   */     _U_,

                     /* 0x50  'P'   */     _U_,
                     /* 0x51  'Q'   */     _U_,
                     /* 0x52  'R'   */     _U_,
                     /* 0x53  'S'   */     _U_,
                     /* 0x54  'T'   */     _U_,
                     /* 0x55  'U'   */     _U_,
                     /* 0x56  'V'   */     _U_,
                     /* 0x57  'W'   */     _U_,
                     /* 0x58  'X'   */     _U_,
                     /* 0x59  'Y'   */     _U_,
                     /* 0x5A  'Z'   */     _U_,
                     /* 0x5B  '['   */     _P_,
                     /* 0x5C  '\'   */     _P_,
                     /* 0x5D  ']'   */     _P_,
                     /* 0x5E  '^'   */     _P_,
                     /* 0x5F  '_'   */     _P_,

                     /* 0x60  '`'   */     _P_,
                     /* 0x61  'a'   */     _L_ | _H_,
                     /* 0x62  'b'   */     _L_ | _H_,
                     /* 0x63  'c'   */     _L_ | _H_,
                     /* 0x64  'd'   */     _L_ | _H_,
                     /* 0x65  'e'   */     _L_ | _H_,
                     /* 0x66  'f'   */     _L_ | _H_,
                     /* 0x67  'g'   */     _L_,
                     /* 0x68  'h'   */     _L_,
                     /* 0x69  'i'   */     _L_,
                     /* 0x6A  'j'   */     _L_,
                     /* 0x6B  'k'   */     _L_,
                     /* 0x6C  'l'   */     _L_,
                     /* 0x6D  'm'   */     _L_,
                     /* 0x6E  'n'   */     _L_,
                     /* 0x6F  'o'   */     _L_,

                     /* 0x70  'p'   */     _L_,
                     /* 0x71  'q'   */     _L_,
                     /* 0x72  'r'   */     _L_,
                     /* 0x73  's'   */     _L_,
                     /* 0x74  't'   */     _L_,
                     /* 0x75  'u'   */     _L_,
                     /* 0x76  'v'   */     _L_,
                     /* 0x77  'w'   */     _L_,
                     /* 0x78  'x'   */     _L_,
                     /* 0x79  'y'   */     _L_,
                     /* 0x7A  'z'   */     _L_,
                     /* 0x7B  '{'   */     _P_,
                     /* 0x7C  '|'   */     _P_,
                     /* 0x7D  '}'   */     _P_,
                     /* 0x7E  '~'   */     _P_,
                     /* 0x7F  DEL   */     _C_,

		     /* 0x80-0x8F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0x90-0x9F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xA0-0xAF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xB0-0xBF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xC0-0xCF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xD0-0xDF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xE0-0xEF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xF0-0xFF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  };
cvtdf.c/        868562436   0     0     0       2009      `
/****************************************************************************/
/*  cvtdf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:03 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

LEAN SLIMF(REAL x)
/*---------------------------------------------------------------------------*/
/* Shink REAL to LEAN.                                                       */

/* Does *NOT* handle +/- INFINITY, NAN.                                      */

/* Does *NOT* handle denormalized numbers.                                   */

/*---------------------------------------------------------------------------*/
{ 

   int exp;
   int  frc;
   CREAL crx;

   REALasCREAL(crx, x);

   /* catenate the fraction bits, keeping one extra */
   frc = ((crx.u.msh & REAL_FRC_MASK) <<
           LEAN_FRC_MSBs+1-REAL_FRC_MSBs) +
	 (crx.u.lsh >> 32  +REAL_FRC_MSBs-LEAN_FRC_MSBs-1);

   exp = (int)((crx.u.msh >> REAL_FRC_MSBs) & REAL_EXP_MASK);

   /* check for overflow and underflow */
   if ((exp -= 1023 - 127 ) <= 0) {	/* underflow */
   
	 frc = 0;	/* no significant bits remain */
      exp = 0;
   }
   else if (exp >= LEAN_EXP_INFNAN) {	/* overflow */
      /* Make an infinity unless original was a NaN,     */
      /* in which case preserve the MSBs of the fraction */
      if (exp == REAL_EXP_INFNAN- 1023 + 127 ) {
	 if (frc || crx.u.lsh) frc |= LEAN_NSNAN_BIT*2;
	 frc &= ((unsigned )-2);
      }
      else frc = 0;
      exp = LEAN_EXP_INFNAN;
   }

   /* Round, assemble result and return */
   frc = ((frc+1) >> 1) + (exp << LEAN_FRC_MSBs);
   if (((int )crx.u.msh) < 0) frc += MINUS;

   return_INTasLEAN(frc);

} /* SLIMF */


cvtfd.c/        868562436   0     0     0       1704      `
/****************************************************************************/
/*  cvtfd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:03 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

REAL GROWF(LEAN x)
/*---------------------------------------------------------------------------*/
/* Grow LEAN to REAL.                                                        */

/* Does *NOT* handle +/- INFINITY, NAN.                                      */

/* Does *NOT* handle denormalized numbers.                                   */

/*---------------------------------------------------------------------------*/
{

   int exp;
   int  frc;
   CREAL rslt;

   /* Unpack fraction and exponent, ignoring the sign for now. */
   LEANasINT(frc,x); frc &= ~MINUS;
   if (exp = (int)(frc >> LEAN_FRC_MSBs)) {
      /* normals, INF and NaN are just re-justified and re-biased */
      rslt.u.lsh = frc << 32  +REAL_FRC_MSBs-LEAN_FRC_MSBs;

      rslt.u.msh = (frc >> LEAN_FRC_MSBs-REAL_FRC_MSBs) +

                   /* adjust exponent bias */
                   ((exp == LEAN_EXP_INFNAN) ?
                    REAL_EXP_INFNAN-LEAN_EXP_INFNAN << REAL_FRC_MSBs:
                    1023   - 127    << REAL_FRC_MSBs);
   }

   else rslt.r = ZERO;

   {int  i; LEANasINT(i,x); if (i < 0) rslt.u.msh |= MINUS;}

   return rslt.r;

} /* GROWF */

defs.c/         868562436   0     0     0       2789      `
/*****************************************************************************/
/*  DEFS.C v1.10#                                                            */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file defines some data structures declared in stdio.h.            */
/*****************************************************************************/
#include <stdio.h>

/*---------------------------------------------------------------------------*/
/* Define the streams for stdin, stdout, and stderr, and assign them as the  */
/* first three streams in _FTABLE upon its initialization.                   */
/*---------------------------------------------------------------------------*/
FILE _ftable[_NFILE] = {{  0, NULL, NULL, NULL, NULL, (_MODER | _IOLBF), 0},
                        {  1, NULL, NULL, NULL, NULL, (_MODEW | _IOLBF), 1},
                        {  2, NULL, NULL, NULL, NULL, (_MODEW | _IONBF), 2},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           3},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           4},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           5},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           6},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           7},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           8},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           9},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           10},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           11},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           12},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           13},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           14},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           15},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           16},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           17},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           18},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           19} };

/*---------------------------------------------------------------------------*/
/* Allocate a table to store the filenames of temporary files, so they can   */
/* be deleted when they are closed.                                          */
/*---------------------------------------------------------------------------*/
char _tmpnams[_NFILE][L_tmpnam];

/*---------------------------------------------------------------------------*/
/* This global variable _FT_END is used to mark the end of used streams in   */
/* the file table.                                                           */
/*---------------------------------------------------------------------------*/
int _ft_end = 3; 

difftime.c/     868562436   0     0     0       443       `
/****************************************************************************/
/*  difftime v1.10#                                                         */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <time.h> 

double difftime(time_t time1, time_t time0)
{
    return ((double)time1 - (double)time0);
}

div.c/          868562436   0     0     0       653       `
/****************************************************************************/
/*  div ldiv    v1.10#                                                      */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include "stdlib.h"

div_t div(register int numer, register int denom)
{
    div_t local;
    local.quot = numer / denom;
    local.rem  = numer % denom;
    return (local);
}

ldiv_t ldiv(register long numer, register long denom)
{
    ldiv_t local;
    local.quot = numer / denom;
    local.rem  = numer % denom;
    return (local);
}

divcut.c/       868562436   0     0     0       2624      `
#ifndef _LITTLE_ENDIAN
   #ifdef _BIG_ENDIAN
      #define _LITTLE_ENDIAN !(_BIG_ENDIAN)
   #endif
#endif

#define MSB_In_Hi_Addr _LITTLE_ENDIAN /* ENDIANness. 0=big, 1=little */

   union REAL_2UNS_u {
      double r;
      struct {
      #if MSB_In_Hi_Addr
         unsigned lsh;
         unsigned msh;
      #else
         unsigned msh;
         unsigned lsh;
      #endif
      } u;
   };
   typedef union REAL_2UNS_u REAL_2UNS;

#define REAL_EXP_BITS 11
#define REAL_FRC_BITS 52

#define MINUS (((int)1)<<(32-1))

#define REAL_EXP_INFNAN ((((int)1)<<REAL_EXP_BITS)-1)
#define REAL_EXP_MASK   ((((int)1)<<REAL_EXP_BITS)-1)

#define REAL_FRC_MSBs (REAL_FRC_BITS % 32) /*frc bits MS part*/
#define REAL_FRC_MASK  ((((int)1)<< REAL_FRC_MSBs)-1)
#define REAL_HIDDEN_BIT (((int)1)<< REAL_FRC_MSBs)
#define REAL_INFNAN (((int)REAL_EXP_INFNAN) << REAL_FRC_MSBs)
#define REAL_NSNAN_BIT (((int)1)<<(REAL_FRC_MSBs-1)) /* MSB of fraction */
#define REAL_NAN    (REAL_INFNAN+1) /* signalling NAN */
#define REAL_NSNAN  (REAL_INFNAN+REAL_NSNAN_BIT) /*non-signl NAN*/

#define REAL_MOSTPOS (((REAL_EXP_INFNAN-1)<<REAL_FRC_MSBs)+REAL_FRC_MASK)
#define REAL_MOSTNEG (((REAL_EXP_INFNAN-1)<<REAL_FRC_MSBs)+REAL_FRC_MASK+MINUS)


unsigned  _lmbd (unsigned , unsigned );
extern int FRCDIVF(REAL_2UNS *p, REAL_2UNS *l, REAL_2UNS *r);

double divcut(double left, double right)
{
   unsigned  lfrc, rfrc, sign;
   int lexp, rexp, qexp;
   REAL_2UNS lft, rgt, quo;

   quo.r = 0.0;

   lft.r = left; 
   rgt.r = right;

   sign = (lft.u.msh ^ rgt.u.msh) & MINUS;
   lfrc = (lft.u.msh &= ~MINUS); 
   rfrc = (rgt.u.msh &= ~MINUS);

   if (rexp = (int)(rfrc >> REAL_FRC_MSBs)) {
      if (!(rfrc &= REAL_FRC_MASK) && !rgt.u.lsh) {
         if (!(lexp = (int)(lfrc >> REAL_FRC_MSBs))) {
            goto resign;
	 }
         quo.u.msh = (lfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;
         quo.u.lsh = lft.u.lsh;
         qexp = lexp - rexp;
         goto insert_exponent;
      }
      rgt.u.msh = rfrc + REAL_HIDDEN_BIT;
   }
   else {
      quo.u.msh = REAL_NAN;
      if (lfrc != 0 || lft.u.lsh != 0) quo.u.msh = REAL_INFNAN;
      goto resign;
   }
   if (lexp = (int)(lfrc >> REAL_FRC_MSBs))
      lft.u.msh = (lfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;
   else goto resign;
   qexp = lexp - rexp;
   qexp += FRCDIVF(&quo, &lft, &rgt);
insert_exponent:
   if ((qexp += 1023 ) <= 0) {
      quo.r = 0.0;
      qexp = 0;
   }
   else if (qexp >= REAL_EXP_INFNAN) {
      qexp = REAL_EXP_INFNAN; 
      quo.r = 0.0;
   }
   quo.u.msh = (quo.u.msh & REAL_FRC_MASK) + (((int )qexp) << REAL_FRC_MSBs);
resign:
   quo.u.msh += sign;
   return quo.r;
}
divd.c/         868562436   0     0     0       4145      `
/****************************************************************************/
/*  divd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:04 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

REAL DIVF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE floating divide.  return left / right                                */

/* Does *NOT* handle +/- INFINITY, NAN.                                      */

/* Does *NOT* handle denormalized numbers.                                   */

/*---------------------------------------------------------------------------*/
{ 
/* if_IEEE_Hardware */
  /* Hardware never has divide.                                           */
  /* The fixed point algorithm below will work, but there are better ways */
  /* given a fast floating point multiply.  Someday...                    */
/* elsif_not_IEEE_Hardware */

   unsigned  lfrc, rfrc, sign;     /* fraction of left, right. sign quotient */
   int lexp, rexp, qexp;        /* exponent of left, right, quotient */
   REAL_2UNS lft, rgt, quo;     /* fraction of left, right, quotient */

   /*------------------------------------------------------------------------*/
   /* Unpack fraction and exponent, ignoring signs for now.                  */
   /* Reinsert hidden bit or re-normalize fraction as appropriate.           */
   /*------------------------------------------------------------------------*/

   quo.r = 0.0;
   lft.r = left; 
   rgt.r = right;

   sign = (lft.u.msh ^ rgt.u.msh) & MINUS;

   lfrc = (lft.u.msh &= ~MINUS); 
   rfrc = (rgt.u.msh &= ~MINUS);

   if (rexp = (int)(rfrc >> REAL_FRC_MSBs)) {  /* right not 0 or denorm */
      if (!(rfrc &= REAL_FRC_MASK) && !rgt.u.lsh) { /* right is power of 2 */
         if (!(lexp = (int)(lfrc >> REAL_FRC_MSBs))) { /* left 0 or denorm */
         
            goto resign; /* 0/right */
         
	 }
         quo.u.msh = (lfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;
         quo.u.lsh = lft.u.lsh;
         qexp = lexp - rexp;
         goto insert_exponent;
      }
      rgt.u.msh = rfrc + REAL_HIDDEN_BIT; /* insert hidden bit */
   }

   else {

      quo.u.msh = REAL_NAN;                                      /* 0    / 0 */
      if (lfrc != 0 || lft.u.lsh != 0) quo.u.msh = REAL_INFNAN;  /* left / 0 */

      goto resign;
   }
   if (lexp = (int)(lfrc >> REAL_FRC_MSBs))
      lft.u.msh = (lfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;/*hidden bit*/

   else goto resign;

   /*------------------------------------------------------------------------*/
   /* Compute product exponent and fraction.                                 */
   /* Round and normalize product if needed.                                 */
   /*------------------------------------------------------------------------*/

   qexp = lexp - rexp;
   qexp += FRCDIVF(&quo, &lft, &rgt);

insert_exponent:
   /*------------------------------------------------------------------------*/
   /* check for overflow and underflow                                       */
   /*------------------------------------------------------------------------*/
   if ((qexp += 1023 ) <= 0) {        /* underflow */

      quo.r = 0.0;   /* no significant bits remain */

      qexp = 0;
   }
   else if (qexp >= REAL_EXP_INFNAN) {    /* overflow */

      qexp = REAL_EXP_INFNAN; quo.r = 0.0;

   }

   /*------------------------------------------------------------------------*/
   /* Assemble result and return                                             */
   /*------------------------------------------------------------------------*/
   quo.u.msh = (quo.u.msh & REAL_FRC_MASK) + (((int )qexp) << REAL_FRC_MSBs);

resign:
   quo.u.msh += sign;

   return quo.r;

/* endif_IEEE_Hardware */
} /* DIVF */

divf.c/         868562436   0     0     0       4153      `
/****************************************************************************/
/*  divf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:04 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL DIVF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE floating divide.  return left / right                                */

/* Does *NOT* handle +/- INFINITY, NAN.                                      */

/* Does *NOT* handle denormalized numbers.                                   */

/*---------------------------------------------------------------------------*/
{ 
/* if_IEEE_Hardware */
  /* Hardware never has divide.                                           */
  /* The fixed point algorithm below will work, but there are better ways */
  /* given a fast floating point multiply.  Someday...                    */
/* elsif_not_IEEE_Hardware */

   unsigned  lfrc, rfrc, pfrc;     /* fraction of left, right and product */
   int    lexp, rexp, pexp;	/* exponent of left, right and product */
   unsigned  sign;    

   /*------------------------------------------------------------------------*/
   /* Unpack fraction and exponent, ignoring signs for now.                  */
   /* Reinsert hidden bit or re-normalize fraction as appropriate.           */
   /*------------------------------------------------------------------------*/

   pfrc = 0;
   REALasUNS(lfrc,  left); sign =         lfrc         ; lfrc &= ~MINUS;
   REALasUNS(rfrc, right); sign = (sign ^ rfrc) & MINUS; rfrc &= ~MINUS;

   if (rexp = rfrc >> 23 ) { /* right not 0 or denorm */
      if (!(rfrc &= REAL_FRC_MASK)) {
         /* right is a power of two */
         if (!(lexp = lfrc >> 23 )) { /* left is 0 or denorm */
         
            goto resign;                       /* 0 / right */
         
	 } else pfrc = ((lfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT)<<1;
         pexp = lexp - rexp;
         goto insert_exponent;
      }
      rfrc += REAL_HIDDEN_BIT; /* insert hidden bit */
   }

   else {          /* 0 divisor */
   
      pfrc = REAL_NAN;                          /*    0 / 0 */
      if (lfrc != 0) pfrc = REAL_INFNAN;        /* left / 0 */
   
      goto resign;
   }

   if (lexp = lfrc >> 23 )
      lfrc = (lfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT; /*insert hidden bit*/

   else goto resign;                       /* 0 / right */

   /*------------------------------------------------------------------------*/
   /* Compute quotient exponent and fraction.                                */
   /* Round and normalize quotient if needed.                                */
   /*------------------------------------------------------------------------*/
   pfrc = FRCDIVF(lfrc, rfrc);

   pexp = lexp - rexp;

   pfrc += 1;     /* biased rounding */

   if (pfrc < (REAL_HIDDEN_BIT<<1)) { pfrc <<= 1; pexp -= 1; }

insert_exponent:
   /*------------------------------------------------------------------------*/
   /* check for overflow and underflow                                       */
   /*------------------------------------------------------------------------*/
   if ((pexp += 127 ) <= 0) {        /* underflow */
   
      pfrc = 0;      /* no significant bits remain */
   
      pexp = 0;
      }
   else if (pexp >= REAL_EXP_INFNAN) {    /* overflow */
   
      pexp = REAL_EXP_INFNAN; pfrc = 0;
   
   }

   /*------------------------------------------------------------------------*/
   /* assemble result and return                                             */
   /*------------------------------------------------------------------------*/
   pfrc = ((pfrc >> 1) & REAL_FRC_MASK) + (((int )pexp) << 23 );

resign:
   pfrc += sign;

   return_UNSasREAL(pfrc);

/* endif_IEEE_Hardware */
} /* DIVF */

dtos.c/         868562436   0     0     0       843       `
/****************************************************************************/
/*  dtos v1.10#                                                             */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
extern int ltoa(long val, char *buffer);
void dtos(double num, register char *buf, int prec)
{
       register int ival;
       register int pow = 0;
       double       max = 0x7FFFFFFF;

       if (num < 0) 
       { 
	     *buf++ = '-'; 
	     num = -num;
       }

       while (num > max) { num /= 10; pow++; }

       buf += ltoa(ival = num, buf);
       num -= ival;

       while (prec--)
       {
	    if (pow-- == 0) *buf++ = '.';
	    *buf++ = (ival = num *= 10) + '0';
	    num -= ival;
       }
       *buf = 0;
}

ecvt.c/         868562436   0     0     0       3115      `
/****************************************************************************/
/*  ecvt v1.10#                                                             */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include "math.h"
extern int ltoa(long val, char *buffer);

#ifndef _LITTLE_ENDIAN
   #ifdef _BIG_ENDIAN
      #define _LITTLE_ENDIAN !(_BIG_ENDIAN)
   #endif
#endif

#if _LITTLE_ENDIAN
#define MANTISSA_WORD 0
#define EXPONENT_WORD 1
#elif _BIG_ENDIAN
#define MANTISSA_WORD 1
#define EXPONENT_WORD 0
#else
#error("Neither Big nor Little Endian?")
#endif

char *ecvt(double value, register int ndigit, int *decpt, int *sign)

{
    static char out[100]; 

    register int   digits = 0;         /* NUMBER OF DIGITS BEFORE .       */
    register char *pos    = out + 1;     
    register int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* IF TRYING TO CONVERT INFINITY, RETURN HUGE_VAL OF PROPER SIGN      */
    /*--------------------------------------------------------------------*/
    { 
       int *ptr = (int *)&value;

       if (((ptr[EXPONENT_WORD] >> 20) & 0x7ff) == 0x7ff) 
	  value = (ptr[EXPONENT_WORD] & 0x80000000) ? -HUGE_VAL : HUGE_VAL;
    }

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos    += temp    = ltoa((long)value, pos);
    *decpt  = digits + temp;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (temp >= ndigit) 
	 pos = out + ndigit + 1;
    else if ((ndigit -= temp) > 0) do
    {
         value -= (int) value;
	 *pos++ = (int)(value *= 10.0) + '0';
    }
    while (--ndigit);

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
	register char *ptr = pos;
	while ((*--ptr += 1) > '9') *ptr = '0';
	if (ptr == out) { *--pos = 0; *decpt += 1; return(out); }
    }
	
    *pos = 0;
    return(out + 1);
}


errno.c/        868562436   0     0     0       355       `
/*****************************************************************************/
/*  errno    v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                  */
/*****************************************************************************/
#include <errno.h>
int errno = 0;


exit.c/         868562436   0     0     0       2415      `
/****************************************************************************/
/*  EXIT.C V1.10#                                                           */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>

#define MAX_FUN   32

static int    at_exit_count = 0;
static void (*at_exit_fun[MAX_FUN])();
void        (*_cleanup_ptr)(void) = NULL;

/****************************************************************************/
/* EXIT() - NORMAL PROGRAM TERMINATION.                                     */
/****************************************************************************/
void exit(int status)        
{
   register int i = at_exit_count;

   /*-------------------------------------------------------------------*/
   /* HANDLE FUNCTIONS REGISTERED THROUGH atexit().                     */
   /*-------------------------------------------------------------------*/
   while (i) (*at_exit_fun[--i])(); 

   /*-------------------------------------------------------------------*/
   /* IF FILES ARE POSSIBLY OPEN, _CLEANUP_PTR() WILL BE SETUP TO CLOSE */
   /* THEM.                                                             */
   /*-------------------------------------------------------------------*/
   if (_cleanup_ptr)  (*_cleanup_ptr)();

   abort();
}

/****************************************************************************/
/* ATEXIT - ATTEMPT TO REGISTER A FUNCTION FOR CALLING AT PROGRAM END       */
/****************************************************************************/
int atexit(void (*fun)())
{
   if (at_exit_count >= MAX_FUN) return 1;
   at_exit_fun[at_exit_count++] = fun;
   return 0;
}

/****************************************************************************/
/* ABORT - ABNORMAL PROGRAM TERMINATION.  CURRENTLY JUST HALTS EXECUTION.   */
/****************************************************************************/
void abort(void)
{
   /*-------------------------------------------------------------------*/
   /* SET C$$EXIT LABEL SO THE DEBUGGER KNOWS WHEN THE C++ PROGRAM HAS  */
   /* COMPLETED.  THIS CAN BE REMOVED IF THE DEBUGGER IS NOT USED.      */
   /*-------------------------------------------------------------------*/
   asm("        .global C$$EXIT");
   asm("C$$EXIT: nop");

   for (;;);   /* SPINS FOREVER */
}

exp.c/          868562436   0     0     0       1986      `
/****************************************************************************/
/*  exp  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:49 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL EXPF(REAL x)
{
   
   if GTRF(x, CNST(7.097827128933838594e+02) )
   { 
      errno = ERANGE;
      return CNST( 1.7976931348623157e+308) ;
   }
   if LSSF(x, CNST(-7.077032713517040747e+02) ) return ZERO;
   if LSSF(ABSF(x), CNST(2.220446049250313081e-16) ) return ONE;

   {
      /* Adapted from "Software Manual for the Elementary Functions"      */
      /* Cody and Waite, Prentice Hall 1980. pages 60-70.                 */

      REAL    result,  xn, x1, f, g, z, gp, q;
      EXPONENT_TYPE n;
      int           i;

      static REAL P[3] =
         {KNST(0.165203300268279130e-4),
          KNST(0.694360001511792852e-2),
          KNST(0.249999999999999993e+0)};

      static REAL Q[3] =
         {KNST(0.495862884905441294e-3),
          KNST(0.555538666969001188e-1),
          KNST(0.500000000000000000e+0)};

      MPYF3(xn, x, One_Over_Ln_2);
      n = (GEZF(xn)? FIXFI((ADDF(xn,HALF))) :  /* n = (int)round(xn); */
                     FIXFI((SUBF(xn,HALF))));
      xn = FLTIF(n);

      x1 = TNCF(x); /* trunc(x), x int range */

      /* g  = ((x1 - xn*C1) + (x-x1)) - xn*C2; */
      SUBF3(g,ADDF(SUBF(x1,
                        MPYF(xn,CNST(0.693359375) )),
                   SUBF(x,x1)), 
              MPYF(xn,CNST(-2.1219444005469058277E-4) ));

      SQRF2(z,g);

      POLYaF(gp,z,P,3 ); 
      MPYF2(gp,g);
      POLYaF(q,z,Q,3 );

      /* f = 0.5 + (gp/(q - gp)); */
      ADDF3(f, HALF, 
               DIVF(gp, 
                    SUBF(q, gp)));

      return SCLF(f, n+1);
   }

} /* EXPF */
exp10.c/        868562436   0     0     0       521       `
/****************************************************************************/
/*  exp10  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:49 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL EXP10F(REAL x)
{
    return EXPF(MPYF(x, Ln_10));
} /*EXP10F*/

exp10f.c/       868562436   0     0     0       522       `
/****************************************************************************/
/*  exp10f  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:17 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL EXP10F(REAL x)
{
    return EXPF(MPYF(x, Ln_10));
} /*EXP10F*/
exp2.c/         868562436   0     0     0       517       `
/****************************************************************************/
/*  exp2  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:50 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL EXP2F(REAL x)
{
    return EXPF(MPYF(x, Ln_2));
} /*EXP2F*/

exp2f.c/        868562436   0     0     0       518       `
/****************************************************************************/
/*  exp2f  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:18 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL EXP2F(REAL x)
{
    return EXPF(MPYF(x, Ln_2));
} /*EXP2F*/
expf.c/         868562436   0     0     0       1889      `
/****************************************************************************/
/*  expf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:19 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL EXPF(REAL x)
{
   
   if GTRF(x, CNST( 88.72283382) )
   { 
      errno = ERANGE;
      return CNST( 3.402823466E+38) ;
   }
   if LSSF(x, CNST(-86.64339241) ) return ZERO;
   if LSSF(ABSF(x), CNST(1.1920928955E-7) ) return ONE;

   {
      /* Adapted from "Handbook of Mathematical Functions with Formulas,    */
      /* Graphs, and Mathematical Tables", Milton Abramowitz and            */
      /* Irene A. Stegun, National Bureau of Standards (Applied Mathematics */
      /* Series 55), Washington D.C., 1964 (reprinted 1970). 4.2.45, page 71*/

      REAL    xn, x1, f, g;
      EXPONENT_TYPE n;
      int           i;

      static REAL exp_consts[7] =
         {KNST(0.0001413161),
          KNST(0.0013298820),
          KNST(0.0083013598),
          KNST(0.0416573475),
          KNST(0.1666653019),
          KNST(0.4999999206),
          KNST(0.9999999995)};
   
      x1 = MPYF(x, One_Over_Ln_2);
      n  = (EXPONENT_TYPE)FIXFI(FLRF(x1));
      n  += 1;
      FLTIF2(xn, n);
      FLRF2(x1, x);

      /* g  = ((x1 - xn * C1) + (x-x1)) - xn * C2; */
      SUBF3(g,
            ADDF(SUBF(x1,
                      MPYF(xn,CNST(0.693359375) )),
                 SUBF(x,x1)),
            MPYF(xn, CNST(-2.1219444005469058277E-4) ));
       
      /* -ln(2) =< g < 0 */

      POLYF(f, g, exp_consts, 7 );

      ADDF2(f, ONE);

      /* 1/2 <= F < 1  (exponent of F is -1) */
      return SCLF(f, n);
   }

} /* EXPF */

fabs.c/         868562436   0     0     0       527       `
/****************************************************************************/
/*  fabs  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:51 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FABSF(REAL x)
{
   return (LSSF(x,ZERO) ? NEGF(x) : x);
} /* FABSF */

fabsf.c/        868562436   0     0     0       528       `
/****************************************************************************/
/*  fabsf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:19 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FABSF(REAL x)
{
   return (LSSF(x,ZERO) ? NEGF(x) : x);
} /* FABSF */
fclose.c/       868562436   0     0     0       3689      `
/*****************************************************************************/
/*  FCLOSE.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    Functions:                                                             */
/*       FCLOSE   -  Close a stream                                          */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>
#include <stdlib.h>

extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* FCLOSE   -  Close a stream                                                */
/*                                                                           */
/*    This function flushes the current stream, deallocates any buffers      */
/*    associated with the stream, and closes it.  This function returns a 0  */
/*    if the close was successful, or an EOF if an error occured.            */
/*                                                                           */
/*****************************************************************************/
int fclose(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int fd = _fp->fd;
   int errchk;
   int remove_flag = _STCHK(_fp, _TMPFILE);

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* Flush the buffer.                                                      */
   /*------------------------------------------------------------------------*/
   if(_doflush(_fp)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* Free the buffer if there was one, and it was malloc'd by SETVBUF.      */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _BUFFALOC))
   {
      free((_fp->buf)-1);
      _UNSET(_fp, _BUFFALOC);
   }

   /*------------------------------------------------------------------------*/
   /* Reset the buffer pointers in the stream.                               */
   /*------------------------------------------------------------------------*/
   _fp->buf = NULL;
   _fp->pos = NULL;
   _fp->bufend = NULL;

   /*------------------------------------------------------------------------*/
   /* Close the file, and give the FILE structure an invalid file descriptor */
   /* so it cannot be used until it is assigned to another stream.           */
   /*------------------------------------------------------------------------*/
   errchk = close(_fp->fd);
   _fp->fd = -1;

   /*------------------------------------------------------------------------*/
   /* If the FILE pointer was associated with a temporary file, look up that */
   /* temporary file's filename, and remove it.                              */
   /*------------------------------------------------------------------------*/
   if(remove_flag) remove(_tmpnams[fd]);  

   return (errchk);
}


fcvt.c/         868562436   0     0     0       3204      `
/****************************************************************************/
/*  fcvt v1.10#                                                             */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include "ctype.h"
#include "math.h"

extern int ltoa(long val, char *buffer);

#ifndef _LITTLE_ENDIAN
   #ifdef _BIG_ENDIAN
      #define _LITTLE_ENDIAN !(_BIG_ENDIAN)
   #endif
#endif

#if _LITTLE_ENDIAN
#define MANTISSA_WORD 0
#define EXPONENT_WORD 1
#elif _BIG_ENDIAN
#define MANTISSA_WORD 1
#define EXPONENT_WORD 0
#else
#error("Neither Big nor Little Endian?")
#endif

char *fcvt(double value, register int ndigit, int *decpt, int *sign)

{
    static char out[100]; 

    register int   digits = 0;         /* NUMBER OF DIGITS BEFORE .       */
    register char *pos    = out + 1;     
    register int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* IF TRYING TO CONVERT INFINITY, RETURN HUGE_VAL OF PROPER SIGN      */
    /*--------------------------------------------------------------------*/
    { 
       int *ptr = (int *)&value;

       if (((ptr[EXPONENT_WORD] >> 20) & 0x7ff) == 0x7ff) 
	  value = (ptr[EXPONENT_WORD] & 0x80000000) ? -HUGE_VAL : HUGE_VAL;
    }

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos   += temp    = ltoa((long)value, pos);
    *decpt = digits + temp; 

    /* if (digits < 0) */ ndigit += digits;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (ndigit > 0) do
    {
         value -= (int)value;
         *pos++ = (int)(value *= 10.0) + '0';
    }
    while (--ndigit);

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
	register char *ptr = pos;
	while ((*--ptr += 1) > '9') *ptr = '0';
	if (ptr == out) 
	   if (--pos > out) { *pos   = 0; *decpt += 1; return(out); }
	   else             { out[1] = 0;              return(out); }
    }
	
    *pos = 0;
    return(out + 1);
}

feof.c/         868562436   0     0     0       802       `
/*****************************************************************************/
/*  FEOF.C v1.10#                                                            */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the function FEOF, which returns a 1 if an EOF      */
/*    has occured on that stream.  The function merely calls a macro         */
/*    that is defined in STDIO.H.                                            */
/*****************************************************************************/
#include <stdio.h>

int feof(FILE *_fp) { return (((_fp)->flags & _STATEOF)); }

ferror.c/       868562436   0     0     0       800       `
/*****************************************************************************/
/*  FERROR.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the function FERROR, which returns a 1 if an I/O    */
/*    error has occured on that stream.  The function merely calls a macro   */
/*    that is defined in STDIO.H.                                            */
/*****************************************************************************/
#include <stdio.h>

int ferror(FILE *_fp) { return (_STCHK(_fp, _STATERR)); }

fgetc.c/        868562436   0     0     0       3985      `
/*****************************************************************************/
/*  FGETC.C v1.10#                                                           */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    GETC     -  Get a character from a stream                              */
/*    GETCHAR  -  Get a character from stdin                                 */
/*    FGETC    -  Get a character from a stream                              */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _buff_read(FILE *_fp);
extern int _rd_ok    (FILE *_fp);

int fgetc(register FILE *_fp);






/*****************************************************************************/
/* GETC  -  Get a character from a stream                                    */
/*                                                                           */
/*    This function is equivalent to FGETC.                                  */
/*                                                                           */
/*****************************************************************************/
int getc(FILE *_fp) { return (fgetc(_fp)); }






/*****************************************************************************/
/* GETCHAR  -  Get a character from stdin                                    */
/*                                                                           */
/*    This function calls a macro defined in STDIO.H, which calls FGETC with */
/*    stdin as its argument.                                                 */
/*                                                                           */
/*****************************************************************************/
int getchar(void) { return(_getchar()); }






/*****************************************************************************/
/* FGETC -  Get a character from a stream                                    */
/*****************************************************************************/
int fgetc(register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Make sure that it is OK to read from this stream.                      */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp)) return (EOF);
   
   /*------------------------------------------------------------------------*/
   /* For non-buffered streams, call the lowlevel READ function.             */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      int   errchk;
      char  result;

      errchk = read(_fp->fd, &result, 1);
      if(errchk <= 0)
      {
         _SET(_fp, (errchk == 0) ? _STATEOF : _STATERR);
         return (EOF);
      }

      return ((int)result);
   }

   /*------------------------------------------------------------------------*/
   /* If the buffer has been entirely read, or is empty, call _BUFF_READ to  */
   /* fill the buffer.                                                       */
   /*------------------------------------------------------------------------*/
   if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);
 
   /*------------------------------------------------------------------------*/
   /* If the buffer read was unsuccessful, return an EOF.  Otherwise, clear  */
   /* the _UNGETC flag in the stream, and return the next character.         */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, (_STATERR | _STATEOF))) return (EOF);
   _UNSET(_fp, _UNGETC);

   return ((int)*(_fp->pos++)); 
   
}


fflush.c/       868562436   0     0     0       4723      `
/*****************************************************************************/
/*  FFLUSH.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* FUNCTIONS:                                                                */
/*    fflush   -  Call _doflush for all streams that require flushing        */
/*    _doflush -  Flush one stream                                           */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _ft_end;

int _doflush(FILE *_fp);






/*****************************************************************************/
/* FFLUSH   -  Call _doflush for all streams that require flushing           */
/*                                                                           */
/*    This function returns a 0 upon success, and an EOF upon failure.       */
/*                                                                           */
/*****************************************************************************/
int fflush(register FILE *_fp)
{
   int result = 0;
 
   /*------------------------------------------------------------------------*/
   /* If _fp is not a NULL pointer, call _DOFLUSH for that stream.           */
   /* Otherwise, call _DOFLUSH for all file streams in the table that are    */
   /* active.                                                                */
   /*------------------------------------------------------------------------*/
   if (_fp) result = _doflush(_fp);
   else
   {
      int index;
 
      for(index = 0; index < _ft_end; index++)
         if(_ftable[index].fd != -1) result |= _doflush(&_ftable[index]);
   }
 
   return (result);
}






/*****************************************************************************/
/* _DOFLUSH -  Flush one stream                                              */
/*                                                                           */
/*    This function flushes the stream pointed to by _fp.  If the function   */
/*    is successful, it returns a 0.  If unsuccessful, it returns an EOF     */
/*                                                                           */
/*****************************************************************************/
int _doflush(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*                                                                        */
   /*    num_write   -  The number of bytes to be written to the file        */
   /*    errchk      -  An indicator to see if WRITE was successful          */
   /*------------------------------------------------------------------------*/
   unsigned num_write = _fp->pos - _fp->buf;
   int errchk = 0;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the stream is writable, and it has a buffer, call WRITE, and store  */
   /* its return value in errchk                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEW)) errchk = write(_fp->fd, (char *)_fp->buf, num_write);
 
   /*------------------------------------------------------------------------*/
   /* If WRITE fails, set the error flag in the stream pointer, and return   */
   /* an EOF                                                                 */
   /*------------------------------------------------------------------------*/
   if(errchk < 0)
   {
      _SET(_fp, _STATERR);
      return (EOF);
   }
 
   /*------------------------------------------------------------------------*/
   /* Reset the buffer pointer, make files opened with the "+" flag          */
   /* available for wither reading or writing, and return a 0, indicating    */
   /* a success                                                              */
   /*------------------------------------------------------------------------*/
   _fp->pos          =  _fp->buf;
   _fp->buff_stop    =  NULL;
   if (_STCHK(_fp, _MODERW)) _UNSET(_fp, (_MODER | _MODEW));
   return 0;
 
}
 

fgetpos.c/      868562436   0     0     0       984       `
/*****************************************************************************/
/*  FGETPOS.C v1.10#                                                         */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This function contains the function FGETPOS, which stores the current  */
/*    position in the file into the variable pointed to by _POS.  A 0 is     */
/*    returned upon success, and upon failure, ERRNO is set to 5, and a -1L  */
/*    is returned.                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>
#include "file.h"

int fgetpos(FILE *_fp, fpos_t *_pos)
{
   if((*_pos = ftell(_fp)) != -1L) return (0);
   else { errno = 5; return (-1);  }
}

fgets.c/        868562436   0     0     0       7058      `
/*****************************************************************************/
/*  FGETS.C v1.10#                                                           */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FGETS    -  Get a string from a stream                                 */
/*    GETS     -  Get a string from stdin                                    */
/*    _DOFGETS -  Perform the main FGETS routine                             */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"

extern int  _rd_ok(FILE *_fp);
extern void _buff_read(FILE *_fp);

static char *_dofgets(char *_ptr, register int _size, register FILE *_fp,
                      int _gets_flag);






/*****************************************************************************/
/* FGETS -  Get a string from a stream                                       */
/*                                                                           */
/*    This function calls _DOFGETS, with a 0 for the _GETS_FLAG argument.    */
/*                                                                           */
/*****************************************************************************/
char *fgets(char *_ptr, register int _size, register FILE *_fp)
{
   return(_dofgets(_ptr, _size, _fp, 0));
}






/*****************************************************************************/
/* GETS  -  Get a string from stdin                                          */
/*                                                                           */
/*    This function calls FGETS with stdin as the stream argument.           */
/*                                                                           */
/*****************************************************************************/
char *gets(char *_ptr) { return (_dofgets(_ptr, 1, stdin, 1)); }






/*****************************************************************************/
/* _DOFGETS -  Perform the main FGETS routine                                */
/*                                                                           */
/*    This function gets a string from the stream _FP.  It returns a pointer */
/*    to the string upon success, or NULL upon failure.                      */
/*                                                                           */
/*****************************************************************************/
static char *_dofgets(char *_ptr, register int _size, register FILE *_fp, 
                      int _gets_flag)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned    char     *next_nl    = NULL;
               char     *fpos       = _ptr;
               size_t   num_left    = _size -1,
                        num_to_read;
               int      skipped_nl  = 0;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is readable.                                 */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp) || _STCHK(_fp, _STATEOF) || (_size -1) < 0) return (NULL);

   /*------------------------------------------------------------------------*/
   /* If the stream is non buffered, read the string in one character at a   */
   /* time, using the lowlevel READ function.                                */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      int errchk;
 
      while((errchk = read(_fp->fd, fpos, 1) > 0) && (*(fpos++) != '\n'));
 
      switch(errchk)
      {
         case  0 :
         case -1 : return (NULL);
      }
 
      *fpos = '\0';
 
      return (_ptr);
   }
 
   while((num_left > 0 || _gets_flag) && ! next_nl)
   {
      /*---------------------------------------------------------------------*/
      /* If the buffer is empty or completely read, fill it up.  If the read */
      /* is unsuccessful, return a NULL                                      */
      /*---------------------------------------------------------------------*/
      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);
      if(_STCHK(_fp, (_STATERR | _STATEOF))) return (NULL);

      /*---------------------------------------------------------------------*/
      /* Determine the location of the next newline character (NEXT_NL).     */
      /*---------------------------------------------------------------------*/
      next_nl = (unsigned char *)memchr(_fp->pos, '\n', (_fp->buff_stop - 
                                        _fp->pos));

      /*---------------------------------------------------------------------*/
      /* Determine how many characters to read from the buffer.  If this     */
      /* function was called from GETS (_GETS_FLAG == 1), read until a       */
      /* newline character, EOF character, or the end of the buffer is       */
      /* encountered.  Do the same otherwise, but do not read any more       */
      /* characters than specified by NUM_LEFT.                              */
      /*---------------------------------------------------------------------*/
      num_to_read =  _fp->buff_stop - _fp->pos;
      num_to_read =  (next_nl) ? (next_nl - _fp->pos + 1) : num_to_read;
      num_to_read =  (_gets_flag) ? num_to_read :
                     (num_left < num_to_read) ? num_left : num_to_read;

      /*---------------------------------------------------------------------*/
      /* If this function was called from GETS (_GETS_FLAG == 1), do not     */
      /* retain a newline character if one is present                        */
      /*---------------------------------------------------------------------*/
      if(next_nl && _gets_flag)
      {
         num_to_read--;
         skipped_nl = 1;
      }

      /*---------------------------------------------------------------------*/
      /* Copy the characters, and update pointers and counters.              */
      /*---------------------------------------------------------------------*/
      memcpy(fpos, _fp->pos, num_to_read);
      _fp->pos += (skipped_nl + num_to_read);
      num_left -= num_to_read;
      fpos += num_to_read;
   }

   /*------------------------------------------------------------------------*/
   /* Tack on the NULL terminator, clear the _UNGETC flag and the _GETS_FLAG.*/
   /*------------------------------------------------------------------------*/
   *fpos = '\0';
   _UNSET(_fp, _UNGETC);
   _gets_flag = 0; 

   return(_ptr);
}

fixdb.c/        868562436   0     0     0       1302      `
/****************************************************************************/
/*  fixdb  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:04 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

unsigned char  FIXFB (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to unsigned, truncating towards zero.                        */
/* Produces saturated answers for out-of-range positive values.              */

/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned y = FIXFU(x);
   if (y > (unsigned)( (unsigned char )-1) ) return ( (unsigned char )-1) ;
 
   return (signed char )y;

} /* FIXFy */

fixdc.c/        868562436   0     0     0       1326      `
/****************************************************************************/
/*  fixdc  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:05 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

   signed char  FIXFC (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to integer, truncating towards zero.                         */
/* Produces saturated answers for out-of-range values.                       */
/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   int y = FIXFI(x);
   if (y > (int)((((signed char )1)<<(8  -1))-1) ) return ((((signed char )1)<<(8  -1))-1) ;
   if (y < (int)( ((signed char )1)<<(8  -1)   ) ) return ( ((signed char )1)<<(8  -1)   ) ;
 
   return (signed char )y;

} /* FIXFx */

fixdi.c/        868562436   0     0     0       1780      `
/****************************************************************************/
/*  fixdi  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:05 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

int  FIXFI (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to integer, truncating towards zero.                         */
/* Produces saturated answers for out-of-range values.                       */
/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned  rslt; int rexp;  /* frc and exp of result */
   REAL_2UNS xx;

   xx.r = x;
   if ((rexp = (xx.u.msh >> REAL_FRC_MSBs) & MASK(11 ))== 0)
      return (int )0;  /* denorm or 0 */

   rexp = 1023  + 32   - 1 - rexp;
   if (rexp <= 0) { /* return saturated answers for overflow */
      rslt = ((((int )1)<<(32  -1))-1) ;
      if (xx.u.msh & MINUS) rslt = ~rslt;
      return rslt;
   }
   if (rexp >= 32  ) return (int )0; /* underflow */

   rslt = 
      ( ( (unsigned )((xx.u.msh & REAL_FRC_MASK)+ REAL_HIDDEN_BIT)
          << (32  -REAL_FRC_MSBs-1)
        )
       + ((unsigned )(xx.u.lsh >> REAL_FRC_MSBs+1))
      ) >> rexp;
   if (xx.u.msh & MINUS) rslt = -rslt;

   return rslt;

} /* FIXFx */

fixdli.c/       868562436   0     0     0       1804      `
/****************************************************************************/
/*  fixdli  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:06 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

   long  FIXFLI (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to integer, truncating towards zero.                         */
/* Produces saturated answers for out-of-range values.                       */
/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned long  rslt; int rexp;  /* frc and exp of result */
   REAL_2UNS xx;

   xx.r = x;
   if ((rexp = (xx.u.msh >> REAL_FRC_MSBs) & MASK(11 ))== 0)
      return (long )0;  /* denorm or 0 */

   rexp = 1023  + 40   - 1 - rexp;
   if (rexp <= 0) { /* return saturated answers for overflow */
      rslt = ((((long )1)<<(40  -1))-1) ;
      if (xx.u.msh & MINUS) rslt = ~rslt;
      return rslt;
   }
   if (rexp >= 40  ) return (long )0; /* underflow */

   rslt = 
      ( ( (unsigned long )((xx.u.msh & REAL_FRC_MASK)+ REAL_HIDDEN_BIT)
          << (40  -REAL_FRC_MSBs-1)
        )
       + ((unsigned long )(xx.u.lsh >> REAL_FRC_MSBs+1))
      ) >> rexp;
   if (xx.u.msh & MINUS) rslt = -rslt;

   return rslt;

} /* FIXFx */

fixdsi.c/       868562436   0     0     0       1296      `
/****************************************************************************/
/*  fixdsi  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:06 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

   short  FIXFSI (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to integer, truncating towards zero.                         */
/* Produces saturated answers for out-of-range values.                       */
/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   int y = FIXFI(x);
   if (y > (int)((((short )1)<<(16  -1))-1) ) return ((((short )1)<<(16  -1))-1) ;
   if (y < (int)( ((short )1)<<(16  -1)   ) ) return ( ((short )1)<<(16  -1)   ) ;
 
   return (short )y;

} /* FIXFx */

fixdu.c/        868562436   0     0     0       1911      `
/****************************************************************************/
/*  fixdu  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:07 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

unsigned  FIXFU (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to unsigned, truncating towards zero.                        */
/* Produces saturated answers for out-of-range positive values.              */

/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned  rslt; int rexp;  /* frc and exp of result */
   REAL_2UNS xx;

   xx.r = x;
 
   if ((rexp = (xx.u.msh >> REAL_FRC_MSBs) & MASK(11 ))== 0)
      return (unsigned )0; /* denormalized or 0 */

   rexp = 1023  + 32   - 1 - rexp;
   if (rexp < 0) { /* overflow */

      if (xx.u.msh & MINUS) return ( ((int )1)<<(32  -1)   ) ;
   
      return ( (unsigned )-1) ;
   }

   if (rexp >= 32  ) return (unsigned )0; /* underflow */

   rslt =
      ( ( (unsigned )((xx.u.msh & REAL_FRC_MASK)+ REAL_HIDDEN_BIT)
          << (32  -REAL_FRC_MSBs-1)
        )
       + ((unsigned )(xx.u.lsh >> REAL_FRC_MSBs+1))
      ) >> rexp;

   if (xx.u.msh & MINUS) 
      rslt = (((int )rslt) < 0) ? ( ((int )1)<<(32  -1)   )  : -rslt;
 
   return rslt;

} /* FIXFy */


fixdul.c/       868562436   0     0     0       1951      `
/****************************************************************************/
/*  fixdul  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:08 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

unsigned long  FIXFUL (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to unsigned, truncating towards zero.                        */
/* Produces saturated answers for out-of-range positive values.              */

/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned long  rslt; int rexp;  /* frc and exp of result */
   REAL_2UNS xx;

   xx.r = x;
 
   if ((rexp = (xx.u.msh >> REAL_FRC_MSBs) & MASK(11 ))== 0)
      return (unsigned long )0; /* denormalized or 0 */

   rexp = 1023  + 40   - 1 - rexp;
   if (rexp < 0) { /* overflow */

      if (xx.u.msh & MINUS) return ( ((long )1)<<(40  -1)   ) ;
   
      return ( (unsigned long )-1) ;
   }

   if (rexp >= 40  ) return (unsigned long )0; /* underflow */

   rslt =
      ( ( (unsigned long )((xx.u.msh & REAL_FRC_MASK)+ REAL_HIDDEN_BIT)
          << (40  -REAL_FRC_MSBs-1)
        )
       + ((unsigned long )(xx.u.lsh >> REAL_FRC_MSBs+1))
      ) >> rexp;

   if (xx.u.msh & MINUS) 
      rslt = (((long )rslt) < 0) ? ( ((long )1)<<(40  -1)   )  : -rslt;
 
   return rslt;

} /* FIXFy */


fixdus.c/       868562436   0     0     0       1301      `
/****************************************************************************/
/*  fixdus  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:08 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

unsigned short  FIXFUS (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to unsigned, truncating towards zero.                        */
/* Produces saturated answers for out-of-range positive values.              */

/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned y = FIXFU(x);
   if (y > (unsigned)( (unsigned short )-1) ) return ( (unsigned short )-1) ;
 
   return (short )y;

} /* FIXFy */


fixfb.c/        868562436   0     0     0       1302      `
/****************************************************************************/
/*  fixfb  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:05 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

unsigned char  FIXFB (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to unsigned, truncating towards zero.                        */
/* Produces saturated answers for out-of-range positive values.              */

/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned y = FIXFU(x);
   if (y > (unsigned)( (unsigned char )-1) ) return ( (unsigned char )-1) ;
 
   return (signed char )y;

} /* FIXFy */

fixfc.c/        868562436   0     0     0       1326      `
/****************************************************************************/
/*  fixfc  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:05 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

   signed char  FIXFC (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to integer, truncating towards zero.                         */
/* Produces saturated answers for out-of-range values.                       */
/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   int y = FIXFI(x);
   if (y > (int)((((signed char )1)<<(8  -1))-1) ) return ((((signed char )1)<<(8  -1))-1) ;
   if (y < (int)( ((signed char )1)<<(8  -1)   ) ) return ( ((signed char )1)<<(8  -1)   ) ;
 
   return (signed char )y;

} /* FIXFx */

fixfi.c/        868562436   0     0     0       1739      `
/****************************************************************************/
/*  fixfi  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:06 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

int  FIXFI (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to integer, truncating towards zero.                         */
/* Produces saturated answers for out-of-range values.                       */
/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned  rslt; unsigned  rfrc; int rexp;   /* frac and exp of result */

   REALasUNS(rfrc,x); rfrc &= ~MINUS;
   if ((rexp = (int)(rfrc >> 23 )) == 0) 
      return (int )0; /* denorm or 0 */

   rfrc = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;    /* insert hidden bit */
   rexp = 127  + 32   -1 -rexp;
   if (rexp <= 0) {	/* overflow */
      rslt = ((((int )1)<<(32  -1))-1) ;
      {unsigned  u; REALasUNS(u,x); if (u & MINUS) rslt = ~rslt;}
      return rslt;
   }
   if (rexp >= 32  ) return 0; /* underflow */
   rslt = rfrc;
   rslt = (rslt << (32  - 23 -1)) >> rexp;
   {unsigned  u; REALasUNS(u,x); if (u & MINUS) rslt = -rslt;}
   return rslt;

} /* FIXFx */


fixfli.c/       868562436   0     0     0       1752      `
/****************************************************************************/
/*  fixfli  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:07 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

   long  FIXFLI (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to integer, truncating towards zero.                         */
/* Produces saturated answers for out-of-range values.                       */
/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned long  rslt; unsigned  rfrc; int rexp;   /* frac and exp of result */

   REALasUNS(rfrc,x); rfrc &= ~MINUS;
   if ((rexp = (int)(rfrc >> 23 )) == 0) 
      return (long )0; /* denorm or 0 */

   rfrc = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;    /* insert hidden bit */
   rexp = 127  + 40   -1 -rexp;
   if (rexp <= 0) {	/* overflow */
      rslt = ((((long )1)<<(40  -1))-1) ;
      {unsigned  u; REALasUNS(u,x); if (u & MINUS) rslt = ~rslt;}
      return rslt;
   }
   if (rexp >= 40  ) return 0; /* underflow */
   rslt = rfrc;
   rslt = (rslt << (40  - 23 -1)) >> rexp;
   {unsigned  u; REALasUNS(u,x); if (u & MINUS) rslt = -rslt;}
   return rslt;

} /* FIXFx */

fixfsi.c/       868562438   0     0     0       1296      `
/****************************************************************************/
/*  fixfsi  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:07 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

   short  FIXFSI (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to integer, truncating towards zero.                         */
/* Produces saturated answers for out-of-range values.                       */
/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   int y = FIXFI(x);
   if (y > (int)((((short )1)<<(16  -1))-1) ) return ((((short )1)<<(16  -1))-1) ;
   if (y < (int)( ((short )1)<<(16  -1)   ) ) return ( ((short )1)<<(16  -1)   ) ;
 
   return (short )y;

} /* FIXFx */

fixfu.c/        868562438   0     0     0       1909      `
/****************************************************************************/
/*  fixfu  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:08 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

unsigned  FIXFU (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to unsigned, truncating towards zero.                        */
/* Produces saturated answers for out-of-range positive values.              */

/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned  rslt; unsigned  rfrc; int rexp;   /* frac and exp of result */

   REALasUNS(rfrc,x);
 
   rfrc &= ~MINUS;
   if ((rexp = (int)(rfrc >> 23 )) == 0) 
      return (unsigned )0; /* denorm or 0 */

   rfrc = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;    /* insert hidden bit */
   rexp = 127  + 32   -1 -rexp;
   if (rexp < 0) { /* overflow  */

      {unsigned  u; REALasUNS(u,x); if (u & MINUS) return ( ((int )1)<<(32  -1)   ) ;}
   
      return ( (unsigned )-1) ;
   }
   if (rexp >= 32  ) return (unsigned )0; /* underflow */

   rslt = rfrc;
   rslt = (rslt << (32  - 23 -1)) >> rexp;
 
   {unsigned  u;
    REALasUNS(u,x); 
    if (u & MINUS) rslt = (((int )rslt) < 0) ? ( ((int )1)<<(32  -1)   )  : -rslt;}
 
   return rslt;

} /* FIXFy */


fixful.c/       868562438   0     0     0       1939      `
/****************************************************************************/
/*  fixful  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:08 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

unsigned long  FIXFUL (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to unsigned, truncating towards zero.                        */
/* Produces saturated answers for out-of-range positive values.              */

/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned long  rslt; unsigned  rfrc; int rexp;   /* frac and exp of result */

   REALasUNS(rfrc,x);
 
   rfrc &= ~MINUS;
   if ((rexp = (int)(rfrc >> 23 )) == 0) 
      return (unsigned long )0; /* denorm or 0 */

   rfrc = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;    /* insert hidden bit */
   rexp = 127  + 40   -1 -rexp;
   if (rexp < 0) { /* overflow  */

      {unsigned  u; REALasUNS(u,x); if (u & MINUS) return ( ((long )1)<<(40  -1)   ) ;}
   
      return ( (unsigned long )-1) ;
   }
   if (rexp >= 40  ) return (unsigned long )0; /* underflow */

   rslt = rfrc;
   rslt = (rslt << (40  - 23 -1)) >> rexp;
 
   {unsigned  u;
    REALasUNS(u,x); 
    if (u & MINUS) rslt = (((long )rslt) < 0) ? ( ((long )1)<<(40  -1)   )  : -rslt;}
 
   return rslt;

} /* FIXFy */


fixfus.c/       868562438   0     0     0       1301      `
/****************************************************************************/
/*  fixfus  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:09 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

unsigned short  FIXFUS (REAL x)
/*---------------------------------------------------------------------------*/
/* Convert REAL to unsigned, truncating towards zero.                        */
/* Produces saturated answers for out-of-range positive values.              */

/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */
/* Handles denormalized numbers.                                             */
/*---------------------------------------------------------------------------*/
{ 

   unsigned y = FIXFU(x);
   if (y > (unsigned)( (unsigned short )-1) ) return ( (unsigned short )-1) ;
 
   return (short )y;

} /* FIXFy */


floor.c/        868562438   0     0     0       620       `
/****************************************************************************/
/*  floor  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:51 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FLOORF(REAL x)
{

   {
      REAL y;
      REAL z = MODFF(x,&y); /* because LSZF macro wants &z */
      return (LSZF(z) ? SUBF(y,ONE) : y);
   }
} /* FLOORF */

floorf.c/       868562438   0     0     0       621       `
/****************************************************************************/
/*  floorf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:20 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FLOORF(REAL x)
{

   {
      REAL y;
      REAL z = MODFF(x,&y); /* because LSZF macro wants &z */
      return (LSZF(z) ? SUBF(y,ONE) : y);
   }
} /* FLOORF */


fltbd.c/        868562438   0     0     0       933       `
/****************************************************************************/
/*  fltbd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:09 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTBF (unsigned char  x)
/*---------------------------------------------------------------------------*/
/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */
/*---------------------------------------------------------------------------*/
{

   return FLTUF((unsigned )x); /* grow and call FLTIF routine to do real work */
 
} /* FLTyF */


fltbf.c/        868562438   0     0     0       933       `
/****************************************************************************/
/*  fltbf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:10 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTBF (unsigned char  x)
/*---------------------------------------------------------------------------*/
/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */
/*---------------------------------------------------------------------------*/
{

   return FLTUF((unsigned )x); /* grow and call FLTIF routine to do real work */
 
} /* FLTyF */


fltcd.c/        868562438   0     0     0       926       `
/****************************************************************************/
/*  fltcd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:10 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTCF (signed char  x)
/*---------------------------------------------------------------------------*/
/* Convert SIGNED (integer) to REAL (floating-pt).                           */
/*---------------------------------------------------------------------------*/
{

   return FLTIF((int )x); /* grow and call FLTIF routine to do real work */
 
} /* FLTxF */

fltcf.c/        868562438   0     0     0       926       `
/****************************************************************************/
/*  fltcf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:11 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTCF (signed char  x)
/*---------------------------------------------------------------------------*/
/* Convert SIGNED (integer) to REAL (floating-pt).                           */
/*---------------------------------------------------------------------------*/
{

   return FLTIF((int )x); /* grow and call FLTIF routine to do real work */
 
} /* FLTxF */

fltid.c/        868562438   0     0     0       1855      `
/****************************************************************************/
/*  fltid  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:10 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FLTIF (int  x)
/*---------------------------------------------------------------------------*/
/* Convert SIGNED (integer) to REAL (floating-pt).                           */
/*---------------------------------------------------------------------------*/
{

   unsigned  rfrc; int rexp;	/* frac and exp of result */
   unsigned  rmsh;
   REAL_2UNS rslt;

   rfrc = x;
   if (rfrc == 0) return ZERO;
   if ((int )rfrc <= 0) rfrc = -rfrc;  /* *WANT* -most_neg == most_neg */

   rexp = _lmbd(1,  rfrc ) ; /* no of consecutive 0 MSBs */
  
   rfrc <<= rexp; rexp = 1023 + 32  -2 - rexp;
 
   /* align for mantissa field and round */
   rslt.u.lsh = (unsigned )(rfrc << (REAL_FRC_MSBs+1- 32  + 32  ));
   rmsh = (unsigned )(rfrc >> (32   -REAL_FRC_MSBs -1));

   /*------------------------------------------------------------------------*/
   /* The exponent field in rfrc now holds 1.                                */
   /* ADD in rexp to simultaneously combine fraction/exponent and also       */
   /* increment the exponent by the appropriate amount.                      */
   /*------------------------------------------------------------------------*/

   rmsh += ((unsigned )rexp) << REAL_FRC_MSBs;

   if (x < 0) rmsh += MINUS;
   rslt.u.msh = rmsh;

   return rslt.r;

} /* FLTxF */


fltif.c/        868562438   0     0     0       1741      `
/****************************************************************************/
/*  fltif  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:11 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FLTIF (int  x)
/*---------------------------------------------------------------------------*/
/* Convert SIGNED (integer) to REAL (floating-pt).                           */
/*---------------------------------------------------------------------------*/
{

   unsigned  rfrc; int rexp; /* frc and exp of result */
   unsigned  rslt;

   rfrc = x;
   if (rfrc == 0) return ZERO;
   if ((int )rfrc <= 0) rfrc = -rfrc;  /* *WANT* -most_neg == most_neg */

   rexp = _lmbd(1,  rfrc ) ; /* no of consecutive 0 MSBs */
  
   rfrc <<= rexp; rexp = 127  + 32   -2 -rexp;
 
   /* align for mantissa field and round */
   rslt = (unsigned )(((rfrc >> 32  - 23 -2) +1) >> 1);

   /*------------------------------------------------------------------------*/
   /* The exponent field in rfrc now holds 1 or maybe 2 if the fraction      */
   /* rounded up.  ADD in rexp to simultaneously combine exponent/fraction   */
   /* and also increment the exponent by the appropriate amount.             */
   /*------------------------------------------------------------------------*/
   rslt+= ((unsigned )rexp) << 23 ;

   if (x < 0) rslt += MINUS;

   return_UNSasREAL(rslt);

} /* FLTxF */


fltlid.c/       868562438   0     0     0       1974      `
/****************************************************************************/
/*  fltlid  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:11 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTLIF (long  x)
/*---------------------------------------------------------------------------*/
/* Convert SIGNED (integer) to REAL (floating-pt).                           */
/*---------------------------------------------------------------------------*/
{

   unsigned long  rfrc; int rexp;	/* frac and exp of result */
   unsigned  rmsh;
   REAL_2UNS rslt;

   rfrc = x;
   if (rfrc == 0) return ZERO;
   if ((long )rfrc <= 0) rfrc = -rfrc;  /* *WANT* -most_neg == most_neg */

   if ((rexp = 
          _lmbd(1,  (unsigned )(rfrc>> 32  ) ) -(2* 32  - 40  )) ==
             (32  -(2* 32  - 40  )))
      rexp += _lmbd(1,  (unsigned )(rfrc) ) ;
  
   rfrc <<= rexp; rexp = 1023 + 40  -2 - rexp;
 
   /* align for mantissa field and round */
   rslt.u.lsh = (unsigned )(rfrc << (REAL_FRC_MSBs+1- 40  + 32  ));
   rmsh = (unsigned )(rfrc >> (40   -REAL_FRC_MSBs -1));

   /*------------------------------------------------------------------------*/
   /* The exponent field in rfrc now holds 1.                                */
   /* ADD in rexp to simultaneously combine fraction/exponent and also       */
   /* increment the exponent by the appropriate amount.                      */
   /*------------------------------------------------------------------------*/

   rmsh += ((unsigned )rexp) << REAL_FRC_MSBs;

   if (x < 0) rmsh += MINUS;
   rslt.u.msh = rmsh;

   return rslt.r;

} /* FLTxF */

fltlif.c/       868562438   0     0     0       1860      `
/****************************************************************************/
/*  fltlif  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:12 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTLIF (long  x)
/*---------------------------------------------------------------------------*/
/* Convert SIGNED (integer) to REAL (floating-pt).                           */
/*---------------------------------------------------------------------------*/
{

   unsigned long  rfrc; int rexp; /* frc and exp of result */
   unsigned  rslt;

   rfrc = x;
   if (rfrc == 0) return ZERO;
   if ((long )rfrc <= 0) rfrc = -rfrc;  /* *WANT* -most_neg == most_neg */

   if ((rexp = 
          _lmbd(1,  (unsigned )(rfrc>> 32  ) ) -(2* 32  - 40  )) ==
             (32  -(2* 32  - 40  )))
      rexp += _lmbd(1,  (unsigned )(rfrc) ) ;
  
   rfrc <<= rexp; rexp = 127  + 40   -2 -rexp;
 
   /* align for mantissa field and round */
   rslt = (unsigned )(((rfrc >> 40  - 23 -2) +1) >> 1);

   /*------------------------------------------------------------------------*/
   /* The exponent field in rfrc now holds 1 or maybe 2 if the fraction      */
   /* rounded up.  ADD in rexp to simultaneously combine exponent/fraction   */
   /* and also increment the exponent by the appropriate amount.             */
   /*------------------------------------------------------------------------*/
   rslt+= ((unsigned )rexp) << 23 ;

   if (x < 0) rslt += MINUS;

   return_UNSasREAL(rslt);

} /* FLTxF */

fltsid.c/       868562438   0     0     0       922       `
/****************************************************************************/
/*  fltsid  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:11 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTSIF (short  x)
/*---------------------------------------------------------------------------*/
/* Convert SIGNED (integer) to REAL (floating-pt).                           */
/*---------------------------------------------------------------------------*/
{

   return FLTIF((int )x); /* grow and call FLTIF routine to do real work */
 
} /* FLTxF */

fltsif.c/       868562438   0     0     0       922       `
/****************************************************************************/
/*  fltsif  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:13 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTSIF (short  x)
/*---------------------------------------------------------------------------*/
/* Convert SIGNED (integer) to REAL (floating-pt).                           */
/*---------------------------------------------------------------------------*/
{

   return FLTIF((int )x); /* grow and call FLTIF routine to do real work */
 
} /* FLTxF */

fltud.c/        868562438   0     0     0       1749      `
/****************************************************************************/
/*  fltud  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:12 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FLTUF (unsigned  x)
/*---------------------------------------------------------------------------*/
/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */
/*---------------------------------------------------------------------------*/
{

   unsigned  rfrc; int rexp;	/* frac and exp of result */
   unsigned  rmsh;
   REAL_2UNS rslt;

   if ((rfrc = x) == 0) return ZERO;

   rexp = _lmbd(1,  rfrc ) ; /* no of consecutive 0 MSBs */
  
   rfrc <<= rexp; rexp = 1023  + 32   -2 -rexp;
 
   /* align for mantissa field and round */
   rslt.u.lsh = (unsigned )(rfrc << (REAL_FRC_MSBs+1- 32  + 32  ));
   rmsh = (unsigned )(rfrc >> 32   -REAL_FRC_MSBs -1);

   /*------------------------------------------------------------------------*/
   /* The exponent field in rfrc now holds 1.                                */
   /* ADD in rexp to simultaneously combine fraction/exponent and also       */
   /* increment the exponent by the appropriate amount.                      */
   /*------------------------------------------------------------------------*/

   rmsh += ((unsigned )rexp) << REAL_FRC_MSBs;

   rslt.u.msh = rmsh;

   return rslt.r;

} /* FLTyF */


fltuf.c/        868562438   0     0     0       1647      `
/****************************************************************************/
/*  fltuf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:13 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FLTUF (unsigned  x)
/*---------------------------------------------------------------------------*/
/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */
/*---------------------------------------------------------------------------*/
{

   unsigned  rfrc; int rexp; /* frc and exp of result */
   unsigned  rslt;

   if ((rfrc = x) == (unsigned )0) return ZERO;

   rexp = _lmbd(1,  rfrc ) ; /* no of consecutive 0 MSBs */
  
   rfrc <<= rexp; rexp = 127  + 32   -2 -rexp;
 
   /* align for mantissa field and round */
   rslt = (unsigned )(((rfrc >> 32  - 23 -2) +1) >> 1);

   /*------------------------------------------------------------------------*/
   /* The exponent field in rfrc now holds 1 or maybe 2 if the fraction      */
   /* rounded up.  ADD in rexp to simultaneously combine exponent/fraction   */
   /* and also increment the exponent by the appropriate amount.             */
   /*------------------------------------------------------------------------*/
   rslt += ((unsigned )rexp) << 23 ;

   return_UNSasREAL(rslt);

} /* FLTyF */


fltuld.c/       868562438   0     0     0       1871      `
/****************************************************************************/
/*  fltuld  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:13 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTULF (unsigned long  x)
/*---------------------------------------------------------------------------*/
/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */
/*---------------------------------------------------------------------------*/
{

   unsigned long  rfrc; int rexp;	/* frac and exp of result */
   unsigned  rmsh;
   REAL_2UNS rslt;

   if ((rfrc = x) == 0) return ZERO;

   if ((rexp = 
          _lmbd(1,  (unsigned )(rfrc>> 32  ) ) -(2* 32  - 40  )) ==
             (32  -(2* 32  - 40  )))
      rexp += _lmbd(1,  (unsigned )(rfrc) ) ;
  
   rfrc <<= rexp; rexp = 1023  + 40   -2 -rexp;
 
   /* align for mantissa field and round */
   rslt.u.lsh = (unsigned )(rfrc << (REAL_FRC_MSBs+1- 40  + 32  ));
   rmsh = (unsigned )(rfrc >> 40   -REAL_FRC_MSBs -1);

   /*------------------------------------------------------------------------*/
   /* The exponent field in rfrc now holds 1.                                */
   /* ADD in rexp to simultaneously combine fraction/exponent and also       */
   /* increment the exponent by the appropriate amount.                      */
   /*------------------------------------------------------------------------*/

   rmsh += ((unsigned )rexp) << REAL_FRC_MSBs;

   rslt.u.msh = rmsh;

   return rslt.r;

} /* FLTyF */


fltulf.c/       868562438   0     0     0       1774      `
/****************************************************************************/
/*  fltulf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:14 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTULF (unsigned long  x)
/*---------------------------------------------------------------------------*/
/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */
/*---------------------------------------------------------------------------*/
{

   unsigned long  rfrc; int rexp; /* frc and exp of result */
   unsigned  rslt;

   if ((rfrc = x) == (unsigned long )0) return ZERO;

   if ((rexp = 
          _lmbd(1,  (unsigned )(rfrc>> 32  ) ) -(2* 32  - 40  )) ==
             (32  -(2* 32  - 40  )))
      rexp += _lmbd(1,  (unsigned )(rfrc) ) ;
  
   rfrc <<= rexp; rexp = 127  + 40   -2 -rexp;
 
   /* align for mantissa field and round */
   rslt = (unsigned )(((rfrc >> 40  - 23 -2) +1) >> 1);

   /*------------------------------------------------------------------------*/
   /* The exponent field in rfrc now holds 1 or maybe 2 if the fraction      */
   /* rounded up.  ADD in rexp to simultaneously combine exponent/fraction   */
   /* and also increment the exponent by the appropriate amount.             */
   /*------------------------------------------------------------------------*/
   rslt += ((unsigned )rexp) << 23 ;

   return_UNSasREAL(rslt);

} /* FLTyF */

fltusd.c/       868562438   0     0     0       936       `
/****************************************************************************/
/*  fltusd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:13 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTUSF (unsigned short  x)
/*---------------------------------------------------------------------------*/
/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */
/*---------------------------------------------------------------------------*/
{

   return FLTUF((unsigned )x); /* grow and call FLTIF routine to do real work */
 
} /* FLTyF */

fltusf.c/       868562438   0     0     0       936       `
/****************************************************************************/
/*  fltusf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:14 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

   REAL FLTUSF (unsigned short  x)
/*---------------------------------------------------------------------------*/
/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */
/*---------------------------------------------------------------------------*/
{

   return FLTUF((unsigned )x); /* grow and call FLTIF routine to do real work */
 
} /* FLTyF */

fmod.c/         868562438   0     0     0       3552      `
/****************************************************************************/
/*  fmod  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:52 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FMODF(REAL x, REAL y)
{
/*---------------------------------------------------------------------------*/
/* desired algorithm:                                                        */
/* {                                                                         */
/*    infinite_precision_float Xip, Yip, Q;                                  */
/*                                                                           */
/*    Xip = (infinite_precision_float)x;                                     */
/*    Yip = (infinite_precision_float)y;                                     */
/*    Q = Xip/Yip;                                                           */
/*    Q = Truncate_Towards_0(Q);                                             */
/*    return (REAL)(Xip - Yip*Q);                                            */
/* }                                                                         */
/*---------------------------------------------------------------------------*/
    EXPONENT_TYPE e;
    REAL f, Quo, Remaindr, absY;
    REAL X_Upper, X_Lower;
    REAL Y_Upper, Y_Lower;
    REAL X_Upper_Upper, X_Upper_Lower;

    if EQZF(y) { errno = EDOM; return ZERO; }

    /* don't overflow doing abs!*/
    if NEQF(y, CNST(-1.7976931348623157e+308) ) ABSF2(absY,y);

    if (EQLF(y, CNST(-1.7976931348623157e+308) ) ||
        (NEQF(x, CNST(-1.7976931348623157e+308) )) && (GEQF(absY, ABSF(x)))) {
       DIVF3(Quo, x, y);
       CPYF(Quo,TRUNCF(Quo));
       if EQLF(Quo, ZERO      ) return x;
       if EQLF(Quo, CNST(-1.0)) return ADDF(x, y);
       if EQLF(Quo, ONE       ) return SUBF(x, y);
       return x;
    }

    /*------------------------------------*/
    /* factor y into upper and lower bits */
    /*------------------------------------*/
    RIPF(y, f, e);
    Y_Upper = SCLF(ROUNDF(MPYF(f, CNST(67108864.0) )),
                   e - (53 /2));
    SUBF3(Y_Lower, y,Y_Upper);

    /*----------------------------------------------------------------------*/
    /* Do long-hand division with factored pieces to avoid loosing ANY bits */
    /*----------------------------------------------------------------------*/
    CPYF(Remaindr,x);
    do {
       /*------------------------------------*/
       /* Get another batch of quotient bits */
       /*------------------------------------*/
       CPYF(Quo, TRUNCF(DIVF(Remaindr, y)));

       /*----------------------------------------------------*/
       /* Compute new Remaindr by forming:  Remaindr-(Quo*y) */
       /*----------------------------------------------------*/

       /* factor Remaindr into upper and lower bits*/
       RIPF(Remaindr, f, e);
       SCLF3(X_Upper,TRUNCF(MPYF(f,CNST(67108864.0) )),
                     e-(53 /2));
       SUBF3(X_Lower, Remaindr, X_Upper);

       RIPF(Quo, f, e);
   
       SCLF3(Quo, TRUNCF(MPYF(f,CNST(16777216.0) )),
                  e-((53 /2)-2));
       SUBF2(X_Upper, MPYF(Quo, Y_Upper));
       SUBF2(X_Lower, MPYF(Quo, Y_Lower));
       ADDF3(Remaindr, X_Upper, X_Lower);

    } while (GEQF(ABSF(Remaindr), absY));

    return Remaindr;
} /* FMODF */

fmodf.c/        868562438   0     0     0       3517      `
/****************************************************************************/
/*  fmodf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:20 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FMODF(REAL x, REAL y)
{
/*---------------------------------------------------------------------------*/
/* desired algorithm:                                                        */
/* {                                                                         */
/*    infinite_precision_float Xip, Yip, Q;                                  */
/*                                                                           */
/*    Xip = (infinite_precision_float)x;                                     */
/*    Yip = (infinite_precision_float)y;                                     */
/*    Q = Xip/Yip;                                                           */
/*    Q = Truncate_Towards_0(Q);                                             */
/*    return (REAL)(Xip - Yip*Q);                                            */
/* }                                                                         */
/*---------------------------------------------------------------------------*/
    EXPONENT_TYPE e;
    REAL f, Quo, Remaindr, absY;
    REAL X_Upper, X_Lower;
    REAL Y_Upper, Y_Lower;
    REAL X_Upper_Upper, X_Upper_Lower;

    if EQZF(y) { errno = EDOM; return ZERO; }

    /* don't overflow doing abs!*/
    if NEQF(y, CNST(-3.402823466E+38) ) ABSF2(absY,y);

    if (EQLF(y, CNST(-3.402823466E+38) ) ||
        (NEQF(x, CNST(-3.402823466E+38) )) && (GEQF(absY, ABSF(x)))) {
       DIVF3(Quo, x, y);
       CPYF(Quo,TRUNCF(Quo));
       if EQLF(Quo, ZERO      ) return x;
       if EQLF(Quo, CNST(-1.0)) return ADDF(x, y);
       if EQLF(Quo, ONE       ) return SUBF(x, y);
       return x;
    }

    /*------------------------------------*/
    /* factor y into upper and lower bits */
    /*------------------------------------*/
    RIPF(y, f, e);
    Y_Upper = SCLF(ROUNDF(MPYF(f, CNST(4096.0) )),
                   e - (24 /2));
    SUBF3(Y_Lower, y,Y_Upper);

    /*----------------------------------------------------------------------*/
    /* Do long-hand division with factored pieces to avoid loosing ANY bits */
    /*----------------------------------------------------------------------*/
    CPYF(Remaindr,x);
    do {
       /*------------------------------------*/
       /* Get another batch of quotient bits */
       /*------------------------------------*/
       CPYF(Quo, TRUNCF(DIVF(Remaindr, y)));

       /*----------------------------------------------------*/
       /* Compute new Remaindr by forming:  Remaindr-(Quo*y) */
       /*----------------------------------------------------*/

       /* factor Remaindr into upper and lower bits*/
       RIPF(Remaindr, f, e);
       SCLF3(X_Upper,TRUNCF(MPYF(f,CNST(4096.0) )),
                     e-(24 /2));
       SUBF3(X_Lower, Remaindr, X_Upper);

       RIPF(Quo, f, e);
   
       SCLF3(Quo, TRUNCF(MPYF(f,CNST(1024.0) )),
                  e-((24 /2)-2));
       SUBF2(X_Upper, MPYF(Quo, Y_Upper));
       SUBF2(X_Lower, MPYF(Quo, Y_Lower));
       ADDF3(Remaindr, X_Upper, X_Lower);

    } while (GEQF(ABSF(Remaindr), absY));

    return Remaindr;
} /* FMODF */


fopen.c/        868562438   0     0     0       8689      `
/*****************************************************************************/
/*  FOPEN.C v1.10#                                                           */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* FUNCTIONS:                                                                */
/*    FOPEN       -  Open a file and return a pointer to it                  */
/*    FREOPEN     -  Switch a FILE pointer to a different stream             */
/*    _OPENFILE   -  Set file flags, and call lowlevel OPEN                  */
/*    _SEARCH_FP  -  Find an open slot in the file table                     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "file.h"
 
extern int    _ft_end;
extern void   (*_cleanup_ptr)(void);
 
static FILE *_search_fp();
static FILE *_openfile(const char *_fname, register FILE *_fp, const char
                       *_mode);
       void _cleanup();



 
 

/*****************************************************************************/
/* FOPEN    -  Open a file and return a pointer to it                        */
/*                                                                           */
/*    This function calls _SEARCH_FP to locate an empty slot in the file     */
/*    table (_ftable), and calls _OPENFILE with it to open a stream to the   */
/*    file _FNAME.  It returns a pointer to the stream that was allocated,   */
/*    or NULL if it was not successful.                                      */
/*                                                                           */
/*****************************************************************************/
FILE *fopen(const char *_fname, const char *_mode)
{
   return (_openfile(_fname, _search_fp(), _mode));
}



 

 
/*****************************************************************************/
/* FREOPEN  -  Switch a FILE pointer to a different stream                   */
/*                                                                           */
/*    This function attempts to close any file associated with _FP, and then */
/*    reassigns _FP to the file _FNAME by calling _OPENFILE.  It returns a   */
/*    pointer to the stream if successful, or NULL if the function is not    */
/*    successful.                                                            */
/*                                                                           */
/*****************************************************************************/
FILE *freopen(const char *_fname, const char *_mode, register FILE *_fp)
{
   fclose(_fp); 
   return (_openfile(_fname, _fp, _mode));
}
 





/*****************************************************************************/
/* _SEARCH_FP  -  Find an open slot in the file table                        */
/*                                                                           */
/*    This function looks through the array _ftable, searching for a null    */
/*    pointer which indicates an empty slot.  It mallocs a stream for that   */
/*    slot, and assigns a pointer to it there, initializing it and returning */
/*    it to the calling function.                                            */
/*                                                                           */
/*****************************************************************************/
static FILE *_search_fp()
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int index;
	
   /*------------------------------------------------------------------------*/
   /* Search the file table for an empty slot.  Return a NULL is there       */
   /* aren't any available.                                                  */
   /*------------------------------------------------------------------------*/
   for(index = 0; (index < _ft_end) && _ftable[index].fd != -1; index++);
   if (index == _NFILE) return (NULL);
   if (index == _ft_end) _ft_end++;

   /*------------------------------------------------------------------------*/
   /* Initialize the new stream.                                             */
   /*------------------------------------------------------------------------*/
   memset(&_ftable[index], '\0', sizeof(FILE));

   return (&_ftable[index]);
}



 
 

/*****************************************************************************/
/* _OPENFILE   -  Set file flags, and call lowlevel OPEN                     */
/*                                                                           */
/*    This function sets FILE flags for reading or writing by the character  */
/*    string _MODE.  It then calls the lowlevel OPEN function to open the    */
/*    file, and assigns the file descriptor returned from that function into */
/*    the FD member of the stream.                                           */
/*                                                                           */
/*****************************************************************************/
static FILE *_openfile(const char *_fname, register FILE *_fp, const char 
                       *_mode)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int         wr, 
               bin, 
               plus;
   unsigned    lflags   =  0;

   if (! _fp) return (NULL);
 
   /*------------------------------------------------------------------------*/
   /* SETUP _CLEANUP_PTR SO THAT ALL OPENED FILES WILL BE CLOSED AT EXIT.    */
   /*------------------------------------------------------------------------*/
   _cleanup_ptr = _cleanup;
   
   /*------------------------------------------------------------------------*/
   /* Set the flags in the stream to reflect to I/O mode of the stream to be */
   /* opened.                                                                */
   /*------------------------------------------------------------------------*/
   wr    = _mode[0];
   bin   = ((_mode[1] == 'b') || (_mode[2] == 'b'));
   plus  = ((_mode[1] == '+') || (_mode[2] == '+'));
 
   _fp->flags = 0;

   if(!plus)
      _SET(_fp, (wr == 'r') ? _MODER : 
                (wr == 'w' || wr == 'a') ? _MODEW : 0);

   _SET(_fp, (wr == 'a') ? _MODEA : 0);
   _SET(_fp, (bin)  ? _MODEBIN : 0);
   _SET(_fp, (plus) ? _MODERW  : 0);
 
   if(bin) lflags |= (O_BINARY);

   /*------------------------------------------------------------------------*/
   /* Set the flags in LFLAGS to reflect the flags that will be necessary to */
   /* call the lowlevel OPEN function properly for this stream.              */
   /*------------------------------------------------------------------------*/
   switch (wr)
   {
      case 'r' :  lflags |= (plus) ? O_RDWR : O_RDONLY;
                  break;
 
      case 'a' :  lflags |= (plus) ? O_RDWR : O_WRONLY;
                  lflags |= (O_APPEND | O_CREAT);
                  break;
 
      case 'w' : lflags |= (plus) ? O_RDWR : O_WRONLY;
                  lflags |= (O_TRUNC | O_CREAT);
                  break;
   }

   /*------------------------------------------------------------------------*/
   /* Call the lowlevel OPEN function, and store the returned file           */
   /* descriptor into the stream.  If the OPEN function fails, return NULL.  */
   /*------------------------------------------------------------------------*/
   if ((_fp->fd = open(_fname, lflags, 0666)) < 0) return (NULL);

   return (_fp);
}






/*****************************************************************************/
/* _CLEANUP   -  CLOSE ALL OPEN STREAMS.  THIS IS CALLED BY EXIT() IF A FILE */
/*               IS EVER OPENED OR A BUFFER IS EVER CREATED.                 */
/*****************************************************************************/
void _cleanup()
{
   int j;

   /*------------------------------------------------------------------------*/
   /* CLOSE ALL STREAMS THAT ARE CURRENTLY OPEN.                             */
   /*------------------------------------------------------------------------*/
   fclose(&_ftable[0]);
   for(j = 1; j < _ft_end; j++) 
       if (_ftable[j].fd > 0) fclose(&_ftable[j]); 
}

fprintf.c/      868562438   0     0     0       2823      `
/*****************************************************************************/
/*  FPRINTF.C v1.10#                                                         */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FPRINTF  -  Print formatted output to a stream                         */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);






/*****************************************************************************/
/* FPRINTF  -  Print formatted output to a stream                            */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream _FP.              */
/*                                                                           */
/*****************************************************************************/
int fprintf(FILE *_fp, const char *_format, ...)
{
   va_list  _ap;
   int rval;
   char *fptr = (char *)_format;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (-1);

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)_fp, _outc, _outs);
   va_end(_ap);
   return (rval);
}
 
 
 
 
 

/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }






/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


fputc.c/        868562438   0     0     0       4283      `
/*****************************************************************************/
/*  FPUTC.C v1.10#                                                           */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PUTC     -  Write a character to a stream                              */
/*    PUTCHAR  -  Write a character to stdout                                */
/*    FPUTC    -  Write a character to a stream                              */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _wrt_ok(FILE *_fp);
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* PUTC  -  Write a character to a stream                                    */
/*                                                                           */
/*    This function is equivalent to FPUTC.                                  */
/*                                                                           */
/*****************************************************************************/
int putc(int _x, FILE *_fp) { return(fputc(_x, _fp)); }






/*****************************************************************************/
/* PUTCHAR  -  Write a character to stdout                                   */
/*                                                                           */
/*    This function calls a macro defined in STDIO.H, which in turn calls    */
/*    FPUTC, with stdout as its stream argument.                             */
/*                                                                           */
/*****************************************************************************/
int putchar(int _x) { return(_putchar(_x)); }






/*****************************************************************************/
/* FPUTC -  Write a character to a stream                                    */
/*                                                                           */
/*    This function writes character _C into the stream specified by _FP.    */
/*    Upon success, it returns the character written.  Upon failure, it      */
/*    returns an EOF.                                                        */
/*                                                                           */
/*****************************************************************************/
int fputc(int _c, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      char cbuf = (char)_c;

      if((write(_fp->fd, &cbuf, 1)) == -1)
      {
         _SET(_fp, _STATERR);
         return (EOF);
      }
      else return ((unsigned char)_c);
   }

   /*------------------------------------------------------------------------*/
   /* Put the character in the buffer.                                       */
   /*------------------------------------------------------------------------*/
   *(_fp->pos++) = (unsigned char)_c;

   /*------------------------------------------------------------------------*/
   /* If the buffer is full, or a line-buffered stream reached a newline     */
   /* character, flush it.                                                   */
   /*------------------------------------------------------------------------*/
   if((_fp->pos == _fp->bufend) || (_STCHK(_fp, _IOLBF) && _c == '\n'))
      if(_doflush(_fp))
      {
         _SET(_fp, _STATERR);
         return (EOF);
      }

   return((unsigned char)_c);
}


fputs.c/        868562438   0     0     0       4690      `
/*****************************************************************************/
/*  FPUTS.C v1.10#                                                           */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PUTS  -  Write a string to stdout                                      */
/*    FPUTS -  Write a string to a stream                                    */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"

extern int _wrt_ok(FILE *_fp);
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* PUTS  -  Write a string + newline to stdout.                              */
/*                                                                           */
/*    This function calls FPUTS, with stdout as the stream argument.         */
/*                                                                           */
/*****************************************************************************/
int puts(const char *_ptr) 
{ 
    int count = fputs(_ptr, stdout);
    count += fputs("\n", stdout); 
    return count;
}



/*****************************************************************************/
/* FPUTS -  Write a string to a stream                                       */
/*                                                                           */ 
/*    This function writes string _PTR to stream _FP, returning the number   */
/*    of characters written upon success, or an EOF upon failure.            */
/*                                                                           */ 
/*****************************************************************************/
int fputs(const char *_ptr, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   size_t   num_left;
   char     *fpos          = (char *)_ptr;
   int      room_left,
            flush_flag     = 0,
            num_to_write;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp)) return (EOF);
 
   room_left = (int)(_fp->bufend - _fp->pos);
   num_left = strlen(_ptr);

   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF) return (write(_fp->fd, _ptr, num_left));
 
   /*------------------------------------------------------------------------*/
   /* Write the string into the buffer, flushing it when full.               */
   /*------------------------------------------------------------------------*/
   while(num_left > 0)
   {
      num_to_write = (num_left > room_left) ? room_left : num_left;
      if((_BUFFMODE(_fp) == _IOLBF) && memchr(fpos, '\n', num_to_write))
      { 
         num_to_write = (char *)memchr(fpos, '\n', num_to_write) - fpos + 1;
         flush_flag = 1;
      }
      memcpy(_fp->pos, fpos, num_to_write);

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      _fp->pos  += num_to_write;
      fpos      += num_to_write;
      num_left  -= num_to_write;
      room_left -= num_to_write;

      /*---------------------------------------------------------------------*/
      /* If the buffer is full, flush it.  Any I/O errors cause this         */
      /* function to exit, returning an EOF.                                 */
      /*---------------------------------------------------------------------*/
      if(room_left == 0 || flush_flag)
      {
         if(_doflush(_fp))
         {
            _SET(_fp, _STATERR);
            return (EOF);
         }
         room_left = (int)(_fp->bufend - _fp->pos);
         _SET(_fp, _MODEW);
         flush_flag = 0;
      }
   }
   return(strlen(_ptr));
}

frcaddd.c/      868562438   0     0     0       3092      `
/****************************************************************************/
/*  frcaddd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:14 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

int FRCADDF(int lx, REAL_2UNS *lf, 
            int rx, REAL_2UNS *rf)
/*---------------------------------------------------------------------------*/
/* Fractional ADD the value defined by *lf (fractional part of left),        */
/* lx (exponent part of left) with *rf,rx; placing the resultant fractional  */
/* part in lf and passing the resultant exponent part as the function result.*/
/*---------------------------------------------------------------------------*/
{
   int sc, sign, dx;
   REAL_2UNS *tf;

   /* Compute shift needed to align radix points.  */
   /*  Swap inputs so left is larger.              */
   dx = lx; sc = dx - rx;
   if (sc < 0) { sc = -sc; dx = rx; tf = lf; lf = rf; rf = tf;}

   if (sc < 52 +2) {	/* significant bits to add */
      unsigned  lf_u_msh = lf->u.msh;
      unsigned  lf_u_lsh = lf->u.lsh;
      unsigned  rf_u_msh = rf->u.msh;
      unsigned  rf_u_lsh = rf->u.lsh;

      /* Reformat so that there's a guard digit at the bottom of the lsw */
      LSH1(lf_u_msh, lf_u_lsh);

      /* shift to align radix points */
      sc--; /* one less because of the guard digit */
      if (sc >= 32  ) {
         rf_u_lsh = rf_u_msh;
         rf_u_msh = (int )rf_u_msh >> (REAL_FRC_MSBs)+2;
         sc -= 32  ;
      }
      if (sc > 0) {
         rf_u_lsh = (rf_u_msh << 32  -sc) + (rf_u_lsh >> sc);
         rf_u_msh = (int )rf_u_msh >> sc;
      } else if (sc < 0) {
         LSH1(rf_u_msh, rf_u_lsh);
      }

      /* add */
      lf_u_msh += rf_u_msh;
      lf_u_lsh += rf_u_lsh;
      if (lf_u_lsh < rf_u_lsh) lf_u_msh += 1;

      /* back to sign-magnitude form */
      sign = 0;
      if ((int )lf_u_msh < 0) {
         sign = MINUS;
         lf_u_msh = ~lf_u_msh + ((lf_u_lsh = -lf_u_lsh) == 0);
      }

      /* renormalize */
      if (lf_u_msh < REAL_HIDDEN_BIT*2) {    /* cancellation */
         lf->u.msh = lf_u_msh;
         lf->u.lsh = lf_u_lsh;
         if ((sc = RENORMF(lf)+2) <= 0) return 0;
         dx -= sc;
         lf->u.msh |= sign;
      } else {
         if (lf_u_msh >= REAL_HIDDEN_BIT*4) {
            RSH1(lf_u_msh, lf_u_lsh);
            dx +=1;
         }
         if ((lf_u_lsh += 1) == 0) lf_u_msh += 1;  /* round with carry */

         RSH1(lf_u_msh, lf_u_lsh);

         lf_u_msh |= sign;

         lf->u.msh = lf_u_msh;
         lf->u.lsh = lf_u_lsh;
     }
   }
   /* back to sign-magnitude form */
   else if ((int )lf->u.msh < 0) {NEG2sCOMP((*lf)); lf->u.msh |= MINUS;}

   if (lx < rx) *rf = *lf;
                
   return dx;
} /* FRCADD */

frcaddf.c/      868562438   0     0     0       561       `
/****************************************************************************/
/*  frcaddf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:15 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );


frcdivd.c/      868562438   0     0     0       5776      `
/****************************************************************************/
/*  frcdivd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:14 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

int FRCDIVF(REAL_2UNS *q, REAL_2UNS *l, REAL_2UNS *r)
/*---------------------------------------------------------------------------*/
/* FRaCtional DIVide                                                         */
/* Forms the quotient of l/r (each a fixed point                             */
/* operand in range 1..2-, with radix point at REAL_FRC_BITS).               */
/* Returns in q the uppermost bits as a fixed point number in the range      */
/* 1..2-, with the radix point at REAL_FRC_BITS, rounded.                    */
/* Returns -1 if the product had to be right shifted by 1 to be in the       */
/* range 1..2-, 0 otherwise.                                                 */
/*---------------------------------------------------------------------------*/
{
   
   int  rsh, inv_div, i, t; 

   /* bigint rm[4], dv[4], quo[4];  C6x compiler barfs on arrays this week. */
   int  rm_0, dv_0, quo_0;
   int  rm_1, dv_1, quo_1;
   int  rm_2, dv_2, quo_2;
   int  rm_3, dv_3, quo_3;

   /* break up the left operand into multiply-sized chunks */
   rm_0 =   l->u.msh >> (REAL_FRC_MSBs- (32  /2-2) ); 
   rm_1 = ((l->u.msh << (2* (32  /2-2)  - REAL_FRC_MSBs)) +
            (l->u.lsh >> (32  -2* (32  /2-2) +REAL_FRC_MSBs))) & ((((int )1)<< (32  /2-2) )-1) ;
   rm_2 = ( l->u.lsh >> (32  -3* (32  /2-2) +REAL_FRC_MSBs) ) & ((((int )1)<< (32  /2-2) )-1) ;
   rm_3 = ( l->u.lsh << (4* (32  /2-2) -REAL_FRC_MSBs- 32  ) ) & ((((int )1)<< (32  /2-2) )-1) ;

   /* same for right */
   dv_0 =   r->u.msh >> (REAL_FRC_MSBs- (32  /2-2) ); 
   dv_1 = ((r->u.msh << (2* (32  /2-2)  - REAL_FRC_MSBs)) +
            (r->u.lsh >> (32  -2* (32  /2-2) +REAL_FRC_MSBs))) & ((((int )1)<< (32  /2-2) )-1) ;
   dv_2 =  (r->u.lsh >> (32  -3* (32  /2-2) +REAL_FRC_MSBs) ) & ((((int )1)<< (32  /2-2) )-1) ;
   dv_3 =  (r->u.lsh << (4* (32  /2-2) -REAL_FRC_MSBs- 32  ) ) & ((((int )1)<< (32  /2-2) )-1) ;

   /*------------------------------------------------------------------------*/
   /* Compute an approximate inverse of d, in the range 0.5..1.0,            */
   /* with radix point at IW bits                                            */
   /*------------------------------------------------------------------------*/
   /* linear approximation */
   inv_div = ((int )(( 1.411622 )*(((int )1)<<(  (32  /2-2)  ))))  - ((((int )(( 0.470459 )*(((int )1)<<( (32  /2-2)  ))))  * dv_0) >> (32  /2-2) );

   /* newton iteration */
   inv_div =
      ( (((int )(( 2.0 )*(((int )1)<<( (32  /2-2)  )))) -((inv_div * dv_0) >> (32  /2-2) ))* inv_div) >> 2* (32  /2-2) - (32  /2) ;
   inv_div =
      (((((int )(( 1.0 )*(((int )1)<<( (32  /2)  )))) -((inv_div * dv_0) >> (32  /2-2) ))* inv_div) >> (32  /2) ) + inv_div;

   /*------------------------------------------------------------------------*/
   /* Long division.                                                         */
   /* Estimate the quoient in MS * IW bits, keeping MS bits.                 */
   /* Then multiply by the divisor, subtract from the remainder              */
   /* to get a new remainder.   Left shift and do it again...                */
   /*------------------------------------------------------------------------*/
   t = 0;
   for (i = 0; i <= 3; i += 1) {
      int  p = (t * inv_div) >> (32  /2) - (32  /2-2) ;
      p += (rm_0 * inv_div) >> (32  /2) ;
      rm_0 += t << (32  /2-2) ; 

      /* quo[i] = p; */
      switch (i) {
       case 0: quo_0 = p; break;
       case 1: quo_1 = p; break;
       case 2: quo_2 = p; break;
       case 3: quo_3 = p; break;
      }
      t = -p;

      /* now form t * divisor in parts, and subtract from remainder */
      p = dv_0 * t;  rm_0 += p >> (32  /2-2) ;  rm_1 += p & ((((int )1)<< (32  /2-2) )-1) ;
      p = dv_1 * t;  rm_1 += p >> (32  /2-2) ;  rm_2 += p & ((((int )1)<< (32  /2-2) )-1) ;
      p = dv_2 * t;  rm_2 += p >> (32  /2-2) ;  rm_3 += p & ((((int )1)<< (32  /2-2) )-1) ;
      p = dv_3 * t;  rm_3 += p >> (32  /2-2) ;

      /* propagate carries */
      rm_2 += rm_3 >> (32  /2-2) ;
      rm_1 += rm_2 >> (32  /2-2) ;
      rm_0 += rm_1 >> (32  /2-2) ;

      /* shift the remainder left by MS bits */
      t = rm_0;
      rm_0 = rm_1 & ((((int )1)<< (32  /2-2) )-1) ;
      rm_1 = rm_2 & ((((int )1)<< (32  /2-2) )-1) ;
      rm_2 = rm_3 & ((((int )1)<< (32  /2-2) )-1) ;
      rm_3 = p    & ((((int )1)<< (32  /2-2) )-1) ;
   }

   /* repackage into 2 words, with 2*MS bits each */
   quo_2 = (quo_2 << (32  /2-2) ) + quo_3;
   quo_0 = (quo_0 << (32  /2-2) ) + quo_1 + (quo_2 >> 2* (32  /2-2) );
   quo_1 =  quo_2 & ((((int )1)<<(2* (32  /2-2) ))-1);

   /* check if left shift is needed for normalization */
   rsh = 0;
   if (quo_0 < (((int )1) << 2* (32  /2-2) )) {
      quo_0 <<= 1; quo_1 <<= 1; rsh = -1;
   }

   /* now round and re-align as needed for our result */
   quo_1   = ((quo_1 >> 4* (32  /2-2) - 52 -1) +1) >> 1;
   q->u.lsh =  (quo_0 << 52 -2* (32  /2-2) ) + quo_1;
   q->u.msh = ((quo_1 >> 52 -2* (32  /2-2) ) + quo_0) >>
               2* (32  /2-2) -REAL_FRC_MSBs;

   /* watch out for round up, which can only be FFFF => 10000 */
   if (q->u.msh >= REAL_HIDDEN_BIT*2) {
       q->u.msh = REAL_HIDDEN_BIT; rsh += 1;
   }

   return rsh;
} /* FRCDIVF */

frcdivf.c/      868562438   0     0     0       3132      `
/****************************************************************************/
/*  frcdivf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:16 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

unsigned  FRCDIVF(unsigned  l, unsigned  r)
/*---------------------------------------------------------------------------*/
/* FRaCtional DIVide                                                         */
/* Forms the quotient of l/r (r is a fixed point                             */
/* operand in range 1..2-, with radix point at REAL_FRC_BITS).               */
/* Returns the quotient as a fixed point number in the range                 */
/* 0.5+..2-, with the radix point at REAL_FRC_BITS+1.                        */
/*---------------------------------------------------------------------------*/
{
   
   int  inv_div, rem, quo, t, rhi, rlo;

   /*------------------------------------------------------------------------*/
   /* Compute an approximate inverse of r, in the range 0.5..1.0,            */
   /* with radix point at IW bits                                            */
   /*------------------------------------------------------------------------*/
   rhi = r >> 23 - (32  /2-2) ; 
   /* linear approximation */
   inv_div = ((int )(( 1.411622 )*(((int )1)<<( (32  /2-2)  ))))  - ((((int )(( 0.470459 )*(((int )1)<<( (32  /2-2)  ))))  * rhi) >> (32  /2-2) );

   /* newton iteration */
   inv_div = ((((int )(( 2.0 )*(((int )1)<<( (32  /2-2)  ))))  - ((inv_div * rhi) >> (32  /2-2) )) * inv_div) >> (32  /2-2) ;
   inv_div = ((((int )(( 2.0 )*(((int )1)<<( (32  /2-2)  ))))  - ((inv_div * rhi) >> (32  /2-2) )) * inv_div) >> (32  /2-2) ;

   /*------------------------------------------------------------------------*/
   /* Long division.                                                         */
   /* Estimate the quotient in REAL_FRC_BITS * IW bits, keeping DW bits.     */
   /* Form the remainder in two steps to avoid intermediate overflow.        */
   /*------------------------------------------------------------------------*/
   rem = l; quo = 0; rlo = r & ((((int )1)<< 23 - (32  /2-2) )-1);
   do {
      t = ((rem >> (23 - (32  /2-2) ))* inv_div)>> (32  /2-2) *2- ((32  /2-2) -1) ;
      rem = (((rem << ((32  /2-2) -1) + (32  /2-2) - 23 )
             - rhi * t) << 23 - (32  /2-2) )
            - rlo * t;
      quo = (quo << ((32  /2-2) -1) ) + t;
   }
   while (quo < REAL_HIDDEN_BIT);

   /*------------------------------------------------------------------------*/
   /* Align radix point of result to REAL_FRC_BITS+1                         */
   /*------------------------------------------------------------------------*/

    quo >>= ((23 )/ ((32  /2-2) -1)  +1)* ((32  /2-2) -1)  - 23 -1;
    return quo;
} /* FRCDIVF */

frcmpyd.c/      868562438   0     0     0       3086      `
/****************************************************************************/
/*  frcmpyd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:15 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

#include <c6x.h> 
 
int FRCMPYF(REAL_2UNS *p, REAL_2UNS *l, REAL_2UNS *r)
/*---------------------------------------------------------------------------*/
/* Fractional MultiPlY                                                       */
/* Forms the product (2*REAL_FRC_BITS bits) of l and r (each a fixed point   */
/* operand in range 1..2-, with radix point at REAL_FRC_BITS).               */
/* Returns in p the uppermost bits as a fixed point number in the range      */
/* 1..2-, with the radix point at REAL_FRC_BITS.                             */
/* Returns 1 if the product had to be right shifted by 1 to be in the        */
/* range 1..2-, 0 otherwise.                                                 */
/*---------------------------------------------------------------------------*/
{

   REAL_2UNS lp = *l;
   REAL_2UNS rp = *r;

   unsigned long p0, p1, p2, p3, msh;

   /* shift left so that format is: */
   /* 01.xxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxx0000000000 */

   LEFT_SHIFT(lp, 32  - REAL_FRC_MSBs - 2);
   LEFT_SHIFT(rp, 32  - REAL_FRC_MSBs - 2);

   p0 = _mpyhu (lp.u.msh, rp.u.msh);
   p1 = _mpyhlu(lp.u.msh, rp.u.msh);
   p2 = _mpyhu (lp.u.msh, rp.u.lsh);
   p3 = _mpyhlu(lp.u.msh, rp.u.lsh);

   /* note that accumulates are 40-bits big so that no bits are lost */
   p1 += _mpylhu(lp.u.msh, rp.u.msh);
   p2 += _mpyu  (lp.u.msh, rp.u.msh);
   p3 += _mpylhu(lp.u.msh, rp.u.lsh);

   p2 += _mpyhu (lp.u.lsh, rp.u.msh);
   p3 += _mpyhlu(lp.u.lsh, rp.u.msh);

   p3 += _mpylhu(lp.u.lsh, rp.u.msh);

   /* sum propagate, repackage into 2 int's, keeping one more bit than    */
   /* needed, round, then carry propagate                                 */
   p0 += p1 >> (32  /2) ;
   p1 = ((p1 & ((((unsigned long)1)<< (32  /2) )-1) ) << (32  /2) ) + p2 + (p3 >> (32  /2) );

   p1 = (p1 >> ((2* 32 -4)- 52 -1))+1;  /*right align & round */
   msh = p0 + (p1 >> (52 -(32 -4)+1));/*carry propagate*/

   /* Repackage the result into the desired fixed point format.       */
   /* At this point the extra bit we kept for rounding is eliminated. */

   if (msh >= (((long)1) << (32  -3))) {      /* normalize */
      p1 = (((p1-1) >> 1) + 1) >> 1;  /* right shift and re-round */
      p->u.lsh = (int)p1 + (int)(p0 << (52 -(32 -4)-1));
      p->u.msh = ((p1>>(52 -(32 -4)-1)) + p0) >> 
                  ((32 -4)-REAL_FRC_MSBs+1);
      return 1;  
   }
   p->u.lsh = (int)(p1 >> 1) + (int)(p0 << (52 -(32 -4)));
   p->u.msh = msh >> (32 -4)-REAL_FRC_MSBs;

   return 0;

} /* FRCMPYF */

frcmpyf.c/      868562438   0     0     0       1798      `
/****************************************************************************/
/*  frcmpyf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:16 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

#include <c6x.h> 
 
unsigned  FRCMPYF(unsigned  l, unsigned  r)
/*---------------------------------------------------------------------------*/
/* Fractional MultiPlY                                                       */
/* Forms the product (2*REAL_FRC_BITS bits) of l and r (each a fixed point   */
/* operand in range 1..2-, with radix point at REAL_FRC_BITS).               */
/* Returns uppermost bits as a fixed point number in the range               */
/* 1..4-, with the radix point at REAL_FRC_BITS+1.                           */
/*---------------------------------------------------------------------------*/
{
   /*------------------------------------------------------------------------*/
   /* Re-align the inputs, split them into halves,                           */
   /* form all the cross products and add 'em up.                            */
   /*------------------------------------------------------------------------*/

   unsigned  p;

   l <<= (32  -REAL_FRC_MSBs)/2 + 1;  /* so hi word of product */
   r <<= (32  -REAL_FRC_MSBs)/2 + 1;  /* has one rounding bit  */

   p = _mpyu(l, r) >> (32  /2) ;

   p += _mpyhlu(l, r);
   p += _mpyhlu(r, l);

   return _mpyhu(l,r) + (p >> (32  /2) );

} /* FRCMPY */

fread.c/        868562438   0     0     0       4494      `
/*****************************************************************************/
/*  FREAD.C v1.10#                                                           */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FREAD       -  Read a block of bytes from a stream                     */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"
 
extern int  _rd_ok(FILE *_fp);
extern void _buff_read(FILE *_fp);





/*****************************************************************************/
/* FREAD -  Read a block of bytes from a stream                              */
/*                                                                           */
/*    This function reads _COUNT blocks of _SIZE size from stream _FP, and   */
/*    stores them in string _PTR.  The function returns the number of        */
/*    blocks read.                                                           */
/*                                                                           */
/*****************************************************************************/
size_t fread(void *_ptr, size_t _size, size_t _count, FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned char     *fpos       = (unsigned char *)_ptr;
            size_t   num_left    = _size * _count,
                     num_read    = 0,
                     num_to_read = 0;
 
   /*------------------------------------------------------------------------*/
   /* Make sure that the file is readable.                                   */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp) || _size == 0 || _count == 0) return (0);
 
   while (num_left > 0)
   {
      /*---------------------------------------------------------------------*/
      /* If the stream is non-buffered, call the lowlevel READ function.     */
      /*---------------------------------------------------------------------*/
      if(_BUFFMODE(_fp) == _IONBF)
      {
         num_read = (size_t)(read(_fp->fd, (char *)fpos, num_left));
         if(num_read != num_left)
         {
            _SET(_fp, (num_read == 0) ? _STATEOF : _STATERR);
            if ((int)num_read == -1) num_read = 0;
         }
         return (num_read / _size);
      }

      /*---------------------------------------------------------------------*/
      /* If the buffer has been completely read, fill it up.  Exit the loop  */
      /* if an I/O error occurs, or the end of the file is reached.          */
      /*---------------------------------------------------------------------*/
      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop)  _buff_read(_fp);
      if(_STCHK(_fp, (_STATERR | _STATEOF))) break;

      /*---------------------------------------------------------------------*/
      /* Determine how many characters can fit in the buffer, and read them  */
      /* in.                                                                 */
      /*---------------------------------------------------------------------*/
      num_to_read = (num_left < (_fp->buff_stop - _fp->pos)) ?
                    num_left : (_fp->buff_stop - _fp->pos);
      memcpy(fpos, _fp->pos, num_to_read);

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      fpos += num_to_read;
      _fp->pos += num_to_read;
      num_read += num_to_read;
      num_left -= num_to_read;
   
 
   }

   /*------------------------------------------------------------------------*/
   /* Clear the _UNGETC flag in the stream, and return the number of blocks  */
   /* read.                                                                  */
   /*------------------------------------------------------------------------*/
   _UNSET(_fp, _UNGETC);
 
   return (num_read / _size);
 
}
 
frexp.c/        868562438   0     0     0       2159      `
/****************************************************************************/
/*  frexp  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:53 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FREXPF(REAL x, int *exp)
/*---------------------------------------------------------------------------*/
/* Decompose x into f and e such that                                        */
/* x == f * RADIX**e and 1/RADIX <= abs(f) < 1                               */
/* Return e in *exp and f as function result.                                */
/*---------------------------------------------------------------------------*/
{

   {
   /* Deals properly with NAN, +/- INFINITY, +/- ZERO, denormalized numbers */
   
      REAL y;
      int *ptr;
      int uy, e;
    
      CPYF(y,x);
   
      ptr = (int *)(&y) + (((64 / 32 )-1)*(_LITTLE_ENDIAN )) ;
      uy = *ptr;
      e = ((uy >> (32 - (11 +1) )) & ((1<< 11 )-1) ); /* maybe get compare to 0 free*/
   
      if (e == 0) /* +/- ZERO or denormalized? */
      {
          if EQZF(y) { *exp = 0; return x; } /* +/- ZERO */

          MPYF3(y,x,CNST(9007199254740992.0) ); /* its not denormalized now! */
          uy = *ptr;
          e = ((uy >> (32 - (11 +1) )) & ((1<< 11 )-1) ) - 53 ;
      }
      else if (e == ((1<< 11 )-1) ) { /* infinities and NAN's */
         if      LSSF(y,CNST(-1.7976931348623157e+308) ) { errno = EDOM; CPYF(y,CNST(-1.7976931348623157e+308) );}
         else if GTRF(y,CNST( 1.7976931348623157e+308) ) { errno = EDOM; CPYF(y,CNST( 1.7976931348623157e+308) );}
         else                          { errno = EDOM; *exp = 0; return ZERO;}
         
      }
      e -= (1023 -1) ;
   
      *exp = e;
      *ptr = (uy & (((1<<(32 -1))+(1<<(52 % 32 ))-1)  >> (32- 32 ))) | /* out with the old ...*/
             (((1023 -1) ) << (32 - (11 +1) ));       /* and in with the new */
      return y;
   }

} /* FREXPF */

frexpf.c/       868562438   0     0     0       2112      `
/****************************************************************************/
/*  frexpf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:21 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL FREXPF(REAL x, int *exp)
/*---------------------------------------------------------------------------*/
/* Decompose x into f and e such that                                        */
/* x == f * RADIX**e and 1/RADIX <= abs(f) < 1                               */
/* Return e in *exp and f as function result.                                */
/*---------------------------------------------------------------------------*/
{

   {
   /* Deals properly with NAN, +/- INFINITY, +/- ZERO, denormalized numbers */
   
      REAL y;
      int *ptr;
      int uy, e;
    
      CPYF(y,x);
   
      ptr = (int *)(&y) + (((32 / 32 )-1)*(_LITTLE_ENDIAN )) ;
      uy = *ptr;
      e = ((uy >> (32 - (8 +1) )) & ((1<< 8 )-1) ); /* maybe get compare to 0 free*/
   
      if (e == 0) /* +/- ZERO or denormalized? */
      {
          if EQZF(y) { *exp = 0; return x; } /* +/- ZERO */

          MPYF3(y,x,CNST(16777216.0) ); /* its not denormalized now! */
          uy = *ptr;
          e = ((uy >> (32 - (8 +1) )) & ((1<< 8 )-1) ) - 24 ;
      }
      else if (e == ((1<< 8 )-1) ) { /* infinities and NAN's */
         if      LSSF(y,CNST(-3.402823466E+38) ) { errno = EDOM; CPYF(y,CNST(-3.402823466E+38) );}
         else if GTRF(y,CNST( 3.402823466E+38) ) { errno = EDOM; CPYF(y,CNST( 3.402823466E+38) );}
         else                          { errno = EDOM; *exp = 0; return ZERO;}
         
      }
      e -= (127 -1) ;
   
      *exp = e;
      *ptr = (uy & (((1<<(32 -1))+(1<<(23 % 32 ))-1)  >> (32- 32 ))) | /* out with the old ...*/
             (((127 -1) ) << (32 - (8 +1) ));       /* and in with the new */
      return y;
   }

} /* FREXPF */
fscanf.c/       868562438   0     0     0       5573      `
/*****************************************************************************/
/*  FSCANF.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSCANF      -  Read formatted input from a stream                      */
/*    SCANF       -  Read formatted input from stdin                         */
/*    _INPCHAR    -  Get a character from the stream                         */
/*    _UNINPCHAR  -  Put a character back onto the stream                    */
/*    _CHKMBC     -  Check that the characters match the input               */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static char _inpchar(void **inp);
static void _uninpchar(void **inp, char outchar);
static int _chkmbc(void **inp, char **_format, int *num_read);






/*****************************************************************************/
/* FSCANF   -  Read formatted input from a stream                            */
/*                                                                           */
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */ 
/*****************************************************************************/
int fscanf(FILE *_fp, const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if (_fp->fd == -1) return (EOF);

   return (_scanfi((void *)_fp, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
   
}






/*****************************************************************************/
/* SCANF -  Read formatted input from stdin                                  */
/*                                                                           */ 
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */ 
/*****************************************************************************/ 
int scanf(const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if (stdin->fd == -1) return (EOF);

   return (_scanfi((void *)stdin, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
 
}




 


/*****************************************************************************/
/* _INPCHAR -  Get a character from the stream                               */
/*****************************************************************************/
static char _inpchar(void **inp) { return (fgetc((FILE *)(*inp))); }






/*****************************************************************************/
/* _UNINPCHAR  -  Put a character back onto the stream                       */
/*****************************************************************************/
static void _uninpchar(void **inp, char outchar)
{ 
   ungetc(outchar, (FILE *)*inp);
}






/*****************************************************************************/
/* _CHKMBC  -  Check that the characters match the input                     */
/*                                                                           */
/*    Check that all characters in the format string that are not part of a  */
/*    conversion specification match the input, until the next '%' or the    */
/*    end of the format string is reached.  The function returns an EOF if   */
/*    the end of the file is reached prematurely, a 0 upon reaching the end  */
/*    of the format string, or a 1 if a '%' is encountered.                  */
/*                                                                           */
/*****************************************************************************/
static int _chkmbc(void **inp, char **_format, int *num_read)
{
   FILE        *_fp = (FILE *)*inp;
   signed char  c;

   /*------------------------------------------------------------------------*/
   /* If there is a white space character in the format statement, skip to   */
   /* the next non-white space character in the input.                       */
   /*------------------------------------------------------------------------*/
   while (isspace(**_format))
   {
      for(c = fgetc(_fp);isspace(c);c = fgetc(_fp)) (*num_read)++;
      ungetc(c, _fp);
      (*_format)++;
   }

   for(;(**_format != '%') && (**_format != '\0');)
      if (*((*_format)++) != (c = fgetc(_fp))) 
      {
         ungetc(c, _fp);
         return ((c == EOF) ? EOF : 0);
      }
      else (*num_read)++;

   if (**_format == '%') return 1;
   else return (0);
}
      

fseek.c/        868562438   0     0     0       2263      `
/*****************************************************************************/
/*  FSEEK.C v1.10#                                                           */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSEEK -  Reposition the file pointer of a stream                       */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _doflush(FILE *_fp);




/*****************************************************************************/ 
/* FSEEK -  Reposition the file pointer of a stream                          */
/*                                                                           */ 
/*    This funtion flushes stream _FP, clears the EOF and I/O Error flags,   */
/*    repositions the file pointer of the stream.  It returns a 0 upon       */
/*    success, and an EOF upon failure.                                      */
/*                                                                           */ 
/*****************************************************************************/ 
int fseek(register FILE *_fp, long _offset, int _ptrname)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* When positioning to a location relative to the current location,       */
   /* adjust for the fact that there may be something in the buffer.         */
   /*------------------------------------------------------------------------*/
   if(_ptrname == SEEK_CUR && _STCHK(_fp, _MODER))
      _offset -= (_fp->buff_stop - _fp->pos);

   _doflush(_fp);

   _UNSET(_fp, (_STATEOF | _UNGETC));
   
   if((lseek(_fp->fd, _offset, _ptrname)) == -1) return (EOF);
   
   return (0);
}
   

fsetpos.c/      868562438   0     0     0       1065      `
/*****************************************************************************/
/*  FSETPOS.C v1.10#                                                         */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSETPOS  -  Position the file indicator for stream _FP                 */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int errno;
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* FSETPOS  -  Position the file indicator for stream _FP                    */
/*****************************************************************************/
int fsetpos(FILE *_fp, const fpos_t *_pos)
{
   return (fseek(_fp, *_pos, SEEK_SET));
}


ftell.c/        868562438   0     0     0       3047      `
/*****************************************************************************/
/*  FTELL.C v1.10#                                                           */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int errno;
extern int _ft_end;






/*****************************************************************************/
/* FTELL -  Get the location of the file pointer in a stream                 */
/*                                                                           */
/*    This function gets the current location of the file pointer for the    */
/*    given stream, and returns it after adjusting it for any inaccuracies   */
/*    that buffering might have caused.                                      */
/*                                                                           */
/*****************************************************************************/
long ftell(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   fpos_t  _pos;
   int   adjust   = 0;

   /*------------------------------------------------------------------------*/
   /* If the stream pointer given is not currently open, return a -1.        */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) { errno = 5; return (-1L);}

   /*------------------------------------------------------------------------*/
   /* For files in read mode, we must subtract the unread data in the buffer */
   /* from the location of the file pointer.  For files in write mode, we    */
   /* must add the data in the buffer that has not yet gone to disk.         */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODER) && _fp->buff_stop > _fp->pos)
      adjust = -(_fp->buff_stop - _fp->pos);
   if(_STCHK(_fp, _MODEW)) adjust = (_fp->pos - _fp->buf); 
 
   /*------------------------------------------------------------------------*/
   /* Get the file pointer's position                                        */
   /*------------------------------------------------------------------------*/
   _pos = lseek(_fp->fd, 0L, SEEK_CUR);

   /*------------------------------------------------------------------------*/
   /* If the call to lseek was unsuccessful, return an -1                    */
   /*------------------------------------------------------------------------*/
   if(_pos < 0) { errno = 5; return (-1L);}

   /*------------------------------------------------------------------------*/
   /* Make the necessary adjustment, and return the value                    */
   /*------------------------------------------------------------------------*/
   _pos += adjust;
   return (_pos);
}


fwrite.c/       868562438   0     0     0       6960      `
/*****************************************************************************/
/*  FWRITE.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FWRITE   -  Write a block of bytes to a stream                         */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <stdlib.h>
#include <string.h>
 
extern int _doflush(FILE *_fp);
extern int _wrt_ok(FILE *_fp);





 
/*****************************************************************************/
/* FWRITE   -  Write a block of bytes to a stream                            */
/*                                                                           */
/*    This function reads _COUNT blocks of size _SIZE from a buffer          */
/*    pointed to by _PTR, and writes them to stream _FP.  It returns the     */
/*    number of blocks successfully written.                                 */
/*                                                                           */
/*****************************************************************************/
size_t fwrite(const void *_ptr, size_t _size, size_t _count,
              register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned char    *fpos       = (unsigned char *)_ptr;
   unsigned char    *nl_pos;
            size_t   buffer_size = (_fp->bufend - _fp->buf),
                     next_nl,
                     room_left;
            size_t   num_left    = _size * _count,
                     num_to_write,
                     num_written  = 0;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp) || _size == 0 || _count == 0) return (0);
 
   room_left   = (_fp->bufend - _fp->pos);
   next_nl     = (char *)memchr(fpos, '\n', num_left) - (char *)fpos + 1;
 
   while (num_left > 0)
   {
      /*---------------------------------------------------------------------*/
      /* Determine how many characters should be written based on buffering  */
      /* mode.  For non-buffered streams, call the lowlever WRITE function.  */
      /* For fully buffered streams, put as many characters in the buffer as */
      /* possible.  For line buffered streams, put characters into the       */
      /* util the buffer is full, the last character is reached, or a        */
      /* newline character is reached.                                       */
      /*---------------------------------------------------------------------*/
      switch (_BUFFMODE(_fp))
      {
         case _IONBF : num_written = (write(_fp->fd, (char *)fpos, num_left));
                       if(num_written != num_left)
                       {
                          _SET(_fp, _STATERR);
                          if ((int)num_written == -1) num_written = 0;
                       }
                       return (num_written / _size);
 
         case _IOFBF : num_to_write = (room_left > num_left) ? 
                       num_left : room_left;
                       break;
 
         case _IOLBF : num_to_write = (room_left > next_nl) ? next_nl :
                       (room_left > num_left) ? num_left : room_left;
                       break;
 
         default     : return (0);
      }
 
      /*---------------------------------------------------------------------*/
      /* Write the data to the buffer, and update the buffer pointer and the */
      /* ROOM_LEFT coutner.                                                  */
      /*---------------------------------------------------------------------*/
      memcpy(_fp->pos, fpos, num_to_write);
      _fp->pos += num_to_write;
      room_left = (_fp->bufend - _fp->pos);

      /*---------------------------------------------------------------------*/
      /* If the buffer is full, or a newline character has been encountered  */
      /* on a line-buffered stream, flush it.                                */
      /*---------------------------------------------------------------------*/
      if (room_left == 0 || (_STCHK(_fp, _IOLBF) && num_to_write == next_nl))
      {
         if(_doflush(_fp))
         {
            _SET(_fp, _STATERR); 
            return (num_written / _size);
         }
         room_left = buffer_size;

         /*------------------------------------------------------------------*/
         /* The _DOFLUSH function clears the write flag on streams opened in */
         /* update mode.  Make sure that the write flag is still set here.   */
         /*------------------------------------------------------------------*/
         _SET(_fp, _MODEW);
      }

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      num_written += num_to_write;
      fpos += num_to_write;
      num_left -= num_to_write;
 
      /*---------------------------------------------------------------------*/
      /* For line-buffered streams, find the next occurance of a newline     */
      /* character.  If there are no more, and the remaining data will fit   */
      /* in the buffer, exit the loop where the remaining data will be moved */
      /* there.  Otherwise loop until this condition is true.                */
      /*---------------------------------------------------------------------*/
      if (_STCHK(_fp, _IOLBF))
      {
         nl_pos = (unsigned char *)memchr((fpos + 1), '\n', 
					  (num_left > 0) ? (num_left-1) : 0);
         if (! nl_pos)
         {
            if (num_left < room_left) break;
            else next_nl = buffer_size + 1;
         }
         else next_nl = (nl_pos - fpos) + 1;
      }
   }

   /*------------------------------------------------------------------------*/
   /* Copy the rest of the characters into the buffer for line-buffered      */
   /* streams.                                                               */
   /*------------------------------------------------------------------------*/
   if (_STCHK(_fp, _IOLBF))
   {
      memcpy(_fp->pos, fpos, num_left);
      num_written += num_left;
      _fp->pos += num_left;
   }
 
   return (num_written / _size);
}
 
gmtime.c/       868562438   0     0     0       573       `
/****************************************************************************/
/*  gmtime v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>

struct tm *gmtime(const time_t *timer)
{
    time_t gtime = _tz.timezone; /* DIFFERENCE BETWEEN CURRENT TIME ZONE    */
				 /* AND GMT IN SECONDS                      */

    if (timer) gtime += *timer;
    return (localtime(&gtime));
}

imath40.c/      868562440   0     0     0       4321      `
#include <stdio.h>
#include <c6x.h>

unsigned long _divul (unsigned long x1, unsigned long x2);
long          _divli (long a, long b);

/***********************************************************************/
/*                                                                     */
/* _lmbdul() - Same as _lmbd(int, int) but takes (int, ulong).         */
/*                                                                     */
/***********************************************************************/
static inline unsigned _lmbdul(int val, unsigned long src)
{
    unsigned p1 = src >> 32; 
    unsigned p2 = src;
    unsigned pos;

    if (!val) p1 |= 0xffffff00;
    
    if ((pos = _lmbd(val, p1)) == 32)
      return _lmbd(val, p2) + 32;
    else return pos;
}

/***********************************************************************/
/*                                                                     */
/* _subcul() - Same as _subc(int, int), but takes (ulong, ulong).      */
/*                                                                     */
/***********************************************************************/
static inline unsigned long _subcul(unsigned long src1, unsigned long src2)
{
    unsigned long res1 = ((src1-src2) << 1) | 0x1;
    unsigned long res2 = src1 << 1;
    if (src1 >= src2)
      return res1;
    else
      return res2;
}

/***********************************************************************/
/*                                                                     */
/* _remul() - Unsigned 40-bit remainder.                               */
/*                                                                     */
/***********************************************************************/
unsigned long _remul (unsigned long a, unsigned long b)
{
    return a - _divul(a,b) * b;
}

/***********************************************************************/
/*                                                                     */
/* _divul() - Unsigned 40-bit division.                              */
/*                                                                     */
/***********************************************************************/
unsigned long _divul (unsigned long x1, unsigned long x2)
{
    register int i;
    register unsigned long num;
    register unsigned long den;
    register int shift;
    unsigned long first_div = 0;
    unsigned long num40;

    shift = _lmbdul(1, x2) - _lmbdul(1, x1);

    if (x1 < x2) return 0;
    if (x1 == 0) return 0;
    if (x2 == 0) return -1;      

    num = x1;
    den = x2 << shift;

    num40 = (_lmbdul(1, x1) == 24);

    first_div = num40 << shift;

    if (den > num) first_div >>= 1; 

    if (num40)
    {
	if(den > num) { den >>= 1; num -= den; }
	else          { num -= den; den >>= 1; }
    }
    else
	shift++;

    for (i = 0; i < shift; i++)
      num = _subcul(num, den);

    return num << (40-shift) >> (40-shift) | first_div;
}

/***********************************************************************/
/*                                                                     */
/* _remli() - Signed 40-bit remainder.                                 */
/*                                                                     */
/***********************************************************************/
long _remli (long a, long b)
{
    return a - _divli(a,b) * b;
}

/***********************************************************************/
/*                                                                     */
/* _divli() - Signed 40-bit division.                                  */
/*                                                                     */
/***********************************************************************/
long _divli(long a, long b)
{
   /*-----------------------------------------------------------------------*/
   /* CHECK SIGNS, TAKE ABSOLUTE VALUE, AND USED UNSIGNED DIVIDE.           */
   /*-----------------------------------------------------------------------*/
   long sign    = (a ^ b) >> 39;
   unsigned long ua = (a < 0) ? -a : a;
   unsigned long ub = (b < 0) ? -b : b;
   unsigned long q  = _divul(ua, ub);

   if (b == 0) return a ? (((unsigned long)-1) >> 1) ^ sign : 0;
			/* saturation value or 0 */

   return sign ? -q : q;
}

isalnum.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  isalnum v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isalnum(int c)
{
    return(_isalnum(c));
}


isalpha.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  isalpha v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isalpha(int c)
{
    return(_isalpha(c));
}


isascii.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  isascii v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isascii(int c)
{
    return(_isascii(c));
}


iscntrl.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  iscntrl v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int iscntrl(int c)
{
    return(_iscntrl(c));
}


isdigit.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  isdigit v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isdigit(int c)
{
    return(_isdigit(c));
}


isgraph.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  isgraph v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isgraph(int c)
{
    return(_isgraph(c));
}


islower.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  islower v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int islower(int c)
{
    return(_islower(c));
}


isprint.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  isprint v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isprint(int c)
{
    return(_isprint(c));
}


ispunct.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  ispunct v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int ispunct(int c)
{
    return(_ispunct(c));
}


ldexp.c/        868562440   0     0     0       2695      `
/****************************************************************************/
/*  ldexp  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:53 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL LDEXPF(REAL x, int n)
/*---------------------------------------------------------------------------*/
/* return x * (REAL_RADIX ** n)                                              */
/*---------------------------------------------------------------------------*/
{

   { 
   /* Deals properly with NAN, +/- INFINITY, +/- ZERO, denormalized numbers */

      REAL y;
      int *ptr;
      int uy, e;

      CPYF(y,x);
      ptr = (int *)(&y) + (((64 / 32 )-1)*(_LITTLE_ENDIAN )) ;
      uy = *ptr;
      e = ((uy >> (32 - (11 +1) )) & ((1<< 11 )-1) );

      if (e == 0) /* ZERO's and denormalized numbers */
      {
         if EQZF(x) return x; /* preserve signed ZERO's */

         MPYF3(y, x, CNST(9007199254740992.0) );  /* its not denormalized now! */
         uy = *ptr;
         e = ((uy >> (32 - (11 +1) )) & ((1<< 11 )-1) ) - 53 ;
      }
      else if (e == ((1<< 11 )-1) ) return x; /* watch for infinity and NAN! */

      e += (n- (1023 -1) );

      if (e > 1024 )
      {
         errno = ERANGE; 
         CPYF(y,(GEZF(x) ? CNST( 1.7976931348623157e+308)  : CNST(-1.7976931348623157e+308) ));
         MPYF2(y,TWO); /* to force +/- INFINITY, if supported */
         return y;
      }
      else if (e < (-1021) ) { /* underflow or denormalized? */
         if (e < (-1021) -(53 -1)) /* underflow? */
            return (GEZF(x) ? 
                    ZERO : /* underflow from the positive direction: +ZERO */
                    /* generate -ZERO (if supported by compiler/hardware) */
                    MPYF(NEGF(CNST(4.450147717014402766e-308) ), CNST(4.450147717014402766e-308) ));

         /* resulting number will be denormalized */
         *ptr= (uy & (((1<<(32 -1))+(1<<(52 % 32 ))-1)  >> (32- 32 ))) |       /* out with the old...*/
              ((e+ (1023 -1) + 53 )<<(32 - (11 +1) ));/* in with (some) new.*/
         return MPYF(y, CNST(1.110223024625156540e-16) );          /* then rest of new   */
         /* MPYF will underflow if target does not support denormalized nos. */
      }

      *ptr = (uy & (((1<<(32 -1))+(1<<(52 % 32 ))-1)  >> (32- 32 ))) | /* out with the old ...*/
             ((e+ (1023 -1) ) << (32 - (11 +1) ));     /* and in with the new */
      return y;
   }

} /* LDEXPF */

isspace.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  isspace v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isspace(int c)
{
    return(_isspace(c));
}


isupper.c/      868562440   0     0     0       401       `
/****************************************************************************/
/*  isupper v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isupper(int c)
{
    return(_isupper(c));
}


isxdigit.c/     868562440   0     0     0       403       `
/****************************************************************************/
/*  isxdigit v1.10#                                                         */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isxdigit(int c)
{
    return(_isxdigit(c));
}


ldexpf.c/       868562440   0     0     0       2634      `
/****************************************************************************/
/*  ldexpf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:22 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL LDEXPF(REAL x, int n)
/*---------------------------------------------------------------------------*/
/* return x * (REAL_RADIX ** n)                                              */
/*---------------------------------------------------------------------------*/
{

   { 
   /* Deals properly with NAN, +/- INFINITY, +/- ZERO, denormalized numbers */

      REAL y;
      int *ptr;
      int uy, e;

      CPYF(y,x);
      ptr = (int *)(&y) + (((32 / 32 )-1)*(_LITTLE_ENDIAN )) ;
      uy = *ptr;
      e = ((uy >> (32 - (8 +1) )) & ((1<< 8 )-1) );

      if (e == 0) /* ZERO's and denormalized numbers */
      {
         if EQZF(x) return x; /* preserve signed ZERO's */

         MPYF3(y, x, CNST(16777216.0) );  /* its not denormalized now! */
         uy = *ptr;
         e = ((uy >> (32 - (8 +1) )) & ((1<< 8 )-1) ) - 24 ;
      }
      else if (e == ((1<< 8 )-1) ) return x; /* watch for infinity and NAN! */

      e += (n- (127 -1) );

      if (e > 128 )
      {
         errno = ERANGE; 
         CPYF(y,(GEZF(x) ? CNST( 3.402823466E+38)  : CNST(-3.402823466E+38) ));
         MPYF2(y,TWO); /* to force +/- INFINITY, if supported */
         return y;
      }
      else if (e < (-125) ) { /* underflow or denormalized? */
         if (e < (-125) -(24 -1)) /* underflow? */
            return (GEZF(x) ? 
                    ZERO : /* underflow from the positive direction: +ZERO */
                    /* generate -ZERO (if supported by compiler/hardware) */
                    MPYF(NEGF(CNST(2.35098870164E-38) ), CNST(2.35098870164E-38) ));

         /* resulting number will be denormalized */
         *ptr= (uy & (((1<<(32 -1))+(1<<(23 % 32 ))-1)  >> (32- 32 ))) |       /* out with the old...*/
              ((e+ (127 -1) + 24 )<<(32 - (8 +1) ));/* in with (some) new.*/
         return MPYF(y, CNST(5.9604644753E-8) );          /* then rest of new   */
         /* MPYF will underflow if target does not support denormalized nos. */
      }

      *ptr = (uy & (((1<<(32 -1))+(1<<(23 % 32 ))-1)  >> (32- 32 ))) | /* out with the old ...*/
             ((e+ (127 -1) ) << (32 - (8 +1) ));     /* and in with the new */
      return y;
   }

} /* LDEXPF */
localtim.c/     868562440   0     0     0       1109      `
/****************************************************************************/
/*  localtime v1.10#                                                        */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>

struct tm *localtime(const time_t *timer)
{
   static struct tm local;
   time_t ltime  = timer ? *timer : 0;

   local.tm_sec  = 0;
   local.tm_min  = 0;
   local.tm_hour = 0;
   local.tm_mday = 1;
   local.tm_mon  = 0;
   local.tm_year = 0;

   if (timer == 0 || ltime == (time_t)-1) return &local;

   /********************************************************************/
   /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */
   /* REPRESENTED IN A SIGNED INT.                                     */
   /********************************************************************/
   if ((int)ltime < 0)
   {
       local.tm_sec  = ltime % 60; 
       local.tm_min  = ltime / 60; 
   }
   else local.tm_sec = ltime;

   mktime(&local);
   return &local;
}


log.c/          868562440   0     0     0       1749      `
/****************************************************************************/
/*  log  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:54 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL LOGF(REAL x)
{
    if LEZF(x)
    { 
       errno = (EQZF(x) ? ERANGE : EDOM); 
       return CNST(-1.7976931348623157e+308) ;
    }

    /* Adapted from "Software Manual for the Elementary Functions" */
    /* Cody and Waite, Prentice Hall 1980. pages 35-45             */
{
    REAL    result, f, z, xn, y, zden, znum, w;
    EXPONENT_TYPE n;
    int           i;

    static REAL A[3] = 
       {KNST(-0.78956112887491257267e+0),
        KNST( 0.16383943563021534222e+2),
        KNST(-0.64124943423745581147e+2)};

    static REAL B[3] = 
       {KNST(-0.35667977739034646171e+2),
        KNST( 0.31203222091924532844e+3),
        KNST(-0.76949932108494879777e+3)};

    RIPF(x, f, n);

    SUBF3(znum, f, HALF);
    if GTRF(f, CNST(0.70710678118654752440) ) 
    {
       SUBF2(znum,HALF);
       MPYF3(zden, f, HALF);
    }
    else 
    {
       n -= 1;
       MPYF3(zden, znum, HALF);
    }

    DIVF3(z, znum, ADDF(zden, HALF));

    SQRF2(w, z);

    POLYF(znum, w, A, 3 );
    POLYbF(zden, w, B, 3 );

    DIVF3(result, znum, zden); 
    ADDF3(result, z, MPYF(z, result));

    if (n == 0) return result;

    FLTIF2(xn, n);

    return ADDF(ADDF(MPYF(xn,CNST(-2.121944400546905827679E-4) ),
                     result),
                MPYF(xn,CNST(0.693359375) ));
}

} /*LOGF*/

log10.c/        868562440   0     0     0       531       `
/****************************************************************************/
/*  log10  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:54 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL LOG10F(REAL x)
{
    return MPYF(LOGF(x), One_Over_Ln_10);
} /*LOG10F*/


log10f.c/       868562440   0     0     0       532       `
/****************************************************************************/
/*  log10f  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:22 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL LOG10F(REAL x)
{
    return MPYF(LOGF(x), One_Over_Ln_10);
} /*LOG10F*/

log2.c/         868562440   0     0     0       526       `
/****************************************************************************/
/*  log2  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:55 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL LOG2F(REAL x)
{
    return MPYF(LOGF(x), One_Over_Ln_2);
} /*LOG2F*/
log2f.c/        868562440   0     0     0       527       `
/****************************************************************************/
/*  log2f  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:23 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL LOG2F(REAL x)
{
    return MPYF(LOGF(x), One_Over_Ln_2);
} /*LOG2F*/

logf.c/         868562440   0     0     0       1385      `
/****************************************************************************/
/*  logf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:24 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL LOGF(REAL x)
{
    if LEZF(x)
    { 
       errno = (EQZF(x) ? ERANGE : EDOM); 
       return CNST(-3.402823466E+38) ;
    }

{

    REAL    result, f;
    EXPONENT_TYPE n;
    int           i;

    static REAL log_consts[8] = /* max of 24 mantissa bits */
      {KNST( 8.7416954E-02), 
       KNST(-1.4376735E-01), 
       KNST( 1.4949567E-01), 
       KNST(-1.6560792E-01), 
       KNST( 1.9956945E-01), 
       KNST(-2.5002149E-01), 
       KNST( 3.3334184E-01), 
       KNST(-4.9999987E-01)};

    RIPF(x, f, n);

    if LEQF(f, One_Over_Sqrt_2) 
    {
       ADDF2(f, f);
       n -= 1;
    }

    SUBF3(f,SUBF(f,HALF),HALF); /* do it this way to avoid losing bits */

    /* abs(F) < .414213562... at this point */

    POLYF(result,f,log_consts,8 );

    ADDF3(result, f, MPYF(f, result)); /* result = f+f*result; */

    /* return result + (REAL)n * Ln_2; */
    return ADDF(result, MPYF(FLTIF(n), Ln_2));
}

} /*LOGF*/

lowlev.c/       868562440   0     0     0       13204     `
/*****************************************************************************/
/*  LOWLEV.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Low level I/O routines                                                    */
/*                                                                           */
/* Functions:                                                                */
/*   getnexfildes()    - Allocate next entry in stream table.                */
/*   tabinit()         - Initialize the stream and device tables.            */
/*   finddevice()      - Search the device table for a device name.          */
/*   getdevice()       - Extract the device name and <find> it.              */
/*   add_device()      - Add a device record to the device table.            */
/*   removedevice()    - Remove the specified device record from the device  */
/*                              table.                                       */
/*   open()            - Open file/device and assign file descriptor.        */
/*   read()            - Read data from an open file/device.                 */
/*   write()           - Write to an open file/device.                       */
/*   lseek()           - Perform lseek on open file/device.                  */
/*   close()           - Close an open file/device.                          */
/*   unlink()          - Perform unlink on file/device.                      */
/*   rename()          - Rename file                                         */
/*****************************************************************************/
#include <stdio.h>
#include <string.h>

extern int  HOSTopen(const char *path, unsigned flags, int fno),
            HOSTclose(int fno),
            HOSTread(int fno, char *buf, unsigned count),
            HOSTwrite(int fno, const char *buf, unsigned count),
            HOSTunlink(const char *path),
            HOSTrename(const char *old_name, const char *new_name);
extern fpos_t HOSTlseek(int fno, fpos_t offset, int origin);

_DEVICE  _device[_NDEVICE] = { { "", _MSA, HOSTopen,  HOSTclose, HOSTread,
                                   HOSTwrite, HOSTlseek, HOSTunlink,
                                   HOSTrename} };

_DEVICE *_stream[_NSTREAM] =  { &_device[0],  &_device[0],   &_device[0] };

/*****************************************************************************/
/*  GETNEXFILDES() - allocate a location in the stream table                 */
/*****************************************************************************/

int getnexfildes(void)
{
   _DEVICE **ptr;

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE STREAM TABLE FOR EMPTY ENTRY - RETURN -1 IF FULL             */
   /*-------------------------------------------------------------------------*/
   for (ptr = &_stream[3] ; ptr != &_stream[_NSTREAM] && *ptr != NULL; ++ptr );

   return ( ptr == &_stream[_NSTREAM] ) ? -1 : ptr - &_stream[0];
}


/*****************************************************************************/
/*  TABINIT() - initialize the stream table and the device table             */
/*****************************************************************************/

void tabinit(void)
{
   _DEVICE **st;
   _DEVICE  *dt;

   static int init = 0;

   if (init) return;

   /*-------------------------------------------------------------------------*/
   /* STEP THROUGH THE TABLES SETTING NAME AND POINTER ENTRIES TO NULL        */
   /* (SKIP PREDEFINED DEVICE AND STREAMS)                                    */
   /*-------------------------------------------------------------------------*/

   for ( st = &_stream[3] ; st != &_stream[_NSTREAM] ; *st++ = NULL );
   for ( dt = &_device[1] ; dt != &_device[_NDEVICE] ; *(dt++)->name = '\0');
   init = 1;
}

/*****************************************************************************/
/*  FINDDEVICE() - find the device record that matches devname in the device */
/*                     table                                                 */
/*****************************************************************************/

_DEVICE *finddevice(const char *devname)
{
   _DEVICE    *dt;

   if (devname[0] == '\0') return NULL;

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE STREAM TABLE FOR THE DEVICE NAME - RETURN NULL IF NOT FOUND  */
   /*-------------------------------------------------------------------------*/
   for (dt = &_device[1]; 
   dt != _device+_NDEVICE && strcmp(dt->name,devname);
   ++dt);

   return (dt == &_device[_NDEVICE]) ? NULL : dt;
}


/*****************************************************************************/
/*  GETDEVICE() - extract the device name and call finddevice                */
/*****************************************************************************/

_DEVICE *getdevice (const char **path)   /* RETURN PTR TO DEVICE RECORD */
                                         /*   ASSOCIATED WITH PATH      */
{
   char    devname[9];
   char   *devnamptr   = devname;
   _DEVICE *dev;

  /*------------------------------------------------------------------------*/
  /* COPY OUT OF THE FIRST 8 CHARS WHAT SHOULD BE A DEVICE NAME             */
  /*------------------------------------------------------------------------*/
  if (devnamptr = strchr(*path,':'))
  {
     *devnamptr = '\0';
     dev = finddevice(*path);
     *devnamptr = ':';
     if (dev) { *path = devnamptr + 1; return dev; }
  }
   return stdevice;
}


/*****************************************************************************/
/*  ADDEVICE() - add a device record to the device table                     */
/*****************************************************************************/
int add_device(char      *name,
               unsigned   flags,
               int      (*dopen)  (const char *path, unsigned flags, int foo),
               int      (*dclose) (int fno),
               int      (*dread)  (int fno, char *buf, unsigned count),
               int      (*dwrite) (int fno, const char *buf, unsigned count),
               fpos_t     (*dlseek) (int fno, fpos_t offset, int origin),
               int      (*dunlink)(const char *path),
               int      (*drename)(const char *old_name, const char *new_name))
{
   _DEVICE *dt;

   tabinit();

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE DEVICE TABLE FOR AN EMPTY SLOT, RETURN -1 IF NONE FOUND      */
   /*-------------------------------------------------------------------------*/
   for (dt = &_device[1]; dt != _device+_NDEVICE && dt->name[0] != '\0'; ++dt);
   if (dt == &_device[_NDEVICE]) return -1;

   strncpy(dt->name,name,8);
   dt->name[8] = '\0';
   dt->flags   = flags;
   dt->OPEN    = dopen;
   dt->CLOSE   = dclose;
   dt->READ    = dread;
   dt->WRITE   = dwrite;
   dt->LSEEK   = dlseek;
   dt->UNLINK  = dunlink;
   dt->RENAME  = drename;

   return 0;
}

/******************************************************************************/
/*  REMOVEDEVICE() - remove the specified device record from the device table */
/******************************************************************************/

int remove_device(char *name)
{
   _DEVICE *ptr;

  /*------------------------------------------------------------------------*/
  /* FIND RECORD AND SET NAME TO NULL                                       */
  /*------------------------------------------------------------------------*/
   if ( !(ptr = finddevice(name)) ) return -1;

   ptr->name[0] = '\0';
   return 0;
}


/*****************************************************************************/
/*  OPEN() - open file/device specified by path and assign file descriptor   */
/*****************************************************************************/

int open(const char *path,
         unsigned flags, 
         int      mode)
{
   _DEVICE    *dev;
   int        result;
   int        nexfildes;

   /*-------------------------------------------------------------------------*/
   /* INITIALIZE STREAM AND DEVICE TABLE FIRST TIME AROUND                    */
   /*-------------------------------------------------------------------------*/
   tabinit();

   /*-------------------------------------------------------------------------*/
   /* GET THE NEXT AVAILABLE FILE DESCRIPTOR - RETURN -1 IF NONE AVAILABLE    */
   /*-------------------------------------------------------------------------*/
   if ( (nexfildes = getnexfildes()) == -1 )
      return -1;

   /*------------------------------------------------------------------------*/
   /* GET DEVICE AND PEFORM OPEN - SET STREAM TABLE ENTRY AND FLAGS          */
   /*------------------------------------------------------------------------*/
   dev    = getdevice(&path);
   result = (dev->flags & _BUSY) ? -1 : (*(dev->OPEN))(path,flags,nexfildes);

   if ( result != -1 )
   {
      _stream[nexfildes] = dev;
      if ( !(dev->flags & _MSA) ) dev->flags |= _BUSY;
      result         = nexfildes;
   }
   return result;
}

/*****************************************************************************/
/*  READ() - read data from an open device/file                              */
/*****************************************************************************/

int read(int           fildes,
         char         *bufptr,
         unsigned      cnt)
{
   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM READ FOR THIS DEVICE/FILE   */
   /*------------------------------------------------------------------------*/
   return (*(_stream[fildes]->READ)) (fildes,bufptr,cnt);
}

/*****************************************************************************/
/*  WRITE() - write data to an open device/file                              */
/*****************************************************************************/

int write(int           fildes,
          const char   *bufptr,
          unsigned      cnt)
{
   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM WRITE FOR THIS DEVICE/FILE  */
   /*------------------------------------------------------------------------*/
   return (*(_stream[fildes]->WRITE)) (fildes,bufptr,cnt);
}

/*****************************************************************************/
/*  LSEEK() - lseek on an open device/file                                   */
/*****************************************************************************/

long lseek(int  fildes,
	   long offset,
	   int  origin)
{
   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM LSEEK FOR THIS DEVICE/FILE  */
   /*------------------------------------------------------------------------*/
   return (*(_stream[fildes]->LSEEK)) (fildes,(fpos_t)offset,origin);
}

/*****************************************************************************/
/*  CLOSE() - close an open device/file                                      */
/*****************************************************************************/

int close(int fildes)
{
   int result;

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM CLOSE FOR THIS DEVICE/FILE  */
   /* CLEAR STREAM TABLE ENTRY AND DEVICE FLAGS                              */
   /*------------------------------------------------------------------------*/
   if ( (result = (*(_stream[fildes]->CLOSE))(fildes)) != -1 )
   {
      _stream[fildes]->flags &= ~_BUSY;
      _stream[fildes] = NULL;
   }
   return result;
}

/*****************************************************************************/
/*  UNLINK() - unlink an open device/file                                    */
/*****************************************************************************/

int unlink(const char *path)
{
   _DEVICE *dev = getdevice(&path);

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM UNLINK FOR THIS DEVICE/FILE */
   /*------------------------------------------------------------------------*/
   return (*(dev->UNLINK)) (path);
}

/*****************************************************************************/
/*  RENAME() - rename a device/file                                          */
/*****************************************************************************/

int rename(const char *old_name, const char *new_name)
{
   _DEVICE *dev = getdevice(&old_name);

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM RENAME FOR THIS DEVICE/FILE */
   /*------------------------------------------------------------------------*/
   return (*(dev->RENAME)) (old_name, new_name);
}
ltoa.c/         868562440   0     0     0       736       `
/****************************************************************************/
/*  ltoa v1.10#								    */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>
#define BUFLEN 20

int ltoa(long val, char *buffer)
{
    char           tempc[BUFLEN];
    register char *bufptr;
    register int   neg = val < 0;
    register long  uval = neg ? -val : val;

    *(bufptr = &tempc[BUFLEN - 1]) = 0;

    do {*--bufptr = (uval % 10) + '0';}  while(uval /= 10);
    if (neg) *--bufptr = '-';

    memcpy(buffer,bufptr, uval = (tempc + BUFLEN) - bufptr);
    return uval - 1;    /* DON'T COUNT NULL TERMINATION */
}

memccpy.c/      868562440   0     0     0       854       `
/*****************************************************************************/
/*  MEMCCPY.C  v1.10#                                                        */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include "stdlib.h"

/*--------------------------------------------------------------------------*/
/* PERFORM SAME OPERATION AS MEMCPY, ABORT IF "ch" is COPIED.               */
/* RETURN POINTER TO BYTE AFTER ch IS FOUND, OR NULL IF NOT FOUND           */
/*--------------------------------------------------------------------------*/
char *memccpy(char *dest, const char *src, int ch, int count)
{
   if (count <= 0) return NULL;
   do
      if ((*dest++ = *src++) == ch) return (dest);
   while (--count != 0);

   return NULL;
}
memchr.c/       868562440   0     0     0       604       `
/****************************************************************************/
/*  memchr v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

void *memchr(const void *cs, int c, size_t n)
{
   if (n)
   {
      const unsigned char *mem = (unsigned char *)cs - 1;   
      unsigned char        ch  = c;

      do if ( *++mem == ch ) return (void *)mem;
      while (--n);
   }
   return NULL;
}
memcmp.c/       868562440   0     0     0       622       `
/****************************************************************************/
/*  memcmp v1.10#							    */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

int memcmp(const void *cs, const void *ct, size_t n)
{
   if (n) 
   {
       const unsigned char *mem1 = (unsigned char *)cs - 1;
       const unsigned char *mem2 = (unsigned char *)ct - 1;
       int                 cp;

       while ((cp = *++mem1) == *++mem2 && --n);
       return cp - *mem2;
   }
   return 0;
}
memcpy.c/       868562440   0     0     0       879       `
/****************************************************************************/
/*  memcpy v1.10# 							    */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

void *memcpy(void *s1, const void *s2, register size_t n)
{
    register int mask = (int)s1 | (int)s2 | n;

    if (n == 0) return s1;

    if (mask & 0x1)
    {
	register const char *src = s2;
	register       char *dst = s1;

        do *dst++ = *src++; while (--n);
	return s1;
    }

    if (mask & 0x2)
    {
	register const short *src = s2;
	register       short *dst = s1;

        do *dst++ = *src++; while (n-=2);
	return s1;
    }

    {
	register const int *src = s2;
	register       int *dst = s1;

        do *dst++ = *src++; while (n-=4);
	return s1;
    }

}


memmov.c/       868562440   0     0     0       740       `
/****************************************************************************/
/*  memmov v1.10#							    */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

void *memmove(void *s1, const void *s2, size_t n)
{
    register void *result = s1;

    if (n == 0) return result;

    if (s2 > s1) 
    {
       register const char *src = s2;
       register char *dst = s1;

       do  *dst++ = *src++; while (--n);
    }

    else 
    {
       register char *src = (char *)s2 + n;
       register char *dst = (char *)s1 + n;

       do  *--dst = *--src; while (--n);
    } 

    return result;
}

memory.c/       868562440   0     0     0       22452     `
/*****************************************************************************/
/*  memory.c v1.10#							     */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                  */
/*****************************************************************************/
/*									     */
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines. The following assumptions/rules apply:              */
/*									     */
/*   1) Packets are allocated a minimum of MIN_BLOCK + BLOCK_OVERHEAD bytes. */
/*   2) The size of the heap is set at link time, using the -heap flag       */
/*      The allocation and sizing of the heap is a cooperative effort        */
/*      involving the linker, this file, and "sysmem.c".                     */
/*   3) The heap can be reset at any time by calling the function "minit"    */
/*									     */
/*  The following items are defined in this module :			     */
/*    minit()	 : Function to initialize dynamic memory management	     */
/*    malloc()	 : Function to allocate memory from mem mgmt system.	     */
/*    calloc()	 : Allocate an clear memory from mem mgmt system.	     */
/*    realloc()  : Reallocate a packet					     */
/*    free()	 : Function to free allocated memory.			     */
/*    memalign() : Function to allocate aligned memory from mem mgmt system. */
/*---------------------------------------------------------------------------*/
/*    minsert()  : Insert a packet into free list, sorted by size	     */
/*    mremove()  : Remove a packet from the free list.			     */
/*    sys_free	 : Pointer to free list 				     */
/*									     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>

/*---------------------------------------------------------------------------*/
/* MIN_BLOCK MUST BE A MULTIPLE OF THE SIZEOF (LARGE_TYPE)                   */
/*---------------------------------------------------------------------------*/
#define LARGE_TYPE      long double
#define MIN_BLOCK       sizeof(LARGE_TYPE)
#define BLOCK_OVERHEAD  MIN_BLOCK
#define BLOCK_USED      1
#define BLOCK_MASK      (MIN_BLOCK-1)

/*---------------------------------------------------------------------------*/
/* "PACKET" is the template for a data packet.  Packet size contains         */
/* the number of bytes allocated for the user, excluding the size required   */
/* for management of the packet (BLOCK_OVERHEAD bytes).  Packets are always  */
/* allocated memory in MIN_BLOCK byte chunks. The lowest order bit of the    */
/* size field is used to indicate whether the packet is free(0) or used(1).  */
/* The size_ptr field is used to manage the free list, and is a pointer      */
/* to the next element in the free list.  The free list is sorted by size.   */
/*---------------------------------------------------------------------------*/
typedef struct pack 
{
    unsigned int packet_size;     /* number of bytes        */
    struct pack  *size_ptr;       /* next elem in free list */
} PACKET;

/*---------------------------------------------------------------------------*/
/* Size of the heap area as defined by the linker. Initialized in sysmem.c   */
/*---------------------------------------------------------------------------*/
int _memory_size;

/*---------------------------------------------------------------------------*/
/* SYS_FREE - This variable is a pointer to the free list.                   */
/*---------------------------------------------------------------------------*/
extern char _sys_memory[];
static PACKET *sys_free = (PACKET *)_sys_memory;

/*---------------------------------------------------------------------------*/
/* Function declarations                                                     */
/*---------------------------------------------------------------------------*/
static void minsert(PACKET *);         /* insert a packet into the free list */
static void mremove(PACKET *);         /* delete packet from the free list   */
void minit(void);         


/*****************************************************************************/
/*									     */
/*  MINSERT - Insert a packet into the free list.  This list is sorted by    */
/*	      size in increasing order. 				     */
/*									     */
/*****************************************************************************/
static void minsert(PACKET *ptr)
{
    register PACKET *current = (PACKET *) sys_free;
    register PACKET *last    = NULL;

    /*-----------------------------------------------------------------------*/
    /* CHECK SPECIAL CASE, EMPTY FREE LIST.				     */
    /*-----------------------------------------------------------------------*/
    if (current == NULL)
    {
        sys_free      = ptr;
        ptr->size_ptr = NULL;
        return;
    }

    /*-----------------------------------------------------------------------*/
    /* SCAN THROUGH LIST, LOOKING FOR A LARGER PACKET.			     */
    /*-----------------------------------------------------------------------*/
    while (current && current->packet_size < ptr->packet_size)
    {
	last	= current;
	current = current->size_ptr;
    }

    /*-----------------------------------------------------------------------*/
    /* LINK THE NEW PACKET INTO THE LIST. THERE ARE THREE CASES :	     */
    /*	 THE NEW POINTER WILL EITHER BE THE FIRST, THE LAST, OR IN THE	     */
    /*	 MIDDLE SOMEWHERE.						     */
    /*-----------------------------------------------------------------------*/
    if (current == NULL) 	        /* PTR WILL BE LAST IN LIST          */
    {
        last->size_ptr = ptr;
        ptr->size_ptr  = NULL;
    }
    else if (last == NULL)	        /* PTR WILL BE FIRST IN THE LIST     */
    {
        ptr->size_ptr  = sys_free;
        sys_free       = ptr;
    }
    else			        /* PTR IS IN THE MIDDLE OF THE LIST  */
    {
        ptr->size_ptr  = current;
        last->size_ptr = ptr;
    }
}


/*****************************************************************************/
/*									     */
/* MREMOVE - REMOVE AN ITEM FROM THE FREE LIST. 			     */
/*									     */
/*****************************************************************************/
static void mremove(PACKET *ptr)
{
    register PACKET *current = sys_free;
    register PACKET *last    = NULL;

    /*-----------------------------------------------------------------------*/
    /* SCAN THROUGH LIST, LOOKING FOR PACKET TO REMOVE                       */
    /*-----------------------------------------------------------------------*/
    while (current && current != ptr)
    {
	last	= current;
	current = current->size_ptr;
    }

    /*-----------------------------------------------------------------------*/
    /* REMOVE THE PACKET FROM THE LIST.   THERE ARE TWO CASES :              */
    /*   THE OLD POINTER WILL EITHER BE THE FIRST, OR NOT THE FIRST.         */
    /*-----------------------------------------------------------------------*/
    if      (current == NULL) sys_free       = NULL;          /* NOT FOUND   */
    else if (last    == NULL) sys_free       = ptr->size_ptr; /* 1ST IN LIST */
    else                      last->size_ptr = ptr->size_ptr; /* MID OF LIST */
}


/*****************************************************************************/
/*									     */
/*  MINIT - This function can be called by the user to completely reset the  */
/*	    memory management system.					     */
/*									     */
/*****************************************************************************/
void minit(void)
{
    /*-----------------------------------------------------------------------*/
    /* TO INITIALIZE THE MEMORY SYSTEM, SET UP THE FREE LIST TO POINT TO     */
    /* THE ENTIRE HEAP, AND INITIALIZE HEAP TO A SINGLE EMPTY PACKET.        */
    /*-----------------------------------------------------------------------*/
    sys_free = (PACKET *)_sys_memory;

    sys_free->packet_size = _memory_size - BLOCK_OVERHEAD;
    sys_free->size_ptr	  = NULL;
}


/*****************************************************************************/
/*									     */
/*  MALLOC - Allocate a packet of a given size, and return a pointer to it.  */
/*	     This function only allocates in multiples of MIN_BLOCK bytes.   */
/*									     */
/*****************************************************************************/
void *malloc(size_t size)
{
    register PACKET       *current = sys_free;
    register unsigned int  newsize = (size + BLOCK_MASK) & ~BLOCK_MASK;
    register unsigned int  oldsize;

    if (size <= 0) return 0;

    /*-----------------------------------------------------------------------*/
    /* SCAN THROUGH FREE LIST FOR PACKET LARGE ENOUGH TO CONTAIN PACKET      */
    /*-----------------------------------------------------------------------*/
    while (current && current->packet_size < newsize)
       current = current->size_ptr;

    if (!current) return 0;
    
    oldsize = current->packet_size;	    /* REMEMBER OLD SIZE	     */
    mremove(current);		            /* REMOVE PACKET FROM FREE LIST  */

    /*-----------------------------------------------------------------------*/
    /* IF PACKET IS LARGER THAN NEEDED, FREE EXTRA SPACE AT END	             */
    /* BY INSERTING REMAINING SPACE INTO FREE LIST.			     */
    /*-----------------------------------------------------------------------*/
    if (oldsize - newsize >= (MIN_BLOCK + BLOCK_OVERHEAD))
    {
       register PACKET *next = 
	       (PACKET *) ((char *) current + BLOCK_OVERHEAD + newsize);
 
       next->packet_size    = oldsize - newsize - BLOCK_OVERHEAD;
       minsert(next);
       current->packet_size = newsize;
    }

   current->packet_size |= BLOCK_USED;
   return (char *)current + BLOCK_OVERHEAD;
 }


/*****************************************************************************/
/*									     */
/*  CALLOC - Allocate a packet of a given size, set the data in the packet   */
/*	     to nulls, and return a pointer to it.			     */
/*									     */
/*****************************************************************************/
void *calloc(size_t num, size_t size)
{
    register size_t      i	 = size * num;
    register LARGE_TYPE *current = malloc(i);
    register char       *save    = (char *) current;

    if (current == 0) return 0;

    i = ((i + BLOCK_MASK) & ~BLOCK_MASK) / sizeof(LARGE_TYPE);

    while (i--) *current++ = 0;
    return save;
}



/*****************************************************************************/
/*									     */
/*  REALLOC - Reallocate a packet to a new size.			     */
/*									     */
/*****************************************************************************/
void *realloc(void *packet, size_t size)
{
    register char *pptr    = (char *) packet - BLOCK_OVERHEAD;
    register int   newsize = (size + BLOCK_MASK) & ~BLOCK_MASK;
    register int   oldsize;

    if (size   <  0)  return 0;
    if (packet == 0)  return malloc(size);
    if (size   == 0)  { free(packet); return 0; }

    oldsize = ((PACKET *)pptr)->packet_size;

    if (!(oldsize & BLOCK_USED))  return 0;
    if (newsize == --oldsize)     return packet;

    /*-----------------------------------------------------------------------*/
    /* IF NEW SIZE IS LESS THAN CURRENT SIZE, TRUNCATE PACKET AND RETURN END */
    /* TO FREE LIST		                                             */
    /*-----------------------------------------------------------------------*/
    if (newsize < oldsize)
    {
       if (oldsize - newsize < (MIN_BLOCK + BLOCK_OVERHEAD)) return packet;
       ((PACKET *)pptr)->packet_size = newsize | BLOCK_USED;

       oldsize -= newsize + BLOCK_OVERHEAD;
       pptr    += newsize + BLOCK_OVERHEAD;
       ((PACKET *)pptr)->packet_size = oldsize | BLOCK_USED;
       free(pptr + BLOCK_OVERHEAD);
       return packet;
    }

    /*-----------------------------------------------------------------------*/
    /* IF NEW SIZE IS BIGGER THAN CURRENT PACKET,		             */
    /*	1) CHECK NEXT PACKET IN LIST, SEE IF PACKET CAN BE EXPANDED          */
    /*	2) IF NOT, MOVE PACKET TO NEW LOCATION. 		             */
    /*-----------------------------------------------------------------------*/
    else
    {
	PACKET *next = (PACKET *)(pptr + oldsize + BLOCK_OVERHEAD);
	int     temp;

	if (((char *)next < &_sys_memory[_memory_size - BLOCK_OVERHEAD]) &&
           (!(next->packet_size & BLOCK_USED))                           &&
           ((temp = oldsize + next->packet_size +BLOCK_OVERHEAD -newsize) >= 0))
	{
	    mremove(next);
	    if (temp < MIN_BLOCK + BLOCK_OVERHEAD)
	    {
	       ((PACKET *)pptr)->packet_size = newsize + temp | BLOCK_USED;
	       return packet;
	    }

	    ((PACKET *)pptr)->packet_size = newsize | BLOCK_USED;
	    pptr += newsize + BLOCK_OVERHEAD;
	    ((PACKET *)pptr)->packet_size = temp - BLOCK_OVERHEAD;
	    minsert((PACKET *)pptr);
	    return packet;
	}
	else
	{
            /*---------------------------------------------------------------*/
	    /* ALLOCATE NEW PACKET AND MOVE DATA INTO IT. 	             */
            /*---------------------------------------------------------------*/
	    register char *new = malloc(size);
	    if (new == 0) return 0;
	    memcpy(new, packet, oldsize);
	    free(packet);
	    return new;
	}
    }
}


/*****************************************************************************/
/*									     */
/*  FREE - Return a packet allocated by malloc to free memory pool.	     */
/*	   Return 0 if successful, -1 if not successful.		     */
/*									     */
/*****************************************************************************/
void free(void *packet)
{
    register char   *ptr = (char *)packet;
    register PACKET *last;	      /* POINT TO PREVIOUS PACKET            */
    register PACKET *current;	      /* POINTER TO THIS PACKET              */
    register PACKET *next;	      /* POINTER TO NEXT PACKET              */

    if (ptr == NULL) return;

    last = next = NULL;		      /* INITIALIZE POINTERS                 */
    ptr -= BLOCK_OVERHEAD;	      /* ADJUST POINT TO BEGINNING OF PACKET */

    current = (PACKET *)_sys_memory;

    /*-----------------------------------------------------------------------*/
    /* SEARCH FOR THE POINTER IN THE PACKET POINTED TO			     */
    /*-----------------------------------------------------------------------*/
    while (current < (PACKET *) ptr)
    {
        last    = current;
        current = (PACKET *)((char *)current + 
		  (current->packet_size & ~BLOCK_USED) + BLOCK_OVERHEAD);
    }

    /*-----------------------------------------------------------------------*/
    /* CHECK FOR POINTER OR PACKET ERRORS.				     */
    /*-----------------------------------------------------------------------*/
    if ((current != (PACKET *) ptr) || (!(current->packet_size & BLOCK_USED)))
         return;

    current->packet_size &= ~BLOCK_USED;   /* MARK PACKET AS FREE */

    /*-----------------------------------------------------------------------*/
    /* GET POINTER TO NEXT PACKET IN MEMORY, IF ANY.			     */
    /*-----------------------------------------------------------------------*/
    next = (PACKET *) ((char *)current + BLOCK_OVERHEAD + current->packet_size);
    if (next > (PACKET *) &_sys_memory[_memory_size-BLOCK_OVERHEAD]) 
	next = NULL;

    if (last->packet_size & BLOCK_USED) last = NULL;
    if (next->packet_size & BLOCK_USED) next = NULL;

    /*-----------------------------------------------------------------------*/
    /* ATTEMPT TO COLLESCE THE THREE PACKETS (PREVIOUS, CURRENT, NEXT)	     */
    /*-----------------------------------------------------------------------*/
    if (last && next)
    {
	mremove(last);
	mremove(next);
	last->packet_size += current->packet_size + next->packet_size + 
			     BLOCK_OVERHEAD + BLOCK_OVERHEAD;
	minsert(last);
	return;
    }

    /*-----------------------------------------------------------------------*/
    /* ATTEMPT TO COLLESCE THE CURRENT WITH LAST PACKET. (LAST, CURRENT)     */
    /*-----------------------------------------------------------------------*/
    if (last)
    {
	mremove(last);
	last->packet_size += current->packet_size + BLOCK_OVERHEAD;
	minsert(last);
	return;
    }

    /*-----------------------------------------------------------------------*/
    /* ATTEMPT TO COLLESCE THE CURRENT WITH NEXT PACKET. (CURRENT, NEXT)     */
    /*-----------------------------------------------------------------------*/
    if (next)
    {
       mremove(next);
       current->packet_size += next->packet_size + BLOCK_OVERHEAD;
       minsert(current);
       return;
    }

    /*-----------------------------------------------------------------------*/
    /* NO COLLESCENCE POSSIBLE, JUST INSERT THIS PACKET INTO LIST	     */
    /*-----------------------------------------------------------------------*/
    minsert(current);
}

/*****************************************************************************/
/*                                                                           */
/*  MEMALIGN - Allocate a packet of a given size, and on a given boundary.   */
/*                                                                           */
/*****************************************************************************/
void *memalign(size_t alignment, size_t size)
{
    PACKET *aln_packet;
    PACKET *current  = sys_free;
    size_t  newsize  = (size + BLOCK_MASK) & ~BLOCK_MASK;
    size_t  aln_mask = alignment - 1;
    int     leftover = -1;
    char   *aln_start;
    char   *un_aln_start;
 
    if (size <= 0) return 0;
      
    /*--------------------------------------------------------------------*/
    /* IF ALIGNMENT IS NOT A POWER OF TWO OR IS LESS THAN THE DEFAULT     */
    /* ALIGNMENT OF MALLOC, THEN SIMPLY RETURN WHAT MALLOC RETURNS.       */
    /*--------------------------------------------------------------------*/
    if (alignment <= BLOCK_OVERHEAD || (alignment & (alignment-1)))
	  return malloc(size);

    /*-----------------------------------------------------------------------*/
    /* SCAN THROUGH FREE LIST FOR PACKET LARGE ENOUGH TO CONTAIN ALIGNED     */
    /* PACKET                                                                */
    /*-----------------------------------------------------------------------*/
    for ( ; current ; current = current->size_ptr)
    {
       un_aln_start = (char *) current + BLOCK_OVERHEAD;
       aln_start    = (char *) (((size_t) un_aln_start + aln_mask) & ~aln_mask);
       leftover     = un_aln_start + current->packet_size - aln_start - newsize;

       /*--------------------------------------------------------------------*/
       /* MAKE SURE THAT THE PRE BLOCK SPACE IS LARGE ENOUGH TO BE A BLOCK   */
       /* OF ITS OWN.                                                        */
       /*--------------------------------------------------------------------*/
       for ( ; (char *)current+sizeof(PACKET) > aln_start-BLOCK_OVERHEAD ;
	       aln_start += alignment, leftover -= alignment);

       if (leftover >= 0) break;
    }

    if (!current) return 0;

    /*-----------------------------------------------------------------------*/
    /* SETUP NEW PACKET FOR ALIGNED MEMORY.                                  */
    /*-----------------------------------------------------------------------*/
    mremove(current);
    aln_packet              = (PACKET *) (aln_start - BLOCK_OVERHEAD);
    aln_packet->packet_size = newsize | BLOCK_USED;

    /*-----------------------------------------------------------------------*/
    /* HANDLE THE FREE SPACE BEFORE THE ALIGNED BLOCK.  IF THE ORIGINAL      */
    /* BLOCK WAS ALIGNED, THERE WON'T BE FREE SPACE BEFORE THE ALIGNED BLOCK.*/
    /*-----------------------------------------------------------------------*/
    if (aln_start != un_aln_start) 
    {
	current->packet_size = (char *)aln_packet - un_aln_start;
	minsert(current);
    }

    /*-----------------------------------------------------------------------*/
    /* HANDLE THE FREE SPACE AFTER THE ALIGNED BLOCK. IF IT IS LARGE ENOUGH  */
    /* TO BE A BLOCK OF ITS OWN, THEN MAKE IT ONE, OTHERWISE ADD THE         */
    /* LEFTOVER SIZE TO THE ALIGNED BLOCK.                                   */
    /*-----------------------------------------------------------------------*/
    if (leftover >= BLOCK_OVERHEAD + MIN_BLOCK)
    {
       register PACKET *next = (PACKET *) (aln_start + newsize);
       next->packet_size     = leftover - BLOCK_OVERHEAD;
       minsert(next);
    }
    else aln_packet->packet_size += leftover;

    return aln_start;
}
       

#ifdef MALLOC_DEBUG

/*****************************************************************************/
/*									     */
/*  MEMMAP -  Print dynamic memory allocation statistics                     */ 
/*									     */
/*****************************************************************************/
#include <stdio.h>
#ifndef MAX
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#endif

void memmap()
{
    PACKET *current = (PACKET *)_sys_memory;

    int free_block_num		= 0;
    int free_block_space	= 0;
    int free_block_max		= 0;
    int used_block_num		= 0;
    int used_block_space	= 0;
    int used_block_max		= 0;

    /*-----------------------------------------------------------------------*/
    /* LOOP THROUGH ALL PACKETS                                              */
    /*-----------------------------------------------------------------------*/
    while (current < (PACKET *) &_sys_memory[_memory_size-BLOCK_OVERHEAD]) 
    {
	int size = current->packet_size & ~BLOCK_USED;
        int used = current->packet_size & BLOCK_USED;

        printf(">> Used:%1d size:%d addr:%x\n", used, size, current);

        if (used)
	{
	    used_block_num++;
	    used_block_space += size;
	    used_block_max   = MAX(used_block_max, size);
	}
	else
	{
	    free_block_num++;
	    free_block_space += size;
	    free_block_max   = MAX(free_block_max, size);
	}

        current = (PACKET *)((char *)current + size + BLOCK_OVERHEAD);
    }

    printf("fr_nm:%d fr_sp:%d fr_mx:%d us_nm:%d us_sp:%d us_mx:%d ovr:%d\n\n", 
	    free_block_num, free_block_space, free_block_max,
	    used_block_num, used_block_space, used_block_max,
	    (free_block_num + used_block_num) * BLOCK_OVERHEAD);

    fflush(stdout);
}
#endif
memset.c/       868562440   0     0     0       513       `
/****************************************************************************/
/*  memset v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

void *memset(void *mem, register int ch, register size_t length)
{
     register char *m = (char *)mem - 1;

     while (length--) *++m = ch;
     return mem;
}

mktime.c/       868562440   0     0     0       4611      `
/****************************************************************************/
/*  mktime v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>
#include <limits.h>

static const unsigned int mon_len[] ={31,28,31,30,31,30,31,31,30,31,30,31 };
static const unsigned int mon_day[] ={0,31,59,90,120,151,181,212,243,273,304,334};

#define JAN11900    1                   
#define DAYS_IN_YR  365     
#define SECS_IN_DAY (60 * 60 * 24)
#define SECS_IN_YR  (DAYS_IN_YR * SECS_IN_DAY)

/* THE FOLLOWING MACRO DETERINES IF ADDING k TO x CAUSES OVERFLOW */

#define OVERFLOW(x,k) (((x) > 0) == ((k) > 0) &&          \
                       ((unsigned)(x)       <= INT_MAX) != \
		       ((unsigned)((x)+(k)) <= INT_MAX))

#define LEAPYEAR(y)   ( ((y + 1900) % 4 == 0) &&      \
                       (((y + 1900) % 100 != 0) || ((y + 1900) % 400 == 0)) )

time_t mktime(register struct tm *tptr)
{
   time_t   result;
   int      daycount;
   int      adjust;
   unsigned returnval;
    
   /*-----------------------------------------------------------------*/
   /* HANDLE SECONDS.  IF TOO MANY OR TOO FEW, MODIFY MINUTES.        */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_sec < 0) ? -((unsigned)(-tptr->tm_sec + 59) / 60) 
			       : (tptr->tm_sec / 60);

   if (OVERFLOW(tptr->tm_min, adjust)) return((time_t) -1);
   tptr->tm_min += adjust;
   tptr->tm_sec -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE MINUTES.  IF TOO MANY OR TOO FEW, MODIFY HOURS           */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_min < 0) ? -((unsigned)(-tptr->tm_min + 59) / 60) 
			       : (tptr->tm_min / 60);

   if (OVERFLOW(tptr->tm_hour, adjust)) return((time_t) -1);
   tptr->tm_hour += adjust;
   tptr->tm_min  -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE HOURS.    IF TOO MANY OR TOO FEW, MODIFY DAYS            */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_hour < 0) ? -((unsigned)(-tptr->tm_hour + 23) / 24) 
			        : (tptr->tm_hour / 24);

   if (OVERFLOW(tptr->tm_mday, adjust)) return((time_t) -1);
   tptr->tm_mday += adjust;
   tptr->tm_hour -= adjust * 24;

   for (;;)
   {
      /*-----------------------------------------------------------------*/
      /* HANDLE MONTHS.   IF TOO MANY OR TOO FEW, MODIFY YEARS           */
      /*-----------------------------------------------------------------*/
      adjust = (tptr->tm_mon < 0) ? -((unsigned)(-tptr->tm_mon + 11) / 12) 
				  : (tptr->tm_mon / 12);

      if (OVERFLOW(tptr->tm_year, adjust)) return((time_t) -1);
      tptr->tm_year += adjust;
      tptr->tm_mon  -= adjust * 12;

      /*-----------------------------------------------------------------*/
      /* HANDLE DAYS.     IF TOO MANY OR TOO FEW, MODIFY MONTHS          */
      /*-----------------------------------------------------------------*/
      if (tptr->tm_mday <= 0)
      { 
	   tptr->tm_mon--;  
           tptr->tm_mday += mon_len[tptr->tm_mon < 0 ? 11 : tptr->tm_mon] + 
		        ((tptr->tm_mon == 1) && ((tptr->tm_year % 4) == 0));
	   continue;
      }

      /*-----------------------------------------------------------------*/
      /* CALCULATE NUMBER OF DAYS IN THIS MONTH.                         */
      /*-----------------------------------------------------------------*/
      daycount = mon_len[tptr->tm_mon] + 
		( (tptr->tm_mon == 1) && LEAPYEAR(tptr->tm_year) );

      if (tptr->tm_mday > daycount) 
	{ tptr->tm_mday -= daycount; tptr->tm_mon++; }
      else break;
   }

   /*--------------------------------------------------------------------*/
   /* WE CAN NOW BE SURE THAT ALL FIELDS IN THE TIME STRUCTURE ARE RIGHT */
   /*--------------------------------------------------------------------*/
   tptr->tm_yday = mon_day[tptr->tm_mon]  + tptr->tm_mday - 1 +
                   ( (tptr->tm_mon > 1) && LEAPYEAR(tptr->tm_year) );

   daycount      = tptr->tm_year * DAYS_IN_YR  + 
	           ((tptr->tm_year - 1) / 4)   + tptr->tm_yday;

   result        = daycount      * SECS_IN_DAY + 
	           tptr->tm_hour * (60 * 60)   +
	           tptr->tm_min  * 60          + tptr->tm_sec;

   tptr->tm_wday  = (JAN11900 + daycount) % 7;
   tptr->tm_isdst = _tz.daylight;

   return result;
}


modf.c/         868562440   0     0     0       2080      `
/****************************************************************************/
/*  modf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:56 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL MODFF(REAL x, REAL *ip)
{
/*---------------------------------------------------------------------------*/
/* Decompose x into w and f such that                                        */
/* x == w + f, abs(f) < 1, floor(w) == w (w is whole number),                */
/* and signs of x, w, f are all same.                                        */
/* Return w in *ip and f as function result.                                 */
/*---------------------------------------------------------------------------*/

   REAL y;
 
   {
   /* Deals properly with NAN, +/- INFINITY, +/- ZERO, denormalized numbers */
   
      int *ptr;
      int e;

      CPYF(y,x);
      ptr = (int *)(&y) + (((64 / 32 )-1)*(_LITTLE_ENDIAN )) ;
      
      e = ((*ptr >> (32 - (11 +1) )) & ((1<< 11 )-1) ) - (1023 -1) ;
      ptr += ((((64 / 32 )-1)*(_LITTLE_ENDIAN ^1)) - (((64 / 32 )-1)*(_LITTLE_ENDIAN )) ); /* point to LSBs of y, hope for auto increment */

      if (e <= 0) { CPYF(*ip,ZERO); return x; } /* no integer part */
      /* above also covers ZERO's and denormalized numbers */
      
      if (e >= 53 ) {CPYF(*ip,x); return ZERO;}/*no fractional part*/
      /* above also covers INFINITY and NAN */

      /* truncate towards 0 by clearing (REAL_MANTISSA-e) mantissa LSBs */
   
      if (e <= (53 - 32 ))
      {
         if (_LITTLE_ENDIAN ) * ptr ++ = 0; else * ptr -- = 0 ;
         *ptr &= ~((1 << ((53 - 32 )-e))-1);
      }
      else *ptr &= ~((1 << (53 -e))-1);
   
   }
   CPYF(*ip, y);      /* return the integer part in *ip */
   return SUBF(x,y);  /* get fractional part by subtracting integer part */

} /* MODFF */
modff.c/        868562440   0     0     0       1921      `
/****************************************************************************/
/*  modff  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:24 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL MODFF(REAL x, REAL *ip)
{
/*---------------------------------------------------------------------------*/
/* Decompose x into w and f such that                                        */
/* x == w + f, abs(f) < 1, floor(w) == w (w is whole number),                */
/* and signs of x, w, f are all same.                                        */
/* Return w in *ip and f as function result.                                 */
/*---------------------------------------------------------------------------*/

   REAL y;
 
   {
   /* Deals properly with NAN, +/- INFINITY, +/- ZERO, denormalized numbers */
   
      int *ptr;
      int e;

      CPYF(y,x);
      ptr = (int *)(&y) + (((32 / 32 )-1)*(_LITTLE_ENDIAN )) ;
      
      e = ((*ptr >> (32 - (8 +1) )) & ((1<< 8 )-1) ) - (127 -1) ;
      ptr += ((((32 / 32 )-1)*(_LITTLE_ENDIAN ^1)) - (((32 / 32 )-1)*(_LITTLE_ENDIAN )) ); /* point to LSBs of y, hope for auto increment */

      if (e <= 0) { CPYF(*ip,ZERO); return x; } /* no integer part */
      /* above also covers ZERO's and denormalized numbers */
      
      if (e >= 24 ) {CPYF(*ip,x); return ZERO;}/*no fractional part*/
      /* above also covers INFINITY and NAN */

      /* truncate towards 0 by clearing (REAL_MANTISSA-e) mantissa LSBs */
   
      *ptr &= ~((1 << (24 -e))-1);
   
   }
   CPYF(*ip, y);      /* return the integer part in *ip */
   return SUBF(x,y);  /* get fractional part by subtracting integer part */

} /* MODFF */

mpyd.c/         868562440   0     0     0       3846      `
/****************************************************************************/
/*  mpyd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:16 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );


REAL MPYF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE floating multiply.  return left * right                              */

/* Does *NOT* handle +/- INFINITY, NAN.                                      */

/* Does *NOT* handle denormalized numbers.                                   */

/*---------------------------------------------------------------------------*/
{ 

   int  rfrc, lfrc, sign;
   int lexp, rexp, pexp;           /* exponent of left, right, product */
   REAL_2UNS lft, rgt, prd;        /* fraction of left, right, product */

   /*------------------------------------------------------------------------*/
   /* Unpack fraction and exponent, ignoring signs for now.                  */
   /* Reinsert hidden bit or re-normalize fraction as appropriate.           */
   /*------------------------------------------------------------------------*/

   prd.r = 0.0;
   lft.r = left; rgt.r = right;

   sign = (lft.u.msh ^ rgt.u.msh) & MINUS;

   lfrc = (lft.u.msh &= ~MINUS); 
   rfrc = (rgt.u.msh &= ~MINUS);

   if (lexp = lfrc >> REAL_FRC_MSBs) {       /* insert hidden bit */
      if (!(lfrc &= REAL_FRC_MASK) && !lft.u.lsh) {
         /* left is a power of two */
	 if (!(rexp = (rfrc >> REAL_FRC_MSBs))) {
      
            goto resign;
      
	 }
         prd.u.msh = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;
         pexp = lexp + rexp;
         prd.u.lsh = rgt.u.lsh;
         goto insert_exponent;
      }
      lft.u.msh = lfrc + REAL_HIDDEN_BIT;
   }

   else goto resign;

   if (rexp = rfrc >> REAL_FRC_MSBs) {       /* insert hidden bit */
      if (!(rfrc &= REAL_FRC_MASK) && !rgt.u.lsh) {
         /* right is a power of two */
         pexp = lexp + rexp;
         prd.u.msh = lft.u.msh;
         prd.u.lsh = lft.u.lsh;
         goto insert_exponent;
      }
      rgt.u.msh = rfrc + REAL_HIDDEN_BIT;
   }

   else goto resign;

   /*------------------------------------------------------------------------*/
   /* Compute product exponent and fraction.                                 */
   /* Round and normalize product if needed.                                 */
   /*------------------------------------------------------------------------*/
   pexp = lexp + rexp;
   pexp += FRCMPYF(&prd, &lft, &rgt);

insert_exponent:
   /*------------------------------------------------------------------------*/
   /* Check for overflow and underflow.                                      */
   /*------------------------------------------------------------------------*/
   if ((pexp -= (1023 +1)) < 0) {     /* underflow */
   
      prd.r = 0.0; goto resign;  /* no significant bits remain */
   
   }
   else if (pexp >= (REAL_EXP_INFNAN-1)) {    /* overflow */
   
      prd.u.lsh = 0;
      prd.u.msh = REAL_INFNAN;
   
      goto resign;
   }

   /*------------------------------------------------------------------------*/
   /* assemble result and return.                                            */
   /* subtract the hidden bit and insert the exponent by adding pexp-1.      */
   /*------------------------------------------------------------------------*/
   prd.u.msh += ((int )pexp) << REAL_FRC_MSBs;

resign:;

   prd.u.msh += sign;
   return prd.r;

} /* MPYF */
mpyf.c/         868562440   0     0     0       3732      `
/****************************************************************************/
/*  mpyf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:17 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );


REAL MPYF(REAL left, REAL right)
/*---------------------------------------------------------------------------*/
/* IEEE floating multiply.  return left * right                              */

/* Does *NOT* handle +/- INFINITY, NAN.                                      */

/* Does *NOT* handle denormalized numbers.                                   */

/*---------------------------------------------------------------------------*/
{ 

   unsigned  lfrc, rfrc, pfrc;     /* fraction of left, right and product */
   int    lexp, rexp, pexp;	/* exponent of left, right and product */
   unsigned  sign;

   /*------------------------------------------------------------------------*/
   /* Unpack fraction and exponent, ignoring signs for now.                  */
   /* Reinsert hidden bit or re-normalize fraction as appropriate.           */
   /*------------------------------------------------------------------------*/
   pfrc = 0;
   REALasUNS(lfrc,  left); sign =         lfrc         ; lfrc &= ~MINUS;
   REALasUNS(rfrc, right); sign = (sign ^ rfrc) & MINUS; rfrc &= ~MINUS;

   if (lexp = (int)(lfrc >> REAL_FRC_MSBs)) {
      if (!(lfrc &= REAL_FRC_MASK)) {
         /* left is a power of two */
	 if (!(rexp = (rfrc >> REAL_FRC_MSBs))) {
         
            goto resign;
         
	 } else pfrc = ((rfrc & REAL_FRC_MASK)+REAL_HIDDEN_BIT) << 1;
         pexp = lexp + rexp;
         goto insert_exponent;
      }
      lfrc += REAL_HIDDEN_BIT; /* insert hidden bit */
   }

   else goto resign;

   if (rexp = (int)(rfrc >> REAL_FRC_MSBs)) {
      if (!(rfrc &= REAL_FRC_MASK)) {
         /* right is a power of two */
         pexp = lexp + rexp;
         pfrc = lfrc << 1;
         goto insert_exponent;
      }
      rfrc += REAL_HIDDEN_BIT; /*insert hidden bit*/
   }

   else goto resign;

   /*------------------------------------------------------------------------*/
   /* Compute product exponent and fraction.                                 */
   /* Round and normalize product if needed.                                 */
   /*------------------------------------------------------------------------*/
   pexp = lexp + rexp;

   pfrc = FRCMPYF(lfrc, rfrc);
   pfrc += 1;     /* biased rounding */
   if (pfrc >= (REAL_HIDDEN_BIT<<2)) { pfrc >>= 1; pexp += 1; }

insert_exponent:
   /*------------------------------------------------------------------------*/
   /* Check for overflow and underflow.                                      */
   /*------------------------------------------------------------------------*/
   if ((pexp -= 127 ) <= 0) {        /* underflow */

      pfrc = 0;      /* no significant bits remain */

      pexp = 0;
   }
   else if (pexp >= REAL_EXP_INFNAN) {    /* overflow */
   
      pexp = REAL_EXP_INFNAN; pfrc = 0;
   
   }

   /*------------------------------------------------------------------------*/
   /* assemble result and return.                                            */
   /*------------------------------------------------------------------------*/
   pfrc = ((pfrc >> 1) & REAL_FRC_MASK) + (((int )pexp) << REAL_FRC_MSBs);

resign:;
   pfrc += sign;

   return_UNSasREAL(pfrc);

} /* MPYF */
negd.c/         868562440   0     0     0       636       `
/****************************************************************************/
/*  negd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:17 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

REAL NEGF(REAL x)
{
   MSC(x) ^= (char)(1<<(8 -1));
   return x;
} /* NEGF */
negf.c/         868562440   0     0     0       636       `
/****************************************************************************/
/*  negf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:18 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL NEGF(REAL x)
{
   MSC(x) ^= (char)(1<<(8 -1));
   return x;
} /* NEGF */
perror.c/       868562440   0     0     0       1984      `
/*****************************************************************************/
/*  PERROR.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PERROR   -  Report any system errors to stderr                         */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>


/*****************************************************************************/
/* PERROR   -  Report any system errors to stderr                            */
/*****************************************************************************/
void perror(const char *_s)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char *buf;

   /*------------------------------------------------------------------------*/
   /* If _s is not NULL, prepend it to any error message.                    */
   /*------------------------------------------------------------------------*/
   if (_s && *_s)
   {
      fputs(_s, stderr);
      fputs(": ", stderr);
   }

   switch(errno)
   {
      case 0      :  buf = "No error";                  break;
      case EDOM   :  buf = "Domain error";              break;
      case ERANGE :  buf = "Range error";               break;
      case ENOENT :  buf = "No such file or directory"; break;
      case EFPOS  :  buf = "File positioning error";    break;
      default     :  buf = "Unknown error";             break;
   }

   fputs(buf, stderr);
   fputc('\n', stderr);
}

pow.c/          868562440   0     0     0       5086      `
/****************************************************************************/
/*  pow  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:56 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL POWF(REAL x, REAL y)
{
/* Adapted from "Software Manual for the Elementary Functions"               */
/* Cody and Waite, Prentice Hall 1980. pages 84-112.                         */

    static REAL A1[17] = /* 53 mantissa bits */
      {KNST( 1.0000000000000000000000E+00), 
       KNST( 9.5760328069857370003603E-01), 
       KNST( 9.1700404320467121532800E-01), 
       KNST( 8.7812608018664972675537E-01), 
       KNST( 8.4089641525371450203607E-01), 
       KNST( 8.0524516597462714173616E-01), 
       KNST( 7.7110541270397037205697E-01), 
       KNST( 7.3841307296974967311342E-01), 
       KNST( 7.0710678118654757273731E-01), 
       KNST( 6.7712777346844632564426E-01), 
       KNST( 6.4841977732550482027562E-01), 
       KNST( 6.2092890603674200100670E-01), 
       KNST( 5.9460355750136051344867E-01), 
       KNST( 5.6939431737834578228785E-01), 
       KNST( 5.4525386633262884483741E-01), 
       KNST( 5.2213689121370687740153E-01), 
       KNST( 5.0000000000000000000000E-01)};

    static REAL A2[8] = /* 53 mantissa bits */
      {KNST(-5.3099730280915798358278E-17), 
       KNST( 1.4800703477186887541150E-17), 
       KNST( 1.2353596284702224819370E-17), 
       KNST(-1.7419972784343138430526E-17), 
       KNST( 3.8504741898901862864758E-17), 
       KNST( 2.3290137959059464613378E-17), 
       KNST( 4.4564063380522338321302E-17), 
       KNST( 4.2759448527536717652507E-17)};

    static REAL P[4] =
       {KNST(0.43445775672163119635e-3),
        KNST(0.22321421285924258967e-2),
        KNST(0.12500000000503799174e-1),
        KNST(0.83333333333333211405e-1)};

    static REAL Q[7] =
       {KNST(0.14928852680595608186e-4),
	KNST(0.15400290440989764601e-3),
	KNST(0.13333541313585784703e-2),
	KNST(0.96181290595172416964e-2),
	KNST(0.55504108664085595326e-1),
	KNST(0.24022650695909537056e+0),
        KNST(0.69314718055994529629e+0)};

    REAL g, z, v, r, u1, u2, w1, w2, w3, y1, y2, w, ip;
    EXPONENT_TYPE m, n;
    int p, iw1, i;

    if LEZF(x) 
    {
       if LSZF(x) 
       {
          if (NEQF(TRUNCF(y), y)) {errno = EDOM; return POWF(x,(ROUNDF(y)));}
          CPYF(z, POWF(ABSF(x),y));
          if (GEQF(y, CNST(-2147483648.0) ) && LSSF(y, CNST( 2147483648.0) )){
             if (FIXFI(y) & 1) NEGF1(z); /* odd */
	  } else {
             if NEZF(MODFF(MPYF(y,HALF),&ip)) NEGF1(z);
          }
          return z;
      }
      if LSZF(y) { errno = EDOM; return CNST(-1.7976931348623157e+308) ; }
      if EQZF(y) return ONE;
      return x; /* x holds 0 */
    }
     
    if EQLF(x, ONE) return x;         /* pow(1.0,y) == 1.0 */
    if EQLF(y, ONE) return x;         /* pow(x,1.0) == 1.0 */

    RIPF(x, g, m);

    /* fast more accurate path for (RADIX**(m-1))**y, y is whole number */
    if EQLF(g,CNST(0.5) )
    {
       p = FIXFI(y); /* overflow OK here */
       if EQLF(FLTIF(p),y) /*EQZF(MODFF(y,&ip))*/
          return SCLF(ONE,(m-1)*p);
    }

    p = 1;
    if LEQF(g, A1[  (9-1)]) p =  9;
    if LEQF(g, A1[p+(4-1)]) p += 4;
    if LEQF(g, A1[p+(2-1)]) p += 2;

    CPYF(z,A1[p+(1-1)]);

    /* z = ((g - z) - A2[(p+(1-1))/2])/(g + z); */
    DIVF3(z, SUBF(SUBF(g,z), 
                  A2[(p+1)/2-1]),
             ADDF(g, z));

    ADDF2(z,z);
    SQRF2(v,z);

    POLYF(r,v,P,4 );
    MPYF2(r,z);

    ADDF2(r, MPYF(CNST(0.44269504088896340736) ,r));
    ADDF3(u2, ADDF(r, MPYF(z, CNST(0.44269504088896340736) )), z);
    MPYF3(u1, FLTIF(m*16 - p), SIXTEENTH);
    if (GEQF(y, DIVF(CNST( 2147483648.0) ,SIXTEEN)) ||
        LSSF(y, DIVF(CNST(-2147483648.0)    ,SIXTEEN)))
       MPYF3(y1, ROUNDF(SCLF(y,4)), SIXTEENTH);
    else
       MPYF3(y1, RNDF(MPYF(SIXTEEN, y)), SIXTEENTH);

    SUBF3(y2, y, y1);
    ADDF3(w, MPYF(u2,y), MPYF(u1,y2));
    if (GEQF(w, DIVF(CNST( 2147483648.0) ,SIXTEEN)) ||
        LSSF(w, DIVF(CNST(-2147483648.0)    ,SIXTEEN)))
       MPYF3(w1, ROUNDF(SCLF(w,4)),SIXTEENTH);
    else
       MPYF3(w1, RNDF(MPYF(SIXTEEN,w)), SIXTEENTH);

    SUBF3(w2, w, w1);
    ADDF3(w, w1, MPYF(u1,y1));

    if GTRF(w, CNST( 11355.0) ) 
    {
       errno = ERANGE; return CNST( 1.7976931348623157e+308) ;
    }
    if LSSF(w, CNST(-11323.0) ) return ZERO;

    MPYF3(w1, RNDF(MPYF(SIXTEEN,w)), SIXTEENTH);
    ADDF2(w2, SUBF(w, w1));
    MPYF3(w3, RNDF(MPYF(SIXTEEN,w2)), SIXTEENTH);
    FIXFI2(iw1, MPYF(SIXTEEN, ADDF(w1, w3)));
    SUBF2(w2, w3);

    if GTZF(w2) 
    {
       SUBF2(w2, SIXTEENTH);
       iw1 += 1;
    }

    i = ((iw1 < 0) ? 0 : 1);
    m = (EXPONENT_TYPE)(i + iw1/16);
    p = 16*(int)(m) - iw1;

    POLYF(z,w2,Q,7 );

    ADDF3(z, A1[p+(1-1)], 
             MPYF(A1[p+(1-1)], z));

    return SCLF(z, m);
} /* POWF */
powf.c/         868562440   0     0     0       4530      `
/****************************************************************************/
/*  powf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:25 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL POWF(REAL x, REAL y)
{
/* Adapted from "Software Manual for the Elementary Functions"               */
/* Cody and Waite, Prentice Hall 1980. pages 84-112.                         */

    static REAL A1[17] = /* 24 mantissa bits */
      {KNST( 1.0000000000000E+00), 
       KNST( 9.5760327577590E-01), 
       KNST( 9.1700404882431E-01), 
       KNST( 8.7812608480453E-01), 
       KNST( 8.4089642763137E-01), 
       KNST( 8.0524516105651E-01), 
       KNST( 7.7110540866851E-01), 
       KNST( 7.3841309547424E-01), 
       KNST( 7.0710676908493E-01), 
       KNST( 6.7712777853012E-01), 
       KNST( 6.4841979742050E-01), 
       KNST( 6.2092888355255E-01), 
       KNST( 5.9460353851318E-01), 
       KNST( 5.6939429044723E-01), 
       KNST( 5.4525387287139E-01), 
       KNST( 5.2213686704635E-01), 
       KNST( 5.0000000000000E-01)};

    static REAL A2[8] = /* 24 mantissa bits */
      {KNST( 4.9226642231081E-09), 
       KNST(-4.6178851705532E-09), 
       KNST( 4.9181085994022E-09), 
       KNST(-2.2504493508369E-08), 
       KNST(-5.0616744854603E-09), 
       KNST( 2.2484190754765E-08), 
       KNST( 2.6931110719430E-08), 
       KNST( 2.4167350718989E-08)};

    static REAL P[1] =
       {KNST(0.83357541e-1)};

    static REAL Q[3] =
       {KNST(0.54360383e-1),
	KNST(0.24018510e+0),
	KNST(0.69314675e+0)};

    REAL g, z, v, r, u1, u2, w1, w2, w3, y1, y2, w, ip;
    EXPONENT_TYPE m, n;
    int p, iw1, i;

    if LEZF(x) 
    {
       if LSZF(x) 
       {
          if (NEQF(TRUNCF(y), y)) {errno = EDOM; return POWF(x,(ROUNDF(y)));}
          CPYF(z, POWF(ABSF(x),y));
          if (GEQF(y, CNST(-2147483648.0) ) && LSSF(y, CNST( 2147483648.0) )){
             if (FIXFI(y) & 1) NEGF1(z); /* odd */
	  } else {
             if NEZF(MODFF(MPYF(y,HALF),&ip)) NEGF1(z);
          }
          return z;
      }
      if LSZF(y) { errno = EDOM; return CNST(-3.402823466E+38) ; }
      if EQZF(y) return ONE;
      return x; /* x holds 0 */
    }
     
    if EQLF(x, ONE) return x;         /* pow(1.0,y) == 1.0 */
    if EQLF(y, ONE) return x;         /* pow(x,1.0) == 1.0 */

    RIPF(x, g, m);

    /* fast more accurate path for (RADIX**(m-1))**y, y is whole number */
    if EQLF(g,CNST(0.5) )
    {
       p = FIXFI(y); /* overflow OK here */
       if EQLF(FLTIF(p),y) /*EQZF(MODFF(y,&ip))*/
          return SCLF(ONE,(m-1)*p);
    }

    p = 1;
    if LEQF(g, A1[  (9-1)]) p =  9;
    if LEQF(g, A1[p+(4-1)]) p += 4;
    if LEQF(g, A1[p+(2-1)]) p += 2;

    CPYF(z,A1[p+(1-1)]);

    /* z = ((g - z) - A2[(p+(1-1))/2])/(g + z); */
    DIVF3(z, SUBF(SUBF(g,z), 
                  A2[(p+1)/2-1]),
             ADDF(g, z));

    ADDF2(z,z);
    SQRF2(v,z);

    POLYF(r,v,P,1 );
    MPYF2(r,z);

    ADDF2(r, MPYF(CNST(0.44269504088896340736) ,r));
    ADDF3(u2, ADDF(r, MPYF(z, CNST(0.44269504088896340736) )), z);
    MPYF3(u1, FLTIF(m*16 - p), SIXTEENTH);
    if (GEQF(y, DIVF(CNST( 2147483648.0) ,SIXTEEN)) ||
        LSSF(y, DIVF(CNST(-2147483648.0)    ,SIXTEEN)))
       MPYF3(y1, ROUNDF(SCLF(y,4)), SIXTEENTH);
    else
       MPYF3(y1, RNDF(MPYF(SIXTEEN, y)), SIXTEENTH);

    SUBF3(y2, y, y1);
    ADDF3(w, MPYF(u2,y), MPYF(u1,y2));
    if (GEQF(w, DIVF(CNST( 2147483648.0) ,SIXTEEN)) ||
        LSSF(w, DIVF(CNST(-2147483648.0)    ,SIXTEEN)))
       MPYF3(w1, ROUNDF(SCLF(w,4)),SIXTEENTH);
    else
       MPYF3(w1, RNDF(MPYF(SIXTEEN,w)), SIXTEENTH);

    SUBF3(w2, w, w1);
    ADDF3(w, w1, MPYF(u1,y1));

    if GTRF(w, CNST( 1418.0) ) 
    {
       errno = ERANGE; return CNST( 3.402823466E+38) ;
    }
    if LSSF(w, CNST(-1386.0) ) return ZERO;

    MPYF3(w1, RNDF(MPYF(SIXTEEN,w)), SIXTEENTH);
    ADDF2(w2, SUBF(w, w1));
    MPYF3(w3, RNDF(MPYF(SIXTEEN,w2)), SIXTEENTH);
    FIXFI2(iw1, MPYF(SIXTEEN, ADDF(w1, w3)));
    SUBF2(w2, w3);

    if GTZF(w2) 
    {
       SUBF2(w2, SIXTEENTH);
       iw1 += 1;
    }

    i = ((iw1 < 0) ? 0 : 1);
    m = (EXPONENT_TYPE)(i + iw1/16);
    p = 16*(int)(m) - iw1;

    POLYF(z,w2,Q,3 );

    ADDF3(z, A1[p+(1-1)], 
             MPYF(A1[p+(1-1)], z));

    return SCLF(z, m);
} /* POWF */
powi.c/         868562440   0     0     0       1570      `
/****************************************************************************/
/*  powi  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:57 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL POWIF(REAL x, int i) /* return x ** i, i an integer */
{
   REAL r, s, rp, sp;
   int invert;
   int t;

   RIPF(x, r, t);
   if EQLF(r, CNST(0.5) ) return SCLF(ONE,(t-1)*i);

   invert = 0 ;
   t = i;
   if (t < 0) {
      invert = 1 ;
      if (t > INT_MIN) t = -t;
   }
   CPYF(s,x);
   if (t & 1) CPYF(r,s); else CPYF(r,ONE);
   if (t < 0) t = -(INT_MIN/2); else t = t >> 1;
   while ((t != 0) && NEZF(r)) {
      SQRF2(sp,s);
      if GEQF(sp,CNST( 1.7976931348623157e+308) ) { /* overflow? */
         if (!invert) { errno = ERANGE; return CNST( 1.7976931348623157e+308) ; };
         INVF1(s); INVF1(r);
         invert = 0 ;
         SQRF2(sp,s);         
      }
      if (t & 1) {
         MPYF3(rp,r,sp);
         if GEQF(rp,CNST( 1.7976931348623157e+308) ) { /* overflow? */
            if (!invert) { errno = ERANGE; return CNST( 1.7976931348623157e+308) ; };
            INVF1(s); INVF1(r);
            invert = 0 ;
            SQRF2(sp,s);
            MPYF3(rp,r,sp);
         }
      }
      CPYF(s,sp); CPYF(r,rp);
      t = t >> 1;
   }
   if (invert) return INVF(r);
   return r;
} /* POWIF */
powif.c/        868562440   0     0     0       1539      `
/****************************************************************************/
/*  powif  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:26 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL POWIF(REAL x, int i) /* return x ** i, i an integer */
{
   REAL r, s, rp, sp;
   int invert;
   int t;

   RIPF(x, r, t);
   if EQLF(r, CNST(0.5) ) return SCLF(ONE,(t-1)*i);

   invert = 0 ;
   t = i;
   if (t < 0) {
      invert = 1 ;
      if (t > INT_MIN) t = -t;
   }
   CPYF(s,x);
   if (t & 1) CPYF(r,s); else CPYF(r,ONE);
   if (t < 0) t = -(INT_MIN/2); else t = t >> 1;
   while ((t != 0) && NEZF(r)) {
      SQRF2(sp,s);
      if GEQF(sp,CNST( 3.402823466E+38) ) { /* overflow? */
         if (!invert) { errno = ERANGE; return CNST( 3.402823466E+38) ; };
         INVF1(s); INVF1(r);
         invert = 0 ;
         SQRF2(sp,s);         
      }
      if (t & 1) {
         MPYF3(rp,r,sp);
         if GEQF(rp,CNST( 3.402823466E+38) ) { /* overflow? */
            if (!invert) { errno = ERANGE; return CNST( 3.402823466E+38) ; };
            INVF1(s); INVF1(r);
            invert = 0 ;
            SQRF2(sp,s);
            MPYF3(rp,r,sp);
         }
      }
      CPYF(s,sp); CPYF(r,rp);
      t = t >> 1;
   }
   if (invert) return INVF(r);
   return r;
} /* POWIF */

printf.c/       868562440   0     0     0       2825      `
/*****************************************************************************/
/*  PRINTF.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PRINTF   -  Print formatted output to stdio                            */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
 
 
 
 

/*****************************************************************************/
/* PRINTF   -  Print formatted output to stdio                               */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream stdio.            */
/*                                                                           */
/*****************************************************************************/
int printf(const char *_format, ...)
{
   va_list _ap;
   int rval;
   char *fptr = (char *)_format;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(stdout->fd == -1) return (-1);

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)stdout, _outc, _outs);
   va_end(_ap);
   return (rval);
}
 
 
 



/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


qsort.c/        868562440   0     0     0       1628      `
/****************************************************************************/
/*  qsort v1.10#                                                            */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>

static void swap_item();

void qsort(void *base, size_t nmemb, size_t size, int (*compar)())
{
   register char     *basep  = base;         /* POINTER TO ARRAY OF ELEMENTS */
   register unsigned  i      = 0;            /* left scan index  */
   register unsigned  j      = nmemb - 1;    /* right scan index */
   register unsigned  pivot  = (nmemb / 2);
   register char     *pivp   = basep + (pivot * size);

   if (nmemb <= 1) return;

   while( i < j )
   {
      while( (*compar) (basep + (i * size), pivp) < 0 ) ++i;
      while( (*compar) (basep + (j * size), pivp) > 0 ) --j;
      if( i < j )
      {
	 swap_item(basep + (i * size), basep + (j * size), size);
	 if     ( pivot == i ) { pivot = j; pivp = basep + (pivot * size); }
	 else if( pivot == j ) { pivot = i; pivp = basep + (pivot * size); } 
	 ++i; --j;
      }
      else if ( i == j ) { ++i; --j;  break; }
   }

   if( j > 0)       qsort(basep, j + 1, size, compar);
   if( i < nmemb-1) qsort(basep + (i * size), nmemb - i, size, compar);
}


static void swap_item(register char *src, 
                      register char *dest, 
                      register size_t size)
{
    while (size--)
    {
        register int temp = *src;       
        *src++            = *dest;
        *dest++           = temp;
    }
}

rand.c/         868562440   0     0     0       750       `
/****************************************************************************/
/*  rand.c v1.10#							    */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>

/***************************************************************/
/* THIS IS AN IMPLEMENTATION WHICH IS INTENDED TO BE PORTABLE, */
/* AS PER THE ANSI STANDARD C SPECIFICATION                    */
/***************************************************************/
static unsigned long next = 1;

int rand(void)
{
     next = next * 1103515245 + 12345;
     return (unsigned int)(next/65536) % (RAND_MAX + 1);
}

void srand(unsigned seed)
{
     next = seed;
}

remove.c/       868562442   0     0     0       985       `
/*****************************************************************************/
/*  REMOVE.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    REMOVE   -  Erase a file                                               */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"






/*****************************************************************************/
/* REMOVE   -  Erase a file                                                  */
/*****************************************************************************/
int remove(const char *_file) { return (_remove(_file)); }


renormd.c/      868562442   0     0     0       1586      `
/****************************************************************************/
/*  renormd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:17 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

int RENORMF(REAL_2UNS *ff)
/*---------------------------------------------------------------------------*/
/* If ff contains 0, return ZCOUNT (why?).                                   */
/* Otherwise, shift ff left until it is normalized (ff >= REAL_HIDDEN_BIT)   */
/* and return the shift count minus 1.                                       */
/*---------------------------------------------------------------------------*/
{
    int shift;
    int offset = -1;
    unsigned tmp;

    while ((tmp = ff->u.msh) == 0) {
	if (ff->u.lsh == 0) return -10 ;

	/* top word is zero, so move some bottom bits up */
	ff->u.msh = ff->u.lsh >> 32  -(REAL_FRC_MSBs)-1;
	ff->u.lsh <<= (REAL_FRC_MSBs)+1;
	offset += (REAL_FRC_MSBs)+1;
    }
  
    shift = _lmbd(1,  tmp ) - 32  +(REAL_FRC_MSBs)+1;
    tmp <<= shift;
  
    if (shift != 0) {
       /* fill in vacated bits with bits from the lower word */
       ff->u.msh = tmp | (ff->u.lsh >> 32  -shift);
       ff->u.lsh <<= shift;
    }

    return shift + offset;
} /* RENORMF */

renormf.c/      868562442   0     0     0       561       `
/****************************************************************************/
/*  renormf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:18 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );


rewind.c/       868562442   0     0     0       1052      `
/*****************************************************************************/
/*  REWIND.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    REWIND   -  Position a stream's file pointer to the beginning of a     */
/*                file                                                       */
/*****************************************************************************/
#include <stdio.h>






/*****************************************************************************/
/* REWIND   -  Position a stream's file pointer to the beginning of a file   */
/*****************************************************************************/
void  rewind(register FILE *_fp) { fseek(_fp, 0L, SEEK_SET); }


round.c/        868562442   0     0     0       1130      `
/****************************************************************************/
/*  round  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:57 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ROUNDF(REAL x)
{

   /* unbiased rounding */
   REAL fp, ip;
   CPYF(fp, MODFF(x,&ip));
   if LSZF(fp) {
      if GTRF(fp, CNST(-0.5)) return ip;
      if EQLF(fp, CNST(-0.5)) { /* round towards even if exactly midway */
         REAL ip2;
         if EQLF(MODFF(LDEXPF(ip,-1),&ip2), CNST(-0.5)) return SUBF(ip,ONE);
         return ip;
      }
      return SUBF(ip,ONE);
   } else {
      if LSSF(fp, CNST( 0.5)) return ip;
      if EQLF(fp, CNST( 0.5)) { /* round towards even if exactly midway */
         REAL ip2;
         if EQLF(MODFF(LDEXPF(ip,-1),&ip2), CNST( 0.5)) return ADDF(ip,ONE);
         return ip;
      }
      return ADDF(ip,ONE);
   }

} /* ROUNDF */
roundf.c/       868562442   0     0     0       1131      `
/****************************************************************************/
/*  roundf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:26 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL ROUNDF(REAL x)
{

   /* unbiased rounding */
   REAL fp, ip;
   CPYF(fp, MODFF(x,&ip));
   if LSZF(fp) {
      if GTRF(fp, CNST(-0.5)) return ip;
      if EQLF(fp, CNST(-0.5)) { /* round towards even if exactly midway */
         REAL ip2;
         if EQLF(MODFF(LDEXPF(ip,-1),&ip2), CNST(-0.5)) return SUBF(ip,ONE);
         return ip;
      }
      return SUBF(ip,ONE);
   } else {
      if LSSF(fp, CNST( 0.5)) return ip;
      if EQLF(fp, CNST( 0.5)) { /* round towards even if exactly midway */
         REAL ip2;
         if EQLF(MODFF(LDEXPF(ip,-1),&ip2), CNST( 0.5)) return ADDF(ip,ONE);
         return ip;
      }
      return ADDF(ip,ONE);
   }

} /* ROUNDF */

rsqrt.c/        868562442   0     0     0       3015      `
/****************************************************************************/
/*  rsqrt  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:58 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL RSQRTF(REAL x)
{
    
    EXPONENT_TYPE e;
    REAL    f, y;
    int           i;

    if LEZF(x) 
    {
       errno = EDOM;

       /* Assume that an argument of <= 0.0 got that way because of finite   */
       /* precision during preceeding calculations and that the ideal        */
       /* value is actually a number approaching 0.0 from the positive side. */
       return CNST( 1.7976931348623157e+308) ;
    }

    RIPF(x, f, e);

    /* First form an estimate of the inverse-square-root.                */
    /* The accuracy of the estimate determines the number of required    */
    /* Newton iterations to compute the required n-bit mantissa result.  */
    /* Given a number expressed as x = f* 2**e, an estimate of 1/SQRT(x),*/
    /* may be computed as:                                               */
    /*   1/SQRT(x)                                                       */
    /* = 1/SQRT(f * 2**e)                                                */
    /* = 1/SQRT(f)      * 1/SQRT(2**e)                                   */
    /*~= (C1*f + C2)    * 1/SQRT(2**(e & 1)) * 1/SQRT(2**(e-(e & 1)))    */
    /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2))     */
    /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */
    /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */
    /* = 2*(C1*f + C2)  * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */
    /* =(2*C1*f + 2*C2) * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */
    /* =(2*C1*f + 2*C2) * {1 or 1/SQRT(2)}   * (2**-((e-(e & 1))/2)-1)   */

    /* .5 <= f < 1, we need 1 <= f < 2, so... */
    /* e = e - 1  ; -- moved below.  Maybe CPU has LSB test as byproduct. */
    /* f = f * 2.0; -- subsumed into calculation below */

    ADDF3(f, MPYF(CNST(-1.145508) ,f), CNST( 2.528320) );
    e -= 1;
    if (e & 1)
    {
       e -= 1;
       MPYF2(f, One_Over_Sqrt_2);
    }

    SCLF3(y, f, ~(e >> 1));  /* note: last use of "e" */

    /* Estimate of 1/sqrt in y now good to about 5 mantissa bits. */
    /* Refine estimate with Newton iterations.                    */
    /* Accuracy roughly doubles each time through the loop.       */
    /* Haven't determined actual accuracy vs. iterations yet.     */
    /* Thresholds on loop choices are thus overly conservative.   */
    /* Note: Cannot square y below for reasons of over/under-flow.*/
    for (i = 1; i <= (3 +1); i++)
       /* y = y+y*(0.5-((x*y)*0.5)*y); */
       ADDF2(y,MPYF(y,SUBF(HALF,MPYF(MPYF(MPYF(x,y),HALF),y))));

    return y;
} /* RSQRTF */

rsqrtf.c/       868562442   0     0     0       3008      `
/****************************************************************************/
/*  rsqrtf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:27 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL RSQRTF(REAL x)
{
    
    EXPONENT_TYPE e;
    REAL    f, y;
    int           i;

    if LEZF(x) 
    {
       errno = EDOM;

       /* Assume that an argument of <= 0.0 got that way because of finite   */
       /* precision during preceeding calculations and that the ideal        */
       /* value is actually a number approaching 0.0 from the positive side. */
       return CNST( 3.402823466E+38) ;
    }

    RIPF(x, f, e);

    /* First form an estimate of the inverse-square-root.                */
    /* The accuracy of the estimate determines the number of required    */
    /* Newton iterations to compute the required n-bit mantissa result.  */
    /* Given a number expressed as x = f* 2**e, an estimate of 1/SQRT(x),*/
    /* may be computed as:                                               */
    /*   1/SQRT(x)                                                       */
    /* = 1/SQRT(f * 2**e)                                                */
    /* = 1/SQRT(f)      * 1/SQRT(2**e)                                   */
    /*~= (C1*f + C2)    * 1/SQRT(2**(e & 1)) * 1/SQRT(2**(e-(e & 1)))    */
    /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2))     */
    /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */
    /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */
    /* = 2*(C1*f + C2)  * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */
    /* =(2*C1*f + 2*C2) * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */
    /* =(2*C1*f + 2*C2) * {1 or 1/SQRT(2)}   * (2**-((e-(e & 1))/2)-1)   */

    /* .5 <= f < 1, we need 1 <= f < 2, so... */
    /* e = e - 1  ; -- moved below.  Maybe CPU has LSB test as byproduct. */
    /* f = f * 2.0; -- subsumed into calculation below */

    ADDF3(f, MPYF(CNST(-1.145508) ,f), CNST( 2.528320) );
    e -= 1;
    if (e & 1)
    {
       e -= 1;
       MPYF2(f, One_Over_Sqrt_2);
    }

    SCLF3(y, f, ~(e >> 1));  /* note: last use of "e" */

    /* Estimate of 1/sqrt in y now good to about 5 mantissa bits. */
    /* Refine estimate with Newton iterations.                    */
    /* Accuracy roughly doubles each time through the loop.       */
    /* Haven't determined actual accuracy vs. iterations yet.     */
    /* Thresholds on loop choices are thus overly conservative.   */
    /* Note: Cannot square y below for reasons of over/under-flow.*/
    for (i = 1; i <= (2 +1); i++)
       /* y = y+y*(0.5-((x*y)*0.5)*y); */
       ADDF2(y,MPYF(y,SUBF(HALF,MPYF(MPYF(MPYF(x,y),HALF),y))));

    return y;
} /* RSQRTF */
setbuf.c/       868562442   0     0     0       1349      `
/*****************************************************************************/
/*  SETVBUF.C v1.10#                                                         */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SETBUF   -  Set the default buffering mode for a stream                */
/*****************************************************************************/
#include <stdio.h>
 
 
 
 
 

/*****************************************************************************/
/* SETBUF   -  Set the default buffering mode for a stream                   */
/*                                                                           */
/*    This function calls SETVBUF, and sets the buffering mode to non-       */
/*    buffered if _BUF is NULL, or fully-buffered if _BUF is not NULL.       */
/*                                                                           */
/*****************************************************************************/
void setbuf(register FILE *_fp, char *_buf)
{
   setvbuf(_fp, _buf, _buf ? _IOFBF : _IONBF, BUFSIZ);
   return;
}
 


setvbuf.c/      868562442   0     0     0       4018      `
/*****************************************************************************/
/*  SETVBUF.C  v1.10#                                                        */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SETVBUF  -  Set the buffering mode for a stream                        */
/*****************************************************************************/
#include <stdio.h>
#include <stdlib.h>

extern void   _cleanup();
extern void  (*_cleanup_ptr)(void);






/*****************************************************************************/
/* SETVBUF  -  Set the buffering mode for a stream                           */
/*                                                                           */
/*    This function sets the buffering mode for a stream, and allocates a    */
/*    buffer for it if necessary.                                            */
/*                                                                           */
/*****************************************************************************/
int setvbuf(register FILE *_fp, register char *_buf, register int _type, 
            register size_t _size)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1 || _size <= 0) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If a buffer already exists, free it if it was malloc'd, and reset all  */
   /* of the stream's buffer pointers.                                       */
   /*------------------------------------------------------------------------*/
   if(_fp->buf)
   {
      if(_STCHK(_fp, _BUFFALOC)) free((_fp->buf)-1);
      _UNSET(_fp, _BUFFALOC);
      _fp->buf = NULL;
      _fp->pos = NULL;
      _fp->bufend = NULL;
      _fp->buff_stop = NULL;
   }

   /*------------------------------------------------------------------------*/
   /* If NULL was used for the buffering mode, default to fully-buffered.    */
   /*------------------------------------------------------------------------*/
   if(! _type) _type = _IOFBF;

   /*------------------------------------------------------------------------*/
   /* Clear any previous buffering flags, and set the new one.               */
   /*------------------------------------------------------------------------*/
   _UNSET(_fp, (_IOLBF | _IOFBF | _IONBF));
   _SET(_fp, _type);

   /*------------------------------------------------------------------------*/
   /* If a buffer was provided, but its size is only one byte, allocate a    */
   /* different one.  Also, do not allow a buffer size greater than BUFSIZ.  */
   /* The buffer will always have one space at the beginning that is         */
   /* for UNGETC, in the event that an UNGETC is performed on an empty file, */
   /* or when the buffer is full, but unread.                                */
  /*------------------------------------------------------------------------*/
   if(_size == 1) _buf = NULL;
   if(_size > BUFSIZ-1) _size = BUFSIZ -1;
   _size++;

   if (_buf) _fp->pos = _fp->buf = (unsigned char*)_buf+1;
   else
   {
      if (! (_fp->pos = _fp->buf = (unsigned char*)malloc(_size))) return (EOF);
      _fp->pos++;
      _fp->buf++;
      _SET(_fp, _BUFFALOC);
   }

   _fp->bufend = _fp->buf + _size -1;

   /*------------------------------------------------------------------------*/
   /* SETUP _CLEANUP_PTR SO ALL BUFFERS WILL BE FLUSHED AT EXIT.             */
   /*------------------------------------------------------------------------*/
   _cleanup_ptr = _cleanup;

   return (0);
}
   
sin.c/          868562442   0     0     0       2246      `
/****************************************************************************/
/*  sin  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:58 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL SINF(REAL x)
{

/* Adapted from "Software Manual for the Elementary Functions" */
/* Cody and Waite, Prentice Hall 1980. pages 127-133           */

    static REAL R[8] =
       {KNST( 0.27204790957888846175e-14),
        KNST(-0.76429178068910467734e-12),
        KNST( 0.16058936490371589114e-9),
        KNST(-0.25052106798274584544e-7),
        KNST( 0.27557319210152756119e-5),
        KNST(-0.19841269841201840457e-3),
        KNST( 0.83333333333331650314e-2),
        KNST(-0.16666666666666665052e+0)};

    int MustNegate, n, i;
    REAL f, g, xn, x1, Result, y;

    MustNegate = LSZF(x);
    ABSF2(y, x);
    CPYF(f, x); /* fast code for -PI/2..PI/2 */
    if GTRF(y, Pi_Over_Two) 
    {
       MPYF3(xn, y, One_Over_Pi);

       if GEQF(y, CNST( 2147483648.0) )

       {
          REAL ip;
          CPYF(xn, ROUNDF(xn));
          n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */
          CPYF(x1,TRUNCF(y));
       }
       else
       { 
          FIXFI2(n, ADDF(xn,HALF)); /* round (xn > 0) */
          FLTIF2(xn, n);
          TNCF2(x1, y);
       }

       /* f = ((x1 - xn * C1) + (y - x1)) - xn * C2; */
       SUBF3(f, ADDF(SUBF(x1, 
                          MPYF(xn,CNST(3.1416015625) )), 
                     SUBF(y,x1)), 
                MPYF(xn,CNST(-0.8908910206761537356617e-5) ));

       /* protect against round-off and enhanced precision problems */
       if GTRF(ABSF(f), Pi_Over_Two)
          CPYF(f, (GTZF(f) ? Pi_Over_Two : NEGF(Pi_Over_Two)));

       if (MustNegate ^ (n & 1)) NEGF1(f);
    }

    SQRF2(g, f);

    POLYF(Result, g, R, 8 );

    ADDF3(Result, f, MPYF(f, Result));

    /* deal with round-off errors */
    if GTRF(ABSF(Result), ONE)
       Result = (GTRF(Result,ONE) ? ONE : CNST(-1.0));

    return Result;
} /* SINF */
sinf.c/         868562442   0     0     0       2013      `
/****************************************************************************/
/*  sinf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:27 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL SINF(REAL x)
{

/* Adapted from "Software Manual for the Elementary Functions" */
/* Cody and Waite, Prentice Hall 1980. pages 127-133           */

    static REAL R[4] = 
       {KNST( 0.2601903036e-5),
        KNST(-0.1980741872e-3),
        KNST( 0.8333025139e-2),
        KNST(-0.1666665668e+0)};

    int MustNegate, n, i;
    REAL f, g, xn, x1, Result, y;

    MustNegate = LSZF(x);
    ABSF2(y, x);
    CPYF(f, x); /* fast code for -PI/2..PI/2 */
    if GTRF(y, Pi_Over_Two) 
    {
       MPYF3(xn, y, One_Over_Pi);

       if GEQF(xn, RND_MAX_P1)

       {
          REAL ip;
          CPYF(xn, ROUNDF(xn));
          n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */
          CPYF(x1,TRUNCF(y));
       }
       else
       { 
          FIXFI2(n, ADDF(xn,HALF)); /* round (xn > 0) */
          FLTIF2(xn, n);
          TNCF2(x1, y);
       }

       /* f = ((x1 - xn * C1) + (y - x1)) - xn * C2; */
       SUBF3(f, ADDF(SUBF(x1, 
                          MPYF(xn,CNST(3.140625) )), 
                     SUBF(y,x1)), 
                MPYF(xn,CNST(9.67653589793e-4) ));

       /* protect against round-off and enhanced precision problems */
       if GTRF(ABSF(f), Pi_Over_Two)
          CPYF(f, (GTZF(f) ? Pi_Over_Two : NEGF(Pi_Over_Two)));

       if (MustNegate ^ (n & 1)) NEGF1(f);
    }

    SQRF2(g, f);

    POLYF(Result, g, R, 4 );

    ADDF3(Result, f, MPYF(f, Result));

    /* deal with round-off errors */
    if GTRF(ABSF(Result), ONE)
       Result = (GTRF(Result,ONE) ? ONE : CNST(-1.0));

    return Result;
} /* SINF */

sinh.c/         868562442   0     0     0       1912      `
/****************************************************************************/
/*  sinh  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:35:59 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL SINHF (REAL x)
{
   
   static REAL P[4] =
      {KNST(-0.78966127417357099479e+0),
       KNST(-0.16375798202630751372e+3),
       KNST(-0.11563521196851768270e+5),
       KNST(-0.35181283430177117881e+6)};

   static REAL Q[3] =
      {KNST(-0.27773523119650701667e+3),
       KNST( 0.36162723109421836460e+5),
       KNST(-0.21108770058106271242e+7)};

    REAL g, w, y, z, Result;

    /* Adapted from "Software Manual for the Elementary Functions" */
    /* Cody and Waite, Prentice Hall 1980. pages 217-228.          */

    ABSF2(y,x);
    if LEQF(y,ONE) 
    {
       if LSSF(y, CNST(1.490116119384765625e-08) ) return x;
       SQRF2(g, x);

       POLYF(Result,g,P,4 );
       POLYbF(z,g,Q,3 );
       DIVF2(Result, z);

       ADDF3(Result, x, MPYF(x,Result));
    }
    else 
    {
       if LEQF(y, CNST(7.097827128933838594e+02) ) 
       {
          CPYF(z, EXPF(y));
          MPYF3(Result, SUBF(z, INVF(z)), HALF);
       }
       else 
       {
          SUBF3(w, y, 0.69316101074218750000E+0 );
          if GTRF(w, ADDF(SUBF(CNST(7.097827128933838594e+02) ,0.69316101074218750000E+0 ),0.69) ) 
          {
             errno = EDOM;
             if LSZF(x) return CNST(-1.7976931348623157e+308) ;
             return CNST( 1.7976931348623157e+308) ;
          }
          CPYF(z, EXPF(w));
          ADDF3(Result, z, MPYF(0.13830277879601902638E-4 ,z));
       }
       if LSZF(x) NEGF1(Result);
    }
    return Result;
} /* SINHF */
sinhf.c/        868562442   0     0     0       1665      `
/****************************************************************************/
/*  sinhf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:28 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL SINHF (REAL x)
{
   
   static REAL P[2] =
      {KNST(-0.190333399e+0),
       KNST(-0.713793159e+1)};

   static REAL Q[1] =
      {KNST(-0.428277109e+2)};

    REAL g, w, y, z, Result;

    /* Adapted from "Software Manual for the Elementary Functions" */
    /* Cody and Waite, Prentice Hall 1980. pages 217-228.          */

    ABSF2(y,x);
    if LEQF(y,ONE) 
    {
       if LSSF(y, CNST(2.44140625e-4) ) return x;
       SQRF2(g, x);

       POLYF(Result,g,P,2 );
       POLYbF(z,g,Q,1 );
       DIVF2(Result, z);

       ADDF3(Result, x, MPYF(x,Result));
    }
    else 
    {
       if LEQF(y, CNST( 88.72283382) ) 
       {
          CPYF(z, EXPF(y));
          MPYF3(Result, SUBF(z, INVF(z)), HALF);
       }
       else 
       {
          SUBF3(w, y, 0.69316101074218750000E+0 );
          if GTRF(w, ADDF(SUBF(CNST( 88.72283382) ,0.69316101074218750000E+0 ),0.69) ) 
          {
             errno = EDOM;
             if LSZF(x) return CNST(-3.402823466E+38) ;
             return CNST( 3.402823466E+38) ;
          }
          CPYF(z, EXPF(w));
          ADDF3(Result, z, MPYF(0.13830277879601902638E-4 ,z));
       }
       if LSZF(x) NEGF1(Result);
    }
    return Result;
} /* SINHF */

sprintf.c/      868562442   0     0     0       2602      `
/*****************************************************************************/
/*  SPRINTF.C v1.10#                                                         */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SPRINTF  -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);






/*****************************************************************************/
/* SPRINTF  -  Copy formatted output to a string                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
int sprintf(char *_string, const char *_format, ...)
{
   va_list _ap;
   int rval;
   char *fptr = (char *)_format;

   *_string = '\0'; 
   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)_string, _outc, _outs);
   va_end(_ap);
   return (rval);

}






/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
   strncat((char *)_op, &c, 1);
   return(c);
}






/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
   strcat((char *)_op, s);
   return(strlen(s));
}
 
sqrt.c/         868562442   0     0     0       3372      `
/****************************************************************************/
/*  sqrt  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:36:00 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL SQRTF(REAL x)
{
    REAL    f, y, z;
    EXPONENT_TYPE e;
    int           i;

    if LEZF(x) 
    {
       if EQZF(x) return ZERO;
       errno = EDOM;

       /* Assume that an argument of < 0.0 got that way because of finite    */
       /* precision during preceeding calculations and that the ideal        */
       /* value is actually 0.0.                                             */
       return ZERO;
    }

    RIPF(x, f, e);

    {
    
       /* First form an estimate of the inverse-square-root.                */
       /* The accuracy of the estimate determines the number of required    */
       /* Newton iterations to compute the required n-bit mantissa result.  */
       /* Given a number expressed as x = f* 2**e, an estimate of 1/SQRT(x),*/
       /* may be computed as:                                               */
       /*   1/SQRT(x)                                                       */
       /* = 1/SQRT(f * 2**e)                                                */
       /* = 1/SQRT(f)      * 1/SQRT(2**e)                                   */
       /*~= (C1*f + C2)    * 1/SQRT(2**(e & 1)) * 1/SQRT(2**(e-(e & 1)))    */
       /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2))     */
       /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */
       /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */
       /* = 2*(C1*f + C2)  * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */
       /* =(2*C1*f + 2*C2) * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */
       /* =(2*C1*f + 2*C2) * {1 or 1/SQRT(2)}   * (2**-((e-(e & 1))/2)-1)   */

       /* .5 <= f < 1, we need 1 <= f < 2, so... */
       /* e = e - 1  ; -- moved below.  Maybe CPU has LSB test as byproduct. */
       /* f = f * 2.0; -- subsumed into calculation below */

       ADDF3(f, MPYF(CNST(-1.145508) ,f), CNST( 2.528320) );

       e -= 1;
       if (e & 1) 
       {
          e -= 1;
          MPYF2(f, One_Over_Sqrt_2);
       }
       SCLF3(y, f, ~(e >> 1));  /* note: last use of "e" */

       /* Estimate of 1/sqrt in y now good to about 5 mantissa bits. */
       /* Refine estimate with Newton iterations.                    */

       /* Do one less newton iterations than is required.            */
       /* Accuracy roughly doubles each time through the loop.       */
       /* Haven't determined actual accuracy vs. iterations yet.     */
       /* Thresholds on loop choices are thus overly conservative.   */
       /* Note: Cannot square y below for reasons of over/under-flow.*/
       for (i = 1; i <= 3 ; i++)
          /* y = y+y*(0.5-((x*y)*0.5)*y); */
          ADDF2(y,MPYF(y,SUBF(HALF,MPYF(MPYF(MPYF(x,y),HALF),y))));

       MPYF3(z,x,y);

       /* Here's the last iteration! */
       /* return z+z*(0.5-((x*y)*0.5)*y); */
       return ADDF(z,MPYF(z,SUBF(HALF,MPYF(MPYF(MPYF(x,y),HALF),y))));
    }

} /* SQRTF */

sqrtf.c/        868562442   0     0     0       3373      `
/****************************************************************************/
/*  sqrtf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:29 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL SQRTF(REAL x)
{
    REAL    f, y, z;
    EXPONENT_TYPE e;
    int           i;

    if LEZF(x) 
    {
       if EQZF(x) return ZERO;
       errno = EDOM;

       /* Assume that an argument of < 0.0 got that way because of finite    */
       /* precision during preceeding calculations and that the ideal        */
       /* value is actually 0.0.                                             */
       return ZERO;
    }

    RIPF(x, f, e);

    {
    
       /* First form an estimate of the inverse-square-root.                */
       /* The accuracy of the estimate determines the number of required    */
       /* Newton iterations to compute the required n-bit mantissa result.  */
       /* Given a number expressed as x = f* 2**e, an estimate of 1/SQRT(x),*/
       /* may be computed as:                                               */
       /*   1/SQRT(x)                                                       */
       /* = 1/SQRT(f * 2**e)                                                */
       /* = 1/SQRT(f)      * 1/SQRT(2**e)                                   */
       /*~= (C1*f + C2)    * 1/SQRT(2**(e & 1)) * 1/SQRT(2**(e-(e & 1)))    */
       /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2))     */
       /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */
       /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */
       /* = 2*(C1*f + C2)  * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */
       /* =(2*C1*f + 2*C2) * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */
       /* =(2*C1*f + 2*C2) * {1 or 1/SQRT(2)}   * (2**-((e-(e & 1))/2)-1)   */

       /* .5 <= f < 1, we need 1 <= f < 2, so... */
       /* e = e - 1  ; -- moved below.  Maybe CPU has LSB test as byproduct. */
       /* f = f * 2.0; -- subsumed into calculation below */

       ADDF3(f, MPYF(CNST(-1.145508) ,f), CNST( 2.528320) );

       e -= 1;
       if (e & 1) 
       {
          e -= 1;
          MPYF2(f, One_Over_Sqrt_2);
       }
       SCLF3(y, f, ~(e >> 1));  /* note: last use of "e" */

       /* Estimate of 1/sqrt in y now good to about 5 mantissa bits. */
       /* Refine estimate with Newton iterations.                    */

       /* Do one less newton iterations than is required.            */
       /* Accuracy roughly doubles each time through the loop.       */
       /* Haven't determined actual accuracy vs. iterations yet.     */
       /* Thresholds on loop choices are thus overly conservative.   */
       /* Note: Cannot square y below for reasons of over/under-flow.*/
       for (i = 1; i <= 2 ; i++)
          /* y = y+y*(0.5-((x*y)*0.5)*y); */
          ADDF2(y,MPYF(y,SUBF(HALF,MPYF(MPYF(MPYF(x,y),HALF),y))));

       MPYF3(z,x,y);

       /* Here's the last iteration! */
       /* return z+z*(0.5-((x*y)*0.5)*y); */
       return ADDF(z,MPYF(z,SUBF(HALF,MPYF(MPYF(MPYF(x,y),HALF),y))));
    }

} /* SQRTF */


sscanf.c/       868562442   0     0     0       4249      `
/*****************************************************************************/
/*  SSCANF.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SSCANF      -  Read formatted input from a string                      */
/*    _INPCHAR    -  Get a character from the string                         */
/*    _UNINPCHAR  -  Put a character back onto the string                    */
/*    _CHKMBC     -  Check that the characters match the input               */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static char _inpchar(void **inp);
static void _uninpchar(void **inp, char outchar);
static int _chkmbc(void **inp, char **_format, int *num_read);






/*****************************************************************************/
/* SSCANF   -  Read formatted input from a string                            */
/*                                                                           */
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */
/*****************************************************************************/
int sscanf(const char *_str, const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);

   return (_scanfi((void *)_str, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));

}






/*****************************************************************************/
/* _INPCHAR -  Get a character from the string                               */
/*****************************************************************************/
static char _inpchar(void **inp)
{
   char result;
   char *buf = (char *)(*inp);

   result = *(buf++);
   *inp = (void *)buf;  

   return ((result == '\0') ? EOF : result);
}






/*****************************************************************************/
/* _UNINPCHAR  -  Put a character back into the string                       */
/*****************************************************************************/
static void _uninpchar(void **inp, char outchar)
{
   char *buf = (char *)(*inp);
   buf--;
   *inp = (void *)buf;  
   return;
}






/*****************************************************************************/
/* _CHKMBC  -  Check that the characters match the input                     */
/*                                                                           */
/*    Check that all characters in the format string that are not part of a  */
/*    conversion specification match the input, until the next '%' or the    */
/*    end of the format string is reached.  The function returns a 0 upon    */
/*    reaching the end of the format string or a mismatch, or a 1 if a '%'   */
/*    is encountered.                                                        */
/*                                                                           */
/*****************************************************************************/
static int _chkmbc(void **inp, char **_format, int *num_read)
{
   char *buf = (char *)*inp;

   /*------------------------------------------------------------------------*/
   /* If there is a white space character in the format statement, skip to   */
   /* the next non-white space character in the input.                       */
   /*------------------------------------------------------------------------*/
   while(isspace(**_format))
   {
      for(;isspace(*buf); buf++) (*num_read)++;
      (*_format)++;
   }

   for(;(**_format != '%') && (**_format != '\0');)
      if(*((*_format)++) != *(buf++)) return (0);
      else (*num_read)++;

   if(**_format == '%')
   {
      *inp = (void *)buf;
       return 1;
   }
   else return (0);
}


strcat.c/       868562442   0     0     0       645       `
/****************************************************************************/
/*  strcat v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strcat(char *string1, const char *string2)
{
   char       *s1 = string1 - 1;
   const char *s2 = string2 - 1;

   while (*++s1);		     /* FIND END OF STRING   */
   s1--;  			     /* BACK UP OVER NULL    */
   while (*++s1 = *++s2);	     /* APPEND SECOND STRING */
   return string1;
}

strchr.c/       868562442   0     0     0       587       `
/****************************************************************************/
/*  strchr v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strchr(const char *string, int c)
{
   char        tch, ch  = c;
   const char *s        = string - 1;

   for (;;)
   {
       if ((tch = *++s) == ch) return (char *) s;
       if (!tch)               return (char *) 0;
   }
}


strcmp.c/       868562442   0     0     0       645       `
/****************************************************************************/
/*  strcmp v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

int strcmp(register const char *string1, register const char *string2)
{
     register int c1, result;

     --string2;
     c1 = *string1;

     for (;;)
     {
	 result = c1 - *++string2;
	 if (c1 == 0) break;
	 c1 = *++string1;
	 if (result != 0) break;
     }
     
     return result;
}


strcoll.c/      868562442   0     0     0       577       `
/****************************************************************************/
/*  strcoll v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

int   strcoll(const char *string1, const char *string2)
{
     register const char *r1 = string1 - 1;
     register const char *r2 = string2 - 1;
     register char cp;
 
     while ((*++r2 == (cp = *++r1)) && cp);
     return *r1 - *r2;
}

strcpy.c/       868562442   0     0     0       551       `
/****************************************************************************/
/*  strcpy v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strcpy(register char *dest, register const char *src)
{
     register char       *d = dest - 1;     
     register const char *s = src  - 1;     

     while (*++d = *++s);
     return dest;
}

strcspn.c/      868562442   0     0     0       803       `
/****************************************************************************/
/*  strcspn v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

size_t strcspn(register const char *string, const char *chs)
{
     register char ch;
     size_t count = 0;
     --string;

     while (ch = *++string)  /* FOR EACH CHARACTER IN STRING */
     {
        register const char *check = chs;
	register char  tch         = *check;

        while(tch)    /* FOR EACH CHARACTER IN LOOKUP STRING */
           if (ch == tch) return ((size_t) count);
	   else tch = *++check;

	count++;
     }

     return (size_t) count;
}

strerror.c/     868562442   0     0     0       397       `
/****************************************************************************/
/*  strerror  v1.10#                                                        */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

char *strerror(int errno)
{
     return ("String Error");
}

strftime.c/     868562442   0     0     0       3787      `
/****************************************************************************/
/*  strftime v1.10#                                                         */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>
#include <string.h>

extern int  sprintf(char *_string, const char *_format, ...);

static const char *const fday[] = { "Sunday","Monday","Tuesday","Wednesday", 
		                    "Thursday","Friday","Saturday" };
static const char *const fmon[] = { "January","February","March","April","May","June",
		                    "July","August","September","October","November",
                                    "December" };
			

size_t strftime(char            *out,
	        size_t           maxsize, 
	        const char      *format,
	        const struct tm *time)
{
    struct tm temp  = *time; 
    int       count = 0;
    char      buf[37];

    mktime(&temp);     /* MAKE SURE THIS IS A LEGITIMATE TIME */

    for (;;)
    {
          while ((count < maxsize) && *format && (*format != '%'))
	  {
	      count++;
	      *out++ = *format++;
	  }

	  if (count >= maxsize) return 0;
	  if (*format == '\0')  { *out = 0; return count; }

	  switch (*++format)
	  {
               case '%' : strcpy(buf, "%");                            break;
	       case 'z' : strcpy(buf, _tz.dstname);                    break;
	       case 'Z' : strcpy(buf, _tz.tzname);                     break;

	       case 'A' : strcpy(buf, fday[temp.tm_wday]);             break;
	       case 'a' : strcpy(buf, fday[temp.tm_wday]); buf[3] = 0; break;
	       case 'B' : strcpy(buf, fmon[temp.tm_mon]);              break;
	       case 'b' : strcpy(buf, fmon[temp.tm_mon]);  buf[3] = 0; break;
	       case 'c' : sprintf(buf, "%s %s%3d %02d:%02d:%02d %d",
				  fday[temp.tm_wday], fmon[temp.tm_mon],
				  temp.tm_mday, temp.tm_hour, temp.tm_min,
				  temp.tm_sec, temp.tm_year + 1900);
                          break;

	       case 'I' : sprintf(buf, "%02d", temp.tm_hour % 12);     break;
	       case 'H' : sprintf(buf, "%02d", temp.tm_hour);          break;
	       case 'M' : sprintf(buf, "%02d", temp.tm_min);           break;
	       case 'S' : sprintf(buf, "%02d", temp.tm_sec);           break;
	       case 'j' : sprintf(buf, "%03d", temp.tm_yday + 1);      break;
	       case 'd' : sprintf(buf, "%02d", temp.tm_mday);          break;
	       case 'w' : sprintf(buf, "%1d",  temp.tm_wday);          break;
	       case 'm' : sprintf(buf, "%02d", temp.tm_mon + 1);       break;
	       case 'y' : sprintf(buf, "%02d", temp.tm_year);          break;
	       case 'Y' : sprintf(buf, "%4d", 1900 + temp.tm_year);    break;

	       case 'p' : strcpy(buf, temp.tm_hour >= 12 ? "PM":"AM"); break;

	       case 'W' : sprintf(buf, "%2d", temp.tm_yday / 7
                              + (temp.tm_mday % 7 > temp.tm_wday) 
                              + ( (temp.tm_wday==0) && ((temp.tm_mday % 7)==0) 
                              ? 0: -1) ); break;
	       case 'U' : sprintf(buf, "%2d", temp.tm_yday / 7
                              + (temp.tm_mday % 7 > temp.tm_wday));    break;

	       case 'x' : sprintf(buf, "%3s %d, %d", fmon[temp.tm_mon], 
				temp.tm_mday, temp.tm_year + 1900);    break;
	       case 'X' : sprintf(buf, "%02d:%02d:%02d", temp.tm_hour, 
					   temp.tm_min, temp.tm_sec);  break;
	  }

          /*-------------------------------------------------------------*/
          /* IF THIS STRING WILL FIT IN BUFFER, APPEND IT.               */
          /*-------------------------------------------------------------*/
	  if ((count += strlen(buf)) > maxsize) return 0;
	  strcpy(out, buf);
	  out += strlen(buf);
	  format++;
    }
}

strlen.c/       868562442   0     0     0       483       `
/****************************************************************************/
/*  strlen v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

size_t strlen(const char *string)
{
   size_t      n = -1;
   const char *s = string - 1;

   do n++; while (*++s);
   return n;
}

strncat.c/      868562442   0     0     0       727       `
/****************************************************************************/
/*  strncat v1.10#                                                          */
/*  Copyright (c) 1993-1977 Texas Instruments Incorporated                  */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strncat(char *dest, const char *src, register size_t n)
{
    if (n)
    {
	char       *d = dest - 1;
	const char *s = src  - 1;

	while (*++d);                      /* FIND END OF STRING   */
	d--;                               /* BACK UP OVER NULL    */
	while (n--)
	  if (!(*++d = *++s)) return dest; /* APPEND SECOND STRING */
	*++d = 0;
    }
    return dest;
}


strncmp.c/      868562442   0     0     0       649       `
/****************************************************************************/
/*  strncmp v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

int strncmp(const char *string1, const char *string2, size_t n)
{
     if (n) 
     {
	 const char *s1 = string1 - 1;
	 const char *s2 = string2 - 1;
	 char        cp;
	 int         result;

	 do 
	    if (result = *++s1 - (cp = *++s2)) return result;
	 while (cp && --n);
     }
     return 0;
}

strncpy.c/      868562442   0     0     0       698       `
/****************************************************************************/
/*  strncpy v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strncpy(register char *dest, register const char *src, register size_t n)
{
     if (n) 
     {
	 register char       *d = dest - 1;
	 register const char *s = src - 1;
 
	 while ((*++d = *++s) && --n);              /* COPY STRING         */
	 if (n-- > 1) do *++d = '\0'; while (--n);  /* TERMINATION PADDING */
     }
     return dest;
}
strpbrk.c/      868562442   0     0     0       748       `
/****************************************************************************/
/*  strpbrk v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

char *strpbrk(const char *string, const char *chs)
{
     register char *str = (char *)string - 1;
     register char ch;

     while (ch = *++str)         /* FOR EACH CHARACTER IN STRING */
     {
        register char *check = (char *)chs - 1;     
	register char  tch;

        while(tch = *++check)    /* FOR EACH CHARACTER IN LOOKUP STRING */
           if (ch == tch) return str;
     }

     return 0;
}
strrchr.c/      868562442   0     0     0       606       `
/****************************************************************************/
/*  strrchr v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strrchr(const char *string, int c)
{
   char        tch, ch = c;
   char       *result  = 0;
   const char *s       = string - 1;

   for (;;)
   {
      if ((tch = *++s) == ch) result = (char *) s;
      if (!tch) break;
   }

   return result;
}
strspn.c/       868562442   0     0     0       823       `
/****************************************************************************/
/*  strspn  v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

size_t strspn(register const char *string, const char *chs)
{
     size_t count = 0;

     for (;;)            /* FOR EACH CHARACTER IN STRING */
     {
	register char  ch    = *string++;
        register char *check = (char *)chs;
	register char  tch   = *check;                

        while (tch)      /* FOR EACH CHARACTER IN LOOKUP STRING */
        {
	   if (ch == tch) break;
           tch = *++check;
        }

        if (!ch || ch != tch) return(count);
	count++;
     }
}

strstr.c/       868562442   0     0     0       742       `
/****************************************************************************/
/*  strstr v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

char *strstr(register const char *string1, const char *string2)
{
     register char cp1, cp2;
     register const char *pos = string1;

     while (*string1)         /* FOR EACH STRING IN SOURCE STRING */
     {
         register const char *cmp = string2;

         while (((cp1 = *string1++) == (cp2 = *cmp++)) && cp1);
	 if (cp2 == 0) return (char *)pos;
	 string1 = ++pos;
     }
     return (0);
}

strtod.c/       868562442   0     0     0       3039      `
/****************************************************************************/
/*  strtod v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>
#include <float.h>
#include <errno.h>
#include <math.h>

static const double powerof10[]  = { 1.e1,  1.e2,  1.e4,   1.e8, 1.e16, 
				     1.e32, 1.e64, 1.e128, 1.e256 };

static const double digits[]     = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

double strtod(const char *st, char **endptr)
{
    double      result = 0;
    char        cp;
    const char *fst    = st;
    int         exp    = 0;               /* EXPONENT              */
    int         count;                    /* EXPONENT CALCULATION  */
    int         value  = 0;               /* SUCCESSFUL PARSE      */
    int         sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if ((sign = ((cp = *fst) == '-')) || (cp == '+')) { ++fst; value = 1; }

    /*----------------------------------------------------------------------*/
    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */
    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */
    /*----------------------------------------------------------------------*/
    for (; _isdigit(cp = *fst); ++fst) 
    {
       result = result * 10 + digits[cp - '0']; 
       value  = 1;
    }

    if (cp == '.')
       while (_isdigit(cp = *++fst)) 
       {
          result = result * 10 + digits[cp - '0']; 
          value  = 1;
	  --exp;
       }

    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */

    /*----------------------------------------------------------------------*/
    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */
    /*----------------------------------------------------------------------*/
    if (value && _toupper(*fst) == 'E')
    {
       if ((sign = ((cp = *++fst) == '-')) || (cp == '+')) cp = *++fst;

       for (count = 0; _isdigit(cp); cp = *++fst)
	  { count *= 10; count += cp - '0'; }

       if (sign) exp -= count;
	    else exp += count;
    }

    /*----------------------------------------------------------------------*/
    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */
    /*----------------------------------------------------------------------*/
    if (result != 0.0)
    {
       if (exp > DBL_MAX_10_EXP) 
	  { errno = ERANGE; result = (result < 0) ? -HUGE_VAL : HUGE_VAL; }
       else if (exp < DBL_MIN_10_EXP) 
	  { errno = ERANGE; result = 0.0; }

       else if (exp < 0)
	    for (count = 0, exp = -exp; exp; count++, exp >>= 1)
	        { if (exp & 1) result /= powerof10[count]; }
       else for (count = 0; exp; count++, exp >>= 1)
	        { if (exp & 1) result *= powerof10[count]; }
    }

    if (endptr) *endptr = (char *)(value ? fst : st);
    return result;
}

strtok.c/       868562442   0     0     0       693       `
/****************************************************************************/
/*  strtok v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

char *strtok(char *str1, const char *str2)
{
     static char *last_end;
     char        *start; 

     if (str1) last_end = str1;

     last_end += strspn(last_end, str2);
     if (*last_end == '\0') return (NULL);

     start = last_end;
     last_end += strcspn(last_end, str2);

     if (*last_end != '\0') *last_end++ = '\0'; 

     return start;
}


strtol.c/       868562442   0     0     0       2715      `
/****************************************************************************/
/*  strtol v1.10#                                                           */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

long strtol(const char *st, char **endptr, int base)
{
    register long        result = 0;
    register char        cp;
    register const char *fst    = st;
    int                  digits = 0;
    int                  sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *fst) == '-')) cp = *++fst;
    else if (cp == '+') cp = *++fst;

    if (base > 36) base = 0;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  } 
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')))
		     cp = *(fst += 2);
		  if (!_isxdigit(cp)) cp = *(fst -= 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;       
	    return sign ? LONG_MIN : LONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */
    /* MINUS SIGN WAS SEEN.                                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);
    if (sign)
    {
	if (result > LONG_MAX) { errno = ERANGE; return (LONG_MIN); }
        return -result;
    }
    return result;
}


strtoul.c/      868562442   0     0     0       2458      `
/****************************************************************************/
/*  strtoul v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

unsigned long strtoul(const char *st, char **endptr, int base)
{
    register unsigned long result = 0;
    register char          cp;
    register const char   *fst = st;
    int                    digits = 0;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if (base > 36) base = 0;  

    if ((cp = *fst) == '+') cp = *++fst;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')))
		     cp = *(fst += 2);
		  if (!_isxdigit(cp)) cp = *(fst -= 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register unsigned long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;        
	    return ULONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);

    return result;
}

strxfrm.c/      868562442   0     0     0       689       `
/****************************************************************************/
/*  strxfrm v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stddef.h>
#include <string.h>

size_t strxfrm(register char *to, register const char *from, register size_t n)
{
     register int count = 0;     
     while (*from++) count++;                       /* GET LENGTH OF STRING */
     from -= count;
     from--;

     if (n) while ((*to++ = *from++) && --n);       /* COPY STRING          */

     return (count);
}

subd.c/         868562442   0     0     0       673       `
/****************************************************************************/
/*  subd  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:10:18 EDT 1997 */

#include "realdi.h"
#include "ieeemask.h"
#include "renormd.h"
#include "frcaddd.h"
#include "frcmpyd.h"
#include "frcdivd.h"


unsigned  _lmbd (unsigned , unsigned );

REAL SUBF(REAL left, REAL right)
{ 
   MSC(right) ^= (char)(1<<(8 -1));
   return ADDF(left, right);
} /* SUBF */


subf.c/         868562442   0     0     0       673       `
/****************************************************************************/
/*  subf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Wed Jun 4 18:08:19 EDT 1997 */

#include "realfi.h"
#include "ieeemask.h"
#include "renormf.h"
#include "frcaddf.h"
#include "frcmpyf.h"
#include "frcdivf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL SUBF(REAL left, REAL right)
{ 
   MSC(right) ^= (char)(1<<(8 -1));
   return ADDF(left, right);
} /* SUBF */


sysmem.c/       868562444   0     0     0       2904      `
/*****************************************************************************/
/*  sysmem   v1.10#  - System memory allocation                              */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                  */
/*****************************************************************************/
/*                                                              */
/* This module declares the memory area used by the memory      */
/* allocation functions malloc(), etc.  The size and placement  */
/* of this memory area is done in the linker (using section     */
/* directives and the -heap flag).                              */
/*                                                              */
/* NOTE 1:This mechanism works in cooperation with "memory.c"   */
/*        and the C6x linker.  If an alternate (custom) memory  */
/*        allocation scheme is used this file may need to be    */
/*        modified or discarded.                                */
/*                                                              */
/* NOTE 2:This file will only be linked in if any of the memory */
/*        allocation functions are used in the program! (or if  */
/*        you reference __sys_memory for some reason)           */
/*                                                              */
/****************************************************************/
asm("          .global __SYSMEM_SIZE  ");
asm("          .global __sys_memory   ");
asm("          .global __memory_size  ");

/****************************************************************/
/* Define heap memory area.  The size is defined in the linker. */
/****************************************************************/
asm("__sys_memory   .usect  \".sysmem\", 0, 8");

/****************************************************************/
/* GENERATE AN AUTOINITIALIZATION RECORD TO INITIALIZE HEAP.    */
/* This code assumes that "__sys_memory" contains a structure   */
/* of type PACKET (as defined in "memory.c").                   */
/* The purpose of this is to initialize the heap into one (big) */
/* free packet of size "__SYSMEM_SIZE-8".  This is equivalent   */
/* to calling minit() at boot time.                             */
/****************************************************************/
asm("          .sect   \".cinit\"       ");
asm("          .align  4                ");
asm("          .word   8                ");
asm("          .word   __sys_memory     ");
asm("          .word   __SYSMEM_SIZE-8  ");
asm("          .word   0                ");

/****************************************************************/
/*  INITIALIZE THE VARIABLE INDICATING HEAP SIZE                */
/****************************************************************/
asm("          .word   4                ");
asm("          .word   __memory_size    ");
asm("          .word   __SYSMEM_SIZE    ");
tan.c/          868562444   0     0     0       2487      `
/****************************************************************************/
/*  tan  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:36:00 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL TANF(REAL x)
{
/* Adapted from "Software Manual for the Elementary Functions" */
/* Cody and Waite, Prentice Hall 1980. pages 150-163           */

    static REAL P[3] =
       {KNST(-0.17861707342254426711e-4),
        KNST( 0.34248878235890589960e-2),
        KNST(-0.13338350006421960681e+0)};

    static REAL Q[4] =
       {KNST( 0.49819433993786512270e-6),
        KNST(-0.31181531907010027307e-3),
        KNST( 0.25663832289440112864e-1),
        KNST(-0.46671683339755294240e+0)};

    REAL y, xn, f, g, x1, xnum, xden;
    int n, i;

    ABSF2(y, x);
    MPYF3(xn, x, Two_Over_Pi);

    if GEQF(y, CNST( 2147483648.0) )

    {
       REAL ip;
       CPYF(xn,ROUNDF(xn));
       n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */
       CPYF(x1,TRUNCF(x));
    } 
    else 
    {
       if GEZF(xn) FIXFI2(n,(ADDF(xn,HALF)));
       else        FIXFI2(n,(SUBF(xn,HALF)));
       FLTIF2(xn, n);
       TNCF2(x1, x);
    }

    /* f  = ((x1 - xn * C1) + (x - x1)) - xn * C2; */
    SUBF3(f, ADDF(SUBF(x1,MPYF(xn,CNST(1.57080078125) )), SUBF(x,x1)), MPYF(xn,CNST(-0.4454455103380768678308e-5) ));

    /* protect against round-off and enhanced precision problems */
    if GTRF(ABSF(f), Pi_Over_Four)
       f = (GTZF(f) ? Pi_Over_Four : NEGF(Pi_Over_Four));

    SQRF2(g,f);

    /* xnum = ((                P1)*g*f + f); */
    /* xnum = (((       P2)*g + P1)*g*f + f); */
    /* xnum = (((P3*g + P2)*g + P1)*g*f + f); */
    POLYF(xnum, g, P, 3 )
    MPYF2(xnum,f);
    ADDF2(xnum,f);

    /* xden = ((((                Q2)*g + Q1)*g + 0.5) + 0.5); */
    /* xden = (((((       Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */
    /* xden = (((((Q4*g + Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */
    POLYF(xden, g, Q, 4 );
    ADDF2(xden,HALF);  /* do not compose these two adds! */
    ADDF2(xden,HALF);

    if ((n & 1) == 0) return      DIVF(xnum, xden);
    if NEZF(xnum)     return NEGF(DIVF(xden, xnum));

    if GTZF(xden) return CNST(-1.7976931348623157e+308) ;
    return CNST( 1.7976931348623157e+308) ;
} /* TANF */

tanf.c/         868562444   0     0     0       2245      `
/****************************************************************************/
/*  tanf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:29 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL TANF(REAL x)
{
/* Adapted from "Software Manual for the Elementary Functions" */
/* Cody and Waite, Prentice Hall 1980. pages 150-163           */

    static REAL P[1] =
       {KNST(-0.958017723e-1)};

    static REAL Q[2] =
       {KNST( 0.971685835e-2),
        KNST(-0.429135777e+0)};

    REAL y, xn, f, g, x1, xnum, xden;
    int n, i;

    ABSF2(y, x);
    MPYF3(xn, x, Two_Over_Pi);

    if GEQF(y, RND_MAX_P1)

    {
       REAL ip;
       CPYF(xn,ROUNDF(xn));
       n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */
       CPYF(x1,TRUNCF(x));
    } 
    else 
    {
       if GEZF(xn) FIXFI2(n,(ADDF(xn,HALF)));
       else        FIXFI2(n,(SUBF(xn,HALF)));
       FLTIF2(xn, n);
       TNCF2(x1, x);
    }

    /* f  = ((x1 - xn * C1) + (x - x1)) - xn * C2; */
    SUBF3(f, ADDF(SUBF(x1,MPYF(xn,CNST(1.5703125) )), SUBF(x,x1)), MPYF(xn,CNST(4.83826794897e-4) ));

    /* protect against round-off and enhanced precision problems */
    if GTRF(ABSF(f), Pi_Over_Four)
       f = (GTZF(f) ? Pi_Over_Four : NEGF(Pi_Over_Four));

    SQRF2(g,f);

    /* xnum = ((                P1)*g*f + f); */
    /* xnum = (((       P2)*g + P1)*g*f + f); */
    /* xnum = (((P3*g + P2)*g + P1)*g*f + f); */
    POLYF(xnum, g, P, 1 )
    MPYF2(xnum,f);
    ADDF2(xnum,f);

    /* xden = ((((                Q2)*g + Q1)*g + 0.5) + 0.5); */
    /* xden = (((((       Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */
    /* xden = (((((Q4*g + Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */
    POLYF(xden, g, Q, 2 );
    ADDF2(xden,HALF);  /* do not compose these two adds! */
    ADDF2(xden,HALF);

    if ((n & 1) == 0) return      DIVF(xnum, xden);
    if NEZF(xnum)     return NEGF(DIVF(xden, xnum));

    if GTZF(xden) return CNST(-3.402823466E+38) ;
    return CNST( 3.402823466E+38) ;
} /* TANF */

tanh.c/         868562444   0     0     0       1402      `
/****************************************************************************/
/*  tanh  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:36:01 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL TANHF (REAL x)
{
    
    static REAL P[3] =
      {KNST(-0.96437492777225469787e+0),
       KNST(-0.99225929672236083313e+2),
       KNST(-0.16134119023996228053e+4)};

    static REAL Q[3] =
      {KNST(0.11274474380534949335e+3),
       KNST(0.22337720718962312926e+4),
       KNST(0.48402357071988688686e+4)};

    REAL g, w, y, z, Result;

    ABSF2(y,x);

    if GTRF(y, CNST(0.54930614433405484570) ) 
    {
       if GTRF(y, CNST(1.906154746539849754e+01) ) 
       {
          if LSZF(x) return M_ONE;
          return ONE;
       }
       SUBF3(Result, HALF,INVF((EXPF(ADDF(y,y)) + ONE)));
       ADDF2(Result, Result);
       if LSZF(x) NEGF1(Result);
       return Result;
    }

    /* probably not needed if underflow turns into 0.0 */
    /* if LSSF(y, RADIX_to_M_Hlf_MANTISSA) return x; */

    SQRF2(g,y);

    POLYF (Result,g,P,3 );
    POLYbF(y,g,Q,3 );
    DIVF2(Result,y);

    return ADDF(x, MPYF(x,Result));
} /* TANHF */
tanhf.c/        868562444   0     0     0       1242      `
/****************************************************************************/
/*  tanhf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:30 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL TANHF (REAL x)
{
    
    static REAL P[2] =
      {KNST(-0.3831010665e-2),
       KNST(-0.8237728127e+0)};

    static REAL Q[1] =
      {KNST( 0.2471319654e+1)};

    REAL g, w, y, z, Result;

    ABSF2(y,x);

    if GTRF(y, CNST(0.54930614433405484570) ) 
    {
       if GTRF(y, CNST(9.01091334725) ) 
       {
          if LSZF(x) return M_ONE;
          return ONE;
       }
       SUBF3(Result, HALF,INVF((EXPF(ADDF(y,y)) + ONE)));
       ADDF2(Result, Result);
       if LSZF(x) NEGF1(Result);
       return Result;
    }

    /* probably not needed if underflow turns into 0.0 */
    /* if LSSF(y, RADIX_to_M_Hlf_MANTISSA) return x; */

    SQRF2(g,y);

    POLYF (Result,g,P,2 );
    POLYbF(y,g,Q,1 );
    DIVF2(Result,y);

    return ADDF(x, MPYF(x,Result));
} /* TANHF */
time.c/         868562444   0     0     0       500       `
/*****************************************************************************/
/*  TIME.C v1.10#                                                            */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <time.h> 

extern time_t HOSTtime();

time_t time(time_t *timer) 
{
   time_t result;

   result = (time_t)HOSTtime();
   if(timer) *timer = result;
   return(result);
}

tmpfile.c/      868562444   0     0     0       1329      `
/*****************************************************************************/
/*  TMPFILE.C v1.10#                                                         */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    TMPFILE  -  Create a temporary file, and return a pointer to the       */
/*                stream                                                     */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>






/*****************************************************************************/
/* TMPFILE  -  Create a temporary file, and return a pointer to its FILE     */
/*             structure                                                     */
/*****************************************************************************/
FILE *tmpfile(void)
{
   char tfname[L_tmpnam];
   FILE *_fp = (tmpnam(tfname)) ? (fopen(tfname, "wb+")) : NULL;

   if(_fp)
   {
      _SET(_fp, _TMPFILE);
      strcpy(_tmpnams[_fp->fd], tfname);
   }

   return (_fp);
}


tmpnam.c/       868562444   0     0     0       3997      `
/*****************************************************************************/
/*  TMPNAM.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    TMPNAM   -  Generate a unique filename                                 */
/*    _GETNAME -  Generate the character string for the filename             */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>

static char *_getname(int cnt, char *result);


/*****************************************************************************/
/* TMPNAM   -  Generate a unique filename                                    */
/*                                                                           */
/*    This function generates a unique filename, and can be called up to     */
/*    TMP_MAX times.                                                         */
/*                                                                           */
/*****************************************************************************/
char *tmpnam(char *_s)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   static   int   counter           = 0;
            int   fd;
   static   char  tfname[L_tmpnam];
 
   /*------------------------------------------------------------------------*/ 
   /* Get a filename from _GETNAME                                           */
   /*------------------------------------------------------------------------*/ 
   _getname(counter++, tfname);

   /*------------------------------------------------------------------------*/ 
   /* Check to see if the filename exists.  Keep getting filenames until     */
   /* a unique one is found, or this function has reached its limit.         */
   /*------------------------------------------------------------------------*/ 
   while(((fd=open(tfname, O_RDONLY, 0666)) >= 0) && (counter < TMP_MAX))
   {
      close(fd);
      _getname(counter++, tfname);
   }
 
   if(counter >= TMP_MAX) return (NULL);
 
   /*------------------------------------------------------------------------*/ 
   /* If _S is not NULL, store the new filename in it.                       */
   /*------------------------------------------------------------------------*/ 
   if(_s)
   {
      strcpy(_s, tfname);
      return (_s);
   }
 
   return (tfname);
}


/*****************************************************************************/
/* _GETNAME -  Generate the character string for the filename                */
/*                                                                           */
/*    This function takes a number passed to it bu TMPNAM, and generates a   */
/*    filename from it.  It returns a pointer to the filename.               */
/*                                                                           */
/*****************************************************************************/
static char *_getname(int cnt, char *result)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char *end   = result + L_tmpnam -1;
   char *spos;
 
   strcpy(result, P_tmpdir);
   spos = (result + strlen(result));
 
   *(spos++) = 'T';
 
   for(;cnt; cnt /= 10) *(spos++) = ((cnt % 10)+ '0');
 
   for(;spos < end; *(spos++)='0');
   *(end--) = '\0';
 
   return (result);
}


tmzone.c/       868562444   0     0     0       526       `
/*****************************************************************************/
/*  _tz v1.10#                                                               */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                  */
/*****************************************************************************/
#include <time.h>

TZ _tz =
{
   0,                       /* daylight */
   21600,                   /* timezone */
   "CST",                   /* tzname   */
   "DST",                   /* dstname  */
};

toascii.c/      868562444   0     0     0       401       `
/****************************************************************************/
/*  toascii v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int toascii(int c)
{
    return(_toascii(c));
}


tolower.c/      868562444   0     0     0       400       `
/****************************************************************************/
/*  tolower v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int tolower(int c)
{
    return(_tolower(c));
}
toupper.c/      868562444   0     0     0       401       `
/****************************************************************************/
/*  toupper v1.10#                                                          */
/*  Copyright (c) 1993-1977  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int toupper(int c)
{
    return(_toupper(c));
}


trgdrv.c/       868562444   0     0     0       5937      `
/*****************************************************************************/
/*  TRGDRV.C v1.10#                                                          */
/*  Copyright (c) 1996-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/****************************************************************************/
/* Functions:                                                               */
/*    HOSTopen()    -    Sends open command with arguments to the host      */
/*    HOSTclose()   -    Sends close command with arguments to the host     */
/*    HOSTread()    -    Sends read command with arguments to the host      */
/*    HOSTwrite()   -    Sends write command with arguments to the host     */
/*    HOSTlseek()   -    Sends lseek command with arguments to the host     */
/*    HOSTunlink()  -    Sends unlink command with arguments to the host    */
/*    HOSTrename()  -    Sends rename command with arguments to the host    */
/*    GETENV()      -    Get the enviroment value for the passed variable   */
/*                        name                                              */
/*    HOSTTIME()    -    Get the time from the host                         */
/*    HOSTCLK()     -    Get the target clock value (CLK register)          */
/****************************************************************************/
#include "stdio.h"
#include "trgcio.h"
#include <string.h>
#include "time.h"

extern int readmsg(register unsigned char *parm,
               register char *data);
extern void writemsg(unsigned char  command,
                     register unsigned char *parm,
                     register char *data,
                     unsigned int   length);

unsigned char parmbuf[8];


/****************************************************************************/
/* HOSTOPEN()  -  Pass the open command and its arguments to the host.      */
/****************************************************************************/

int HOSTopen(char    *path,
             unsigned flags,
             int      fno)
{
   LOADSHORT(parmbuf,fno,0);
   LOADSHORT(parmbuf,flags,2);

   writemsg(_DTOPEN,parmbuf,path,strlen(path)+1);  /* SEND NULL ACROSS ALSO */
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTCLOSE()  -  Pass the close command and its arguments to the host.    */
/****************************************************************************/

int HOSTclose(int fno)
{
   LOADSHORT(parmbuf,fno,0);

   writemsg(_DTCLOSE,parmbuf,NULL,0);
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTREAD()  -  Pass the read command and its arguments to the host.      */
/****************************************************************************/

int HOSTread(int      fno,
             char    *buf,
             unsigned count)
{
   LOADSHORT(parmbuf,fno,0);
   LOADSHORT(parmbuf,count,2);

   writemsg(_DTREAD,parmbuf,NULL,0);
   readmsg(parmbuf,buf);

   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTWRITE()  -  Pass the write command and its arguments to the host.    */
/****************************************************************************/

int HOSTwrite(int      fno,
              char    *buf,
              unsigned count)
{
   LOADSHORT(parmbuf,fno,0);
   LOADSHORT(parmbuf,count,2);
   writemsg(_DTWRITE,parmbuf,buf,count);
   readmsg(parmbuf,NULL);
   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTLSEEK()  -  Pass the lseek command and its arguments to the host.    */
/****************************************************************************/

fpos_t HOSTlseek(int fno,
		 fpos_t offset,
		 int origin)
{
   LOADSHORT(parmbuf,fno,0);
   LOAD32(parmbuf,offset,2);
   LOADSHORT(parmbuf,origin,6);

   writemsg(_DTLSEEK,parmbuf,NULL,0);
   readmsg(parmbuf,NULL);

   return UNLOAD32(parmbuf,0);
}


int HOSTunlink(char *path)
{
   writemsg(_DTUNLINK,parmbuf,path,strlen(path) + 1);
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}

int  HOSTrename(char *old,
                char *new)
{
   char combined[100];
   int length;
   strcpy(combined,old);
   length = strlen(old)+1;
   strcpy(combined+length,new);
   length += strlen(new) + 1;

   writemsg(_DTRENAME,parmbuf,combined,length);
                                                 /*SEND NULL ACROSS ALSO*/
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}


/****************************************************************************/
/* GETENV()  -  Get the enviroment value for the passed variable name       */
/****************************************************************************/
char *getenv(const char *_string)
{
   static char result[200];
   writemsg(_DTGETENV,parmbuf,(char *)_string,strlen(_string) + 1);
   readmsg(parmbuf,result);

   return (UNLOADSHORT(parmbuf,0) == 0) ? NULL : result;
}

/****************************************************************************/
/* HOSTTIME()  -  Get the time from the host                                */
/****************************************************************************/
time_t HOSTtime()
{
   writemsg(_DTGETTIME,parmbuf,NULL,0);
   readmsg(parmbuf, NULL);

   return((time_t)(UNLOAD32(parmbuf,0)));
}

/****************************************************************************/
/* HOSTclock()  -  Get the current number of clock ticks                    */
/****************************************************************************/
clock_t HOSTclock()
{
   writemsg(_DTGETCLK,parmbuf,NULL,0);
   readmsg(parmbuf, NULL);

   return((clock_t)(UNLOAD32(parmbuf,0)));
}
 

trgmsg.c/       868562444   0     0     0       5526      `
/*****************************************************************************/
/*  TRGMSG.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Bottom level data transfer routines for host communication with the       */
/* target.                                                                   */
/*                                                                           */
/* Functions:                                                                */
/*  writemsg()  -  Sends the passed data and parameters on to the host.      */
/*  readmsg()   -  Reads the data and parameters passed from the host.       */
/*****************************************************************************/
#include "stdio.h"
#include "trgcio.h"


#if BSSCIOBUF
#define DEFCIO(size) unsigned char _CIOBUF_[size]

#elif defined(_MVP_PP) || defined(_MVP_MP)
#pragma SHARED   (_CIOBUF_);
#pragma DATA_SECTION (_CIOBUF_, ".cio");
#pragma DATA_ALIGN   (_CIOBUF_, 4);
#define DEFCIO(size) unsigned char _CIOBUF_[size]

#elif defined(_TMS370C8)
#define STR(x) #x
#define DEFCIO(size) asm("__CIOBUF_: .usect  .cio," STR(size)); \
		     extern far unsigned char _CIOBUF_[size]

#else
#define STR(x) #x
#define DEFCIO(size) asm("__CIOBUF_: .usect  .cio," STR(size) ",4"); \
		     extern unsigned char _CIOBUF_[size]
#endif

DEFCIO(CIOBUFSIZ);


/***************************************************************************/
/*                                                                         */
/*  WRITEMSG()  -  Sends the passed data and parameters on to the host.    */
/*                                                                         */
/***************************************************************************/
void writemsg(unsigned char           command,
              register unsigned char *parm,
              register char          *data,
              unsigned int            length)
{
#if defined(_MVP_PP)
    extern unsigned char *_gen_addr(unsigned char *p);
    register unsigned char *p = _gen_addr(_CIOBUF_);
#else
    register unsigned char * volatile p = (unsigned char *) _CIOBUF_;
#endif

    register unsigned int i;

    /***********************************************************************/
    /* THE LENGTH IS WRITTEN AS A TARGET INT                               */
    /***********************************************************************/ 
    *(unsigned int *)p = length; 
    p += sizeof(unsigned int);

    /***********************************************************************/ 
    /* THE COMMAND IS WRITTEN AS A TARGET BYTE                             */
    /***********************************************************************/ 
    *p++ = command;

    /***********************************************************************/ 
    /* PACK THE PARAMETERS AND DATA SO THE HOST READS IT AS BYTE STREAM    */
    /***********************************************************************/ 
    for (i = 0; i < 8; i++)      PACKCHAR(*parm++, p, i);
    for (i = 0; i < length; i++) PACKCHAR(*data++, p, i+8);

#if defined(_TMS320C5XX) /* LEAD */
    /***********************************************************************/ 
    /* THE EMULATOR BREAKPOINTS IN DECODE PHASE, SO HAVE TO ADD IN SOME    */
    /* NOPS TO MAKE SURE LAST REAL INSTRUCTION COMPLETES BEFORE BREAKPOINT */
    /***********************************************************************/ 
    asm("	nop");
    asm("	nop");
#endif

    /***********************************************************************/
    /* THE BREAKPOINT THAT SIGNALS THE HOST TO DO DATA TRANSFER            */
    /***********************************************************************/
#if defined(_MVP_PP) || defined(_MVP_MP)
    asm("	.system	C$$IO$$");
#else
    asm("	.global	C$$IO$$");
#endif

    asm("	nop");
    asm("C$$IO$$:nop");
}



/***************************************************************************/
/*                                                                         */
/*  READMSG()   -  Reads the data and parameters passed from the host.     */
/*                                                                         */
/***************************************************************************/
readmsg(register unsigned char *parm,
        register char          *data)
{
#if defined(_MVP_PP)
    extern unsigned char *_gen_addr(unsigned char *);
    register unsigned char *p = _gen_addr(_CIOBUF_);
#else
    register unsigned char * volatile p = (unsigned char *) _CIOBUF_;
#endif

    register unsigned int i;
    unsigned int length;

    /***********************************************************************/
    /* THE LENGTH IS READ AS A TARGET INT                                  */
    /***********************************************************************/
    length = *(unsigned int *)p;
    p += sizeof(unsigned int);
    
    /***********************************************************************/
    /* UNPACK THE PARAMETERS AND DATA                                      */
    /***********************************************************************/
    for (i = 0; i < 8; i++) *parm++ = UNPACKCHAR(p, i);
    if (data != NULL) 
       for (i = 0; i < length; i++) *data++ = UNPACKCHAR(p, i+8);
}
trunc.c/        868562444   0     0     0       567       `
/****************************************************************************/
/*  trunc  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:36:01 EDT 1997 */

#include "reald.h"


unsigned  _lmbd (unsigned , unsigned );

REAL TRUNCF(REAL x)
{

   {
      REAL fp, ip;
      CPYF(fp, MODFF(x,&ip));
      return ip;
   }
} /* TRUNCF */

truncf.c/       868562444   0     0     0       568       `
/****************************************************************************/
/*  truncf  v1.10                                                           */
/*  Copyright (c) 1997-1977  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri May 30 15:57:31 EDT 1997 */

#include "realf.h"


unsigned  _lmbd (unsigned , unsigned );

REAL TRUNCF(REAL x)
{

   {
      REAL fp, ip;
      CPYF(fp, MODFF(x,&ip));
      return ip;
   }
} /* TRUNCF */
ungetc.c/       868562444   0     0     0       3430      `
/*****************************************************************************/
/*  UNGETC.C v1.10#                                                          */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    UNGETC   -  Push a character back onto a stream                        */
/*****************************************************************************/
#include <stdio.h>






/*****************************************************************************/
/* UNGETC   -  Push a character back onto a stream                           */
/*                                                                           */
/*    This function returns the character pushed back upon success, or an    */
/*    EOF upon failure.                                                      */
/*                                                                           */
/*****************************************************************************/
int ungetc(int _c, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the character is an EOF, or if an UNGETC has already been performed */
   /* and there is no room left in the buffer, return an EOF.                */
   /*------------------------------------------------------------------------*/
   if(_c == EOF || (_fp->pos < _fp->buf)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the file is in update mode, and is currently writing, change it to  */
   /* read mode.                                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODERW))
   {
      _UNSET(_fp, _MODEW);
      _SET(_fp, _MODER);
   }
 
   /*------------------------------------------------------------------------*/
   /* Set up a buffer if one is needed, and none exists.                     */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      if(setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ) == EOF) return (EOF);
 
   /*------------------------------------------------------------------------*/
   /* Put the character in the buffer, set the _UNGETC flag in the stream,   */
   /* and clear the EOF flag in the stream.                                  */
   /*------------------------------------------------------------------------*/
   *(--_fp->pos) = (unsigned char)_c;
   _SET(_fp, _UNGETC);
   _UNSET(_fp, _STATEOF);

   /*------------------------------------------------------------------------*/
   /* If this is an UNGETC on an empty file, make the end of the read buffer.*/
   /*------------------------------------------------------------------------*/
   if(!_fp->buff_stop) _fp->buff_stop = _fp->buf;

   return ((unsigned char)_c);
}

vfprintf.c/     868562444   0     0     0       2753      `
/*****************************************************************************/
/*  VFRINTF.C v1.10#                                                         */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VFPRINTF -  Print formatted output to a stream                         */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include "format.h"
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
 
 
 
 

/*****************************************************************************/
/* VFPRINTF -  Print formatted output to a stream                            */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream _FP.              */
/*                                                                           */
/*****************************************************************************/
int vfprintf(FILE *_fp, const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (-1);

   return (_printfi(&fptr, _ap, (void *)_fp, _outc, _outs));
 
}
 
 

 


/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


vprintf.c/      868562444   0     0     0       2750      `
/*****************************************************************************/
/*  VPRINTF.C v1.10#                                                         */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VPRINTF  -  Print formatted output to stdio                            */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
 
 
 
 

/*****************************************************************************/
/* VPRINTF  -  Print formatted output to a stdio                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream stdio.            */
/*                                                                           */
/*****************************************************************************/
int vprintf(const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(stdout->fd == -1) return (EOF);

   return (_printfi(&fptr, _ap, (void *)stdout, _outc, _outs));
 
}
 
 
 
 
 


/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }

vsprintf.c/     868562444   0     0     0       2531      `
/*****************************************************************************/
/*  VSPRINTF.C v1.10#                                                        */
/*  Copyright (c) 1995-1977 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VSPRINTF -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);






/*****************************************************************************/
/* VSPRINTF -  Copy formatted output to a string                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
int vsprintf(char *_string, const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;
   *_string = '\0';
   return (_printfi(&fptr, _ap, (void *)_string, _outc, _outs));

}
 
 
 
 


/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
   strncat((char *)_op, &c, 1);
   return(c);
}
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
   strcat((char *)_op, s);
   return(strlen(s));
}
 

divd.asm/       868562436   0     0     0       0         `
divi.asm/       868562436   0     0     0       2829      `
;******************************************************************************
;* divi  v1.10#                                                               *
;* Copyright (c) 1996-1977  Texas Instruments Incorporated                    *
;******************************************************************************
 
; The basic algorithm:
; 
; int __divi (int dividend, int divisor)
; {
;     int negative_quotient = (dividend<0) ^ (divisor<0);
;     register int i;
;     register int shift;
;     int quotient;
; 
;     divident = abs(dividend);
;     divisor  = abs(divisor);
;     shift = _lmbd(1, divisor) - _lmbd(1, dividend);
; 
;     if (dividend < divisor) return 0;
; 
;     divisor <<= shift;
;     shift++;
; 
;     for (i = 0; i < shift; i++)
;       dividend = _subc(dividend, divisor);
; 
;     quotient = dividend << (32-shift) >> (32-shift);
;     return (negative-quotient ? -quotient : quotient);
; }
; 
; Regs used:
; A0 = quotient_shift
; A1 = neg_num, zero_quo
; A2 = mag_num, neg_quo
; A4 = arg1: numerator, abs_num, retval: quotient
; A6 = copy neg_num
; B0 = subc loop counter
; B1 = loop counter, neg_den, mod
; B2 = mag_den, neg_loopcount, modulo_shift
; B3 = return address
; B4 = arg2: denominator, abs_den
; B5 = copy neg_den
;
; Regs killed:
; A0, A1, A2, A4, A6, B0, B1, B2, B4, B5 
;
; Regs used but not killed:
; B3


	.global __divi
__divi:

	 SHRU	.S1	A4,	31,	A1	; neg_num = num < 0
||	 SHRU	.S2	B4,	31,	B1	; neg_den = den < 0

   [ A1] NEG	.L1	A4,	A4		; abs_num = abs(num)
|| [ B1] NEG	.L2	B4,	B4		; abs_den = abs(den)
||	 B	.S2	LOOP			;
 
         NORM	.L1	A4,	A2		; mag_num = norm(abs_num)
||	 NORM	.L2	B4,	B2		; mag_den = norm(abs_den)
||	 MV	.D1	A1,	A6		; copy neg_num
||	 MV	.D2	B1,	B5		; copy neg_den
||	 B	.S1	LOOP			;
 
	 CMPGTU	.L1X	B4,	A4,	A1	; zero_quo = (abs_den > abs_num)
||	 SUB	.L2X	B2,	A2,	B0	; i = mag_den - mag_num
||	 MVK	.S1	31,	A0		;
||	 B	.S2	LOOP			;
 
	 SHL	.S2	B4,	B0,	B4	; abs_den <<= i
||	 CMPLT	.L2	B0,	6,	B2	; check for negative loop counter
||	 SUB	.D2	B0,	6,	B1	; generate loop counter
|| 	 SUB	.L1X	A0,	B0,	A0	; quotient_shift = 31 - i
|| 	 B	.S1	LOOP			;
 
   [ B2] ZERO	.L2	B1			; zero negative loop counter
||	 SUBC	.L1X	A4,	B4,	A4	; abs_num = _subc(abs_num, abs_den)
||	 B	.S2	LOOP			;

LOOP: 
   [ B0] SUBC	.L1X	A4,	B4,	A4	; abs_num = _subc(abs_num, abs_den)
|| [ B0] SUB	.L2	B0,	1,	B0	; i-- (decrement subc counter)
|| [ B1] SUB	.D2	B1,	1,	B1	; i-- (decrement loop counter)
|| [ B1] B	.S1	LOOP			; for
 
	 B	.S2	B3			; return
 
   [!A1] SHL	.S1	A4,	A0,	A4	; quotient = abs_num << quotient_shift
|| [ A1] ZERO	.D1	A4			; if (zero_quo) quotient = zero
||	 XOR	.L1X	A6,	B5,	A2	; neg_quo = neg_num ^ neg_den
 
   [!A1] SHRU	.S1	A4,	A0,	A4	; quotient = abs_num >> quotient_shift
 
   [ A2] NEG	.S1	A4,	A4		; if (neg_quo) quotient = -quotient

	 NOP		2

divu.asm/       868562436   0     0     0       2609      `
;******************************************************************************
;* divu  v1.10#                                                               *
;* Copyright (c) 1996-1977  Texas Instruments Incorporated                    *
;******************************************************************************
 
; The basic algorithm:
; 
; unsigned __divu (unsigned  dividend, unsigned divisor)
; {
;     register int i;
;     register int shift = _lmbd(1, divisor) - _lmbd(1, dividend);
; 
;     if (dividend < divisor) return 0;
; 
;     divisor <<= shift;
;     shift++;
; 
;     for (i = 0; i < shift; i++)
;       dividend = _subc(dividend, divisor);
; 
;     return dividend << (32-shift) >> (32-shift);
; }
; 
; Regs used:
; A0 = quotient_shift
; A1 = mag_den, zero_quo
; A2 = first_div
; A4 = arg1: numerator, retval: quotient
; A6 = copy loop counter
; B0 = subc loop counter
; B1 = mag_num, truth value, loop counter
; B2 = truth value
; B3 = return address
; B4 = arg2: denominator
; 
; Regs killed:
; A0, A1, A2, A4, A6, B0, B1, B2, B4
;
; Regs used but not killed:
; B3

	 .global __divu
__divu:	
	LMBD	1,	A4,	B1	; mag_num = lmbd(1, num), num32 = (magn_num == 0)
||	LMBD	1,	B4,	A1	; mag_den = lmbd(1, den)
||	MVK	32,	A0		; const 32
||	ZERO	A2			; first_div = 1
 
	CMPGTU	B4,	A4,	A1	; zero_quo = (den > num)
||	SUB	A1,	B1,	B0	; i = mag_den - mag_num
||[!B1] MVK	1,	A2		; if (num32) first_div = 1
 
	SHL	B4,	B0,	B4	; den <<= i
|| [B1]	ADD	B0,	1,	B0	; if (!num32) i++
||	MV	B0,	A6		; copy i
 
	CMPGTU	B4,	A4,	B2	; gt = den > num
||	SUB	A0,	B0,	A0	; quotient_shift = 32 - i
||	SHL	A2,	A6,	A2	; first_div <<= i
||	B	LOOP			;
 
   [B1]	ZERO	B2			; num32 && gt 
|| [B2]	MV	B2,	B1		; !(num32 && !gt)
|| [B2]	SHRU	A2,	1,	A2	; first_div >>= 1
||	B	LOOP			;
 
   [B2]	SHRU	B4,	1,	B4	; if (num32 && gt) den >> 1
||[!B1] SUB	A4,	B4,	A4	; if (num32 && !gt) num -= den
||	B	LOOP			;
 
  [!B1]	SHRU	B4,	1,	B4	; if (num32 && !gt) den >> 1
|| [B2]	SUB	A4,	B4,	A4	; if (num32 && gt) num -= den
||	CMPLT	B0,	7,	B2	; check for negative loop counter
||	SUB	B0,	7,	B1	; generate loop counter
||	B	LOOP			;
 
   [B2]	ZERO	B1			; zero negative loop counter
|| [B0]	SUBC	A4,	B4,	A4	; num = subc(num, den)
|| [B0]	SUB	B0,	1,	B0	; i--
||	B	LOOP			;
 
LOOP: 
   [B0]	SUBC	A4,	B4,	A4	; num = subc(num, den)
|| [B0]	SUB	B0,	1,	B0	; i--
|| [B1]	SUB	B1,	1,	B1	; i--
|| [B1]	B	LOOP			; for
 
	B	B3			; return

  [!A1]	SHL	A4,	A0,	A4	; quotient = numerator << quotient_shift
|| [A1]	ZERO	A4			; if (zero_quo) quotient = 0
 
  [!A1]	SHRU	A4,	A0,	A4	; quotient = numerator >> quotient_shift

  [!A1]	ADD	A4,	A2,	A4

	NOP	2

remi.asm/       868562442   0     0     0       3512      `
;******************************************************************************
;* remi  v1.10#                                                               *
;* Copyright (c) 1996-1977  Texas Instruments Incorporated                    *
;******************************************************************************
 
; The basic algorithm:
; 
; int __remi (int dividend, int divisor)
; {
;     int negative_remainder = (dividend<0) && (abs(divisor) <= abs(dividend));
;     register int i;
;     register int shift;
;     int remainder;    
; 
;     divident = abs(dividend);
;     divisor  = abs(divisor);
;     shift = _lmbd(1, divisor) - _lmbd(1, dividend);
; 
;     if (dividend < divisor) return 0;
; 
;     divisor <<= shift;
;     shift++;
; 
;     for (i = 0; i < shift; i++)
;       dividend = _subc(dividend, divisor);
; 
;     remainder = dividend >> shift;
;     return (negative_remainder ? -remainder : remainder);
; }
; 
; Regs used:
; A1 = neg_num, zero_quo
; A2 = mag_num, neg_quo
; A4 = arg1: numerator, abs_num, retval: remainder
; A5 = copy numerator
; A6 = copy neg_num
; B0 = subc loop counter
; B1 = loop counter, neg_den, mod
; B2 = mag_den, neg_loopcount, modulo_shift
; B3 = return address
; B4 = arg2: denominator, abs_den
;
; Regs killed:
; A1, A2, A4, A5, A6, B0, B1, B2, B4
;
; Regs used but not killed:
; B3

        .global __remi
__remi:

        SHRU    .S1     A4,     31,     A1    ; neg_num = num < 0
||      SHRU    .S2     B4,     31,     B1    ; neg_den = den < 0
||      MV      .D1     A4,     A5            ; copy num

   [A1] NEG     .L1     A4,     A4            ; abs_num = abs(num)
|| [B1] NEG     .L2     B4,     B4            ; abs_den = abs(den)
||      B       .S2     LOOP                  ;
 
        NORM    .L1     A4,     A2            ; mag_num = norm(abs_num)
||      NORM    .L2     B4,     B2            ; mag_den = norm(abs_den)
||      MV      .D1     A1,     A6            ; copy neg_num
||      B       .S1     LOOP                  ;
 
        CMPGTU  .L1X    B4,     A4,     A1    ; zero_quo = (abs_den > abs_num)
||      SUB     .L2X    B2,     A2,     B0    ; i = mag_den - mag_num
||      B       .S2     LOOP                  ;
 
        SHL     .S2     B4,     B0,     B4    ; abs_den <<= i
||      CMPLT   .L2     B0,     6,      B2    ; check for negative loop counter
||      SUB     .D2     B0,     6,      B1    ; generate loop counter
||      B       .S1     LOOP                  ;
 
   [B2] ZERO    .L2     B1                    ; zero negative loop counter
||      SUBC    .L1X    A4,     B4,     A4    ; abs_num = _subc(abs_num, abs_den)
||      ADD     .D2     1,      B0,     B2    ; modulo_shift = i + 1
||      B       .S2     LOOP                  ;
LOOP: 
   [B0] SUBC    .L1X    A4,     B4,     A4    ; abs_num = _subc(abs_num, abs_den)
|| [B0] SUB     .L2     B0,     1,      B0    ; i-- (decrement subc counter)
|| [B1] SUB     .D2     B1,     1,      B1    ; i-- (decrement loop counter)
|| [B1] B       .S1     LOOP                  ; for
 
        B       .S2     B3                    ; return
 
  [!A1] SHRU    .S2X    A4,     B2,     B1    ; mod = abs_num >> modulo_shift
 
   [A1] MV      .L2X    A5,     B1            ; if (zero_quo) mod = num
||[!A1] MV      .L1     A6,     A1            ;\ neg_mod = !zero_quo && neg_num
|| [A1] ZERO    .D1     A1                    ;/
 
   [A1] NEG     .L2     B1,     B1            ; if (neg_mod) rem = -rem

        MV      .L1     B1,     A4

        NOP             
remu.asm/       868562442   0     0     0       2281      `
;******************************************************************************
;* remu  v1.10#                                                               *
;* Copyright (c) 1996-1977  Texas Instruments Incorporated                    *
;******************************************************************************
 
; The basic algorithm:
; 
; unsigned __remu (unsigned  dividend, unsigned divisor)
; {
;     register int i;
;     register int shift = _lmbd(1, divisor) - _lmbd(1, dividend);
; 
;     if (dividend < divisor) return 0;
; 
;     divisor <<= shift;
;     shift++;
; 
;     for (i = 0; i < shift; i++)
;       dividend = _subc(dividend, divisor);
; 
;     return dividend >> shift;
; }
; 
; Regs used:
; A1 = mag_den, zero_result
; A4 = arg1: numerator, retval: remainder
; A5 = copy numerator
; A7 = modulo_shift
; B0 = subc loop counter
; B1 = mag_num, truth value, loop counter
; B2 = truth value
; B3 = return address
; B4 = arg2: denominator
; 
; Regs killed:
; A1, A4, A5, A7, B0, B1, B2, B4
;
; Regs used but not killed:
; B3

	.global __remu
__remu:
	LMBD	1,	A4,	B1	; mag_num = lmbd(1, num), num32 = (magn_num == 0)
||	LMBD	1,	B4,	A1	; mag_den = lmbd(1, den)
 
	CMPGTU	B4,	A4,	A1	; zero_result = (den > num)
||	SUB	A1,	B1,	B0	; i = mag_den - mag_num
||	MV	A4,	A5		; save num
 
	SHL	B4,	B0,	B4	; den <<= i
|| [B1]	ADD	B0,	1,	B0	; if (!num32) i++
 
	CMPGTU	B4,	A4,	B2	; gt = den > num
||	B	LOOP			;
 
   [B1]	ZERO	B2			; num32 && gt 
|| [B2]	MV	B2,	B1		; !(num32 && !gt)
||	MV	B0,	A7		; modulo_shift = i
||	B	LOOP			;
 
   [B2]	SHRU	B4,	1,	B4	; if (num32 && gt) den >> 1
||[!B1]	SUB	A4,	B4,	A4	; if (num32 && !gt) num -= den
||	B	LOOP			;
 
  [!B1]	SHRU	B4,	1,	B4	; if (num32 && !gt) den >> 1
|| [B2]	SUB	A4,	B4,	A4	; if (num32 && gt) num -= den
||	CMPLT	B0,	7,	B2	; check for negative loop counter
||	SUB	B0,	7,	B1	; generate loop counter
||	B	LOOP			;
 
   [B2]	ZERO	B1			; zero negative loop counter
|| [B0]	SUBC	A4,	B4,	A4	; num = subc(num, den)
|| [B0]	SUB	B0,	1,	B0	; i--
||	B	LOOP			;
 
LOOP: 
   [B0]	SUBC	A4,	B4,	A4	; num = subc(num, den)
|| [B0]	SUB	B0,	1,	B0	; i--
|| [B1]	SUB	B1,	1,	B1	; i--
|| [B1]	B	LOOP			; for
 
  [!A1]	SHRU	A4,	A7,	A4	; mod = n >> modulo_shift
|| [A1]	MV	A5,	A4		; if (zero_result) rem = num
||	B	B3			; return
 
	NOP	 5

setjmp.asm/     868562442   0     0     0       2658      `
;******************************************************************************
;* SETJMP  v1.10#                                                             *
;* Copyright (c) 1996-1977  Texas Instruments Incorporated                    *
;******************************************************************************
 
        .global  _setjmp, __setjmp, _longjmp
 
;*---------------------------------------------------------------------------
;*   setjmp
;*
;*     C syntax  :   int setjmp(env)
;*                      jmp_buf *env;
;*
;*     Function  : Save callers current environment for a subsequent
;*                 call to longjmp.  Return 0.
;*---------------------------------------------------------------------------
;*
;*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro.
;*         In our implementation, the setjmp macro calls a function "_setjmp".
;*         However, since the user may not include "setjmp.h", we provide
;*         two entry-points to this function.
;*
;*---------------------------------------------------------------------------
 
__setjmp:
_setjmp:

        MV     A4, B4
||	STW    B3, *+A4(48)

        STW    A10, *+A4(0)
||      STW    B10, *+B4(4)
||      B      B3

        STW    A11, *+A4(8)
||      STW    B11, *+B4(12)

        STW    A12, *+A4(16)
||      STW    B12, *+B4(20)

        STW    A13, *+A4(24)
||      STW    B13, *+B4(28)

        STW    A14, *+A4(32)
||      STW    B14, *+B4(36)

        STW    A15, *+A4(40)
||      STW    B15, *+B4(44)
||	ZERO  A4

 
;*---------------------------------------------------------------------------
;*   longjmp
;*
;*     C syntax  :   int longjmp(env, returnvalue)
;*                      jmp_buf *env;
;*                      int     returnvalue;
;*
;*     Function  : Restore the context contained in the jump buffer.
;*                 This causes an apparent "2nd return" from the
;*                 setjmp invocation which built the "env" buffer.
;*                 This return appears to return "returnvalue".
;*                 NOTE: This function may not return 0.
;*---------------------------------------------------------------------------
_longjmp:

	 LDW    *+A4(48), A3

         MV     A4, B6
||	 MV     A4, A6
||       MV     B4, B2

         LDW    *+A6(0), A10
||       LDW    *+B6(4), B10
|| [B2]  MV     B4, A4
|| [!B2] MVK    1, A4

         LDW    *+A6(8), A11
||       LDW    *+B6(12), B11 

	 LDW    *+A6(16), A12
||	 LDW    *+B6(20), B12
 
	 LDW    *+A6(24), A13
||	 LDW    *+B6(28), B13
 
	 LDW    *+A6(32), A14
||	 LDW    *+B6(36), B14
 
	 LDW    *+A6(40), A15
||	 LDW    *+B6(44), B15
||	 B      A3
	 NOP    5

strasg.asm/     868562442   0     0     0       2978      `
;***************************************************************
;* TMS320C6x ANSI C Codegen     Version 0.20                   *
;* Date/Time created: Fri Nov 22 16:51:27 1996                 *
;***************************************************************

;***************************************************************
;* GLOBAL FILE PARAMETERS                                      *
;*                                                             *
;*   Architecture    : TMS320C6200                             *
;*   Endian          : Little                                  *
;*   Interrupt Loops : Disabled                                *
;*   Memory Model    : Small                                   *
;*   Loop Trip Count : Conservatively determined               *
;*   Redundant Loops : Enabled                                 *
;*   Pipelining      : Enabled                                 *
;*   Debug Info      : No Debug Info                           *
;*                                                             *
;***************************************************************

FP	.set	A15
DP	.set	B14
SP	.set	B15

	.sect	".text"
	.global	__strasg

;***************************************************************
;* FUNCTION NAME: __strasg                                     *
;*                                                             *
;*   Regs Modified     : A0,A1,A2,A3,B1,B4,B5                  *
;*   Regs Used         : A0,A1,A2,A3,A4,A6,B1,B3,B4,B5         *
;***************************************************************
__strasg:
;* A3    assigned to dst
;* B4    assigned to src
;* A6    assigned to cnt
;* A4    assigned to ret

         MVC       CSR,B5
||         MV.L2X    A4,B4
||         SUBAW.D1  A6,6,A2
||         MV.S1X    B4,A0

         AND.L1X   -2,B5,A3

         MVC       A3,CSR
L2:   ; PIPE LOOP PROLOG

         LDW.D1    *A0++,A1
||[A2]     ADD.L1    0xfffffffc,A2,A2

[A2]     B.S1      L3
||         LDW.D1    *A0++,A1
||[A2]     ADD.L1    0xfffffffc,A2,A2

[A2]     B.S1      L3
||         LDW.D1    *A0++,A1
||[A2]     ADD.L1    0xfffffffc,A2,A2

[A2]     B.S1      L3
||         LDW.D1    *A0++,A1
||[A2]     ADD.L1    0xfffffffc,A2,A2

[A2]     B.S1      L3
||         LDW.D1    *A0++,A1
||[A2]     ADD.L1    0xfffffffc,A2,A2

         MV.L2X    A1,B1
||[A2]     B.S1      L3
||         LDW.D1    *A0++,A1
||[A2]     ADD.L1    0xfffffffc,A2,A2
L3:   ; PIPE LOOP KERNEL

         STW.D2    B1,*B4++
||         MV.L2X    A1,B1
||[A2]     B.S1      L3
||         LDW.D1    *A0++,A1
||[A2]     ADD.L1    0xfffffffc,A2,A2
L4:   ; PIPE LOOP EPILOG

         STW.D2    B1,*B4++
||         MV.L2X    A1,B1

         STW.D2    B1,*B4++
||         MV.L2X    A1,B1
||         B.S2      B3

         STW.D2    B1,*B4++
||         MV.L2X    A1,B1

         STW.D2    B1,*B4++
||         MV.L2X    A1,B1

         STW.D2    B1,*B4++
||         MV.L2X    A1,B1

         STW.D2    B1,*B4++
	 
         MVC       B5,CSR
